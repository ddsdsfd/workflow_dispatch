[{"categories":["Git"],"content":" 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 介绍 先通过几张图片来大致了解一下 Git 的工作原理吧！ 文章开头的流程图已经简单明了地说明了 Git 常用操作的工作流程，下图换种风格再展示一次： 提到 Git 就会联想到 github, 下图从 Git 的角度简单说明了一些 Github 常用操作的关系： 下面这个图则展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 \"index\" 的区域是暂存区（stage, index），标记为 “master” 的是 master分支所代表的目录树。 HEAD指针: 每个git仓库有且仅有一个HEAD指针，它通常指向當前某个活動的本地分支指针(最初本地仓库master)。也可以是某个提交记录、某个tag，但这会让其处于 detached HEAD（游离头）状态，此状态下的所有提交都无效。 图中我们可以看出此时 \"HEAD\" 实际是指向 master 分支的一个\"游标\"。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的objects标识的区域为 Git 的对象库，实际位于 \".git/objects\" 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 \"git add\"命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 \"git reset HEAD\" 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 \"git rm --cached \u003cfile\u003e\" 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 \"git checkout .\" 或者 \"git checkout -- \u003cfile\u003e\" 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 \"git checkout HEAD .\" 或者 \"git checkout HEAD \u003cfile\u003e\" 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 基本常用命令 第一次使用git的时候，需要设置用户信息和用户邮箱，用于辨识提交者身份。 git config --global user.name \u003cgit用户名\u003e git config --global user.email \u003c邮箱地址\u003e git config --list # 查看当前用户信息 ","date":"2018-10-30","objectID":"/posts/git/:0:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"基本操作 git init # 把当前的目录变成可以用git进行版本控制的git仓库，生成隐藏.git文件。 git add XX # 把xx文件添加到暂存区去。 git add –A # git add --all的缩写，添加全部到暂存区 git add –u # 把文件的删除和修改添加到暂存区（不包括新增） git add . # 监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区 git commit -m \"message\" # 从暂存区提交到本地仓库 git commit -a -m \"message\" # 相当于省略git add，但是无法提交新增的文件 git push origin master # Git会把master分支推送到远程库对应的远程分支上 Tips “commit message\"内容尽量规范！ 当某一次提交后，突然想起漏提交了文件，或不小心提交了不满意的代码时， 可以使用git commit --amend -m \"message\"指令。它可以在不增加一个新的commit-id的情况下将新修改的代码追加到前一次的commit-id中。提交之后message也将被本次的message覆盖，所以还需要再次添加上次的message。 ","date":"2018-10-30","objectID":"/posts/git/:1:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"push git push origin branch-name git push –u origin master git push origin --delete branch-name # 删除远程分支 把当前master分支推送到远程库; -u表示记住分支和地址，下次使用git push即可。 ","date":"2018-10-30","objectID":"/posts/git/:2:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"remote git remote add origin reposityUrl # 关联一个远程库 git remote # 查看远程库的信息 git remote –v # 查看远程库的详细信息 ","date":"2018-10-30","objectID":"/posts/git/:3:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"clone git clone reposityUrl # 从远程库中克隆 git clone -b branchName reposityUrl # 克隆指定分支 ","date":"2018-10-30","objectID":"/posts/git/:4:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"pull git pull 从远程仓库拉下来到本地库然后合并相当于git fetch+git merge。 一般push前先拉去最新版本，避免代码冲突，如果有冲突需要解决了冲突才能提交。 import repositories同步更新 git pull 原链接 git push origin master ","date":"2018-10-30","objectID":"/posts/git/:5:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"fetch git fetch # 从远程库抓下最新版本，但是不合并 fetch是从远程库到本地库，但是未在工作区，需要git merge ","date":"2018-10-30","objectID":"/posts/git/:6:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"merge git merge dev # 在当前的分支上合并dev分支 分支合并也是在本地完成(从本地库到工作区)，新的分支只有在合并后才允许被删除。 如果分支合并是出现冲突需要解决了冲突才能合并，使用git status查看冲突文件。 ","date":"2018-10-30","objectID":"/posts/git/:7:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"branch,checkout git branch # 查看当前所有的分支 git branch name # 创建分支 git branch –r # 看远程所有分支 git branch –a # 查看本地远程分支 git branch –d name # 删除分支 git checkout name # 切换分支 git checkout –b name # 创建并切换到name分支上 git checkout -- file git checkout -- file相当于取消对文档的修改，将最新的本地版本库的本文件复制覆盖它。（比较危险！） ","date":"2018-10-30","objectID":"/posts/git/:8:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"reflog,log git log # 显示所有提交过的版本信息：commit id，提交者，日期 git reflog # 查看历史记录的commit id Tips 想看到自己的操作记录，则可以使用log与reflog，它两个的区别如下: git log命令可以显示所有提交过的版本信息； 如果感觉太繁琐，可以加上参数--pretty=oneline，只会显示版本号和提交时的备注信息。 git reflog可以查看所有分支的所有操作记录。（包括已经被删除的commit记录和reset的操作） ","date":"2018-10-30","objectID":"/posts/git/:9:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"reset git reset --hard HEAD^ git reset --hard HEAD~ # 回退到上一个版本 git reset --hard HEAD~100 # 回退到100个版本 git reset head -- file # 不加file则全部退回 git reset file # 将本地仓库的当前版本退回至暂存区，相当于取消暂存 版本退回是从本地仓库到暂存区，如果已经提交远程库，此时的版本是低于最新的版本的会拒绝提交， 需要用git push -f origin master强制提交。 特别提醒 如果你git reset --hard HEAD^+git push -f origin master执行完，github中的记录和本地文件都会回到退回的状态。简单来说就是一修改了一天的bug,完工后，你这一套操作直接打回原形。别慌（实际内心慌的一麻皮。。。） 通过git log -g命令来找到需要恢复的信息对应的commitid，可以通过提交的时间和记录来辨别, 找到执行reset --hard之前的那个commit对应的commit-id 通过git branch recover_branch commit-id 来建立一个新的分支 这样，就把到commitid为止的代码、各种提交记录等信息都恢复到了recover_branch分支上了。 ","date":"2018-10-30","objectID":"/posts/git/:10:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"status git status 查看你的文件在暂存区和工作目录的状态，默认是较为详细的显示，并提示你可以用何种命令完成你接下来可能要做的事情。 git status -s 较为简单的输出当前的状态，如： $ git status -s M README.md D hello.rb ?? world.java 你可以看到，在简短输出中，有两栏。第一栏是暂存区的，第二栏则是工作目录的。这里表示： README.md 在暂存区中的状态是 modify hello.rd 在工作目录中的状态是 delete world.java 还未添加到版本控制。 ","date":"2018-10-30","objectID":"/posts/git/:11:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"diff git diff XX # 查看XX文件修改了哪些内容 git diff # 工作目录和暂存区 git diff --cached # 暂存区和本地仓库 git diff HEAD # 工作目录和本地仓库 git diff --stat # 显示信息摘要 ","date":"2018-10-30","objectID":"/posts/git/:12:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"rm, mv git rm # 将文件从暂存区和工作目录删除，-f 为强制删除 git rm filename # 删除文件 git rm –r dirname # 删除文件夹 –r 表示递归所有子目录 git rm --cached \u003cpath\u003e # 将文件从暂存区中删除 git mv \u003cold_path\u003e \u003cnew_path\u003e git rm用来删除文件、目录。git mv命令用于移动或重命名一个文件、目录。 比如删除photos文件，本地删除后，远程仓库还会有，所以 git rm -r photos git commit -m \"删除相册\" git push ","date":"2018-10-30","objectID":"/posts/git/:13:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"submodule git submodule add # 添加子模组 git submodule init # 子模组初始化 git submodule update # 子模组更新 Note 当一个远程库有子模组时，直接clone子模组只是一个空文件夹，需要进入子模组的空文件夹init和update才行。 或者使用递归克隆git clone --recursive 远程库 子模组更新后，父模组必须更新，因为需要更新commit id。 ","date":"2018-10-30","objectID":"/posts/git/:14:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"tag git tag v1.0 git tag -a v1.0 # 给最新一次提交打标签 git tag -a \u003ctagname\u003e -m \"标签\" # 指定标签信息命令 git show \u003ctagname\u003e # 显示标签信息 git tag # 查看版本打的Tag git tag -d v1.0 # 删除本地标签 git push origin :refs/tags/v1.0 # 删除远程标签 $ git push [remote] [tag] # 提交指定tag $ git push [remote] --tags # 提交所有tag Note 当你执行git tag -a命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交85fc7e7(最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 $ git log --oneline --decorate --graph * d5e9fc2 (HEAD -\u003e master) Merge branch 'change_site' |\\ | * 7774248 (change_site) changed the runoob.php * | c68142b 修改代码 |/ * c1501a2 removed test.txt、add runoob.php * 3e92c19 add test.txt * 3b58100 (tag: v0.9) 第一次版本提交 ","date":"2018-10-30","objectID":"/posts/git/:15:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"stash git stash # 把当前的工作隐藏起来，等以后恢复现场后继续工作 git stash list # 查看所有被隐藏的文件列表 ","date":"2018-10-30","objectID":"/posts/git/:16:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"gitk gitk # git自带GUI gitk --all github,gitea等平台issue的常用标签 bug 描述的问题是一个bug enhancement 功能增强，没有feature也可以指 New feature or request feature 新功能 duplicate 问题重复 invalid 可用的，不是bug question 疑问，需要进一步的信息 wontfix 不会修复此问题 help-wanted 需要帮助 good first issue Good for newcomers 更多标签 license 其他 github上fork了别人的项目后，再同步更新别人的提交 常用Git命令清单 Gearn Git Branching ","date":"2018-10-30","objectID":"/posts/git/:17:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":null,"content":"暫時不接受友鏈！ Warn: 超過兩年為更新或長期挂掉的站點將被取消！ -- 基本資訊 名稱：菠菜眾長 地址：https://lruihao.cn 描述：不怕萬人阻擋，只怕自己投降 Logo： avatar 或 gravatar 友情提醒 互換友鏈請按以上格式在評論留言。（僅限個人非商業部落格/網站）。 Warn: 網站失效、停止維護、內容不當都可能被取消連結！ 那些不尊重他人勞動成果，轉載不加出處的，或惡意行為的網站，還請您不要來進行交換了。 ","date":"2021-09-19","objectID":"/friends/:0:0","tags":null,"title":"友鏈","uri":"/friends/"},{"categories":null,"content":" 非常感谢朋友们的 coffee ~ 2018.09.28 francs AliPay ￥50 作为一个大学生，第一次在网上收到别人的支持，内心表示受宠若惊又非常开心。拿这 50 块买了半年腾讯云服务器!真的非常感谢老哥的支持！ 2018.10.26 francs QQ ￥8.8 今天学校运动会没课，睡到 9 点多起来看到 QQ 收到一个红包，也是很开心！感谢支持！ 2018.11 francs QQ ￥8.8 2018.12.04 * 昌升 AliPay ￥10 上课的时候听到了支付宝清脆的支付宝到账10元的声音！感谢评论区匿名打赏的兄dei! 2018.12.04 * 昌升 AliPay ￥18 晚上加了一个qq好友，聊天之中又收到支付宝的提示，才知道是谁打赏的，真的很感谢每笔打赏！ 2019.03.19 A*r WechatPay ￥2 2019 收到的第一笔打赏！每一份打赏支持我都心存感激！谢谢各位兄弟！231****047#qq.com 2020.01.17 * 喜洲 QQ ￥20.20 时隔一年再次因为这个博客收到打赏，谢谢大家看得起！有关博客的问题，我能解答的都会帮助你们。101****073 ","date":"2021-09-13","objectID":"/guestbook/:0:0","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":null,"content":" hacknical gitmemory ","date":"2021-09-07","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"期許 不卑不亢，不矜不伐，不驕不躁 不嗔，不怒，不爭，獨善其身 ","date":"2021-09-07","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" “每天早晨叫醒你的不是鬧鐘，而是你的夢想。” 我有過靠著這種信念撐下來的日子，我見過自己努力的樣子，至於現在的自己配不配得上當初努力的自己， 其實也不重要了，還望披荊斬棘，不改初心。 不怕萬人阻擋，只怕自己投降。你如何回憶，決定你是一個怎樣的人！ 從大一伊始，打 ACM 比賽，訓練刷題，再到毅然決然離開實驗室，選擇陌生的 Web 開發，從工作前的一無所知到，到前端開發，後端開發，到教實習生，到面試新人，到開始乏味。這一路走來，好奇心，探索欲，瞎擇騰，或許還有愛意，都是支撐我的動力。 時間並不會因為你的迷茫和遲疑而停留，就像你在看到這篇博客的時候，不知道有多少人正風雨兼程趕赴夢想。沒有誰生來就是神牛，千裏之行，始於足下！比自己優秀的人有很多，永遠不要感動自己，保持謙遜，沈澱自己，感謝每一個曾經努力的自己。不必執著於過去，也不必過度擔憂未來，望披荊斬棘，不忘初心。 最開始寫博客，是在打 ACM 的時候，深受一個學長的博客影響，他的博客是 hexo 搭建的，ID 是 [戎碼一生]，所以我也照葫蘆畫瓢用 hexo 搭建了一個，一用就是 3 年，博客名字原 “博採眾長” 改为 “菠菜眾長”，因為不能用成語作為網站名字，就這個原因。 直到 21 年下半年，升級 windows 11, 系統出了 BUG, 整理磁盤不小心把代碼刪掉了，就乾脆換成 hugo 了。 ","date":"2018-05-28","objectID":"/posts/hello_world/:0:0","tags":null,"title":"Hello World","uri":"/posts/hello_world/"}]