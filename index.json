[{"categories":["Git"],"content":" 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 介绍 先通过几张图片来大致了解一下 Git 的工作原理吧！ 文章开头的流程图已经简单明了地说明了 Git 常用操作的工作流程，下图换种风格再展示一次： 提到 Git 就会联想到 github, 下图从 Git 的角度简单说明了一些 Github 常用操作的关系： 下面这个图则展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 \"index\" 的区域是暂存区（stage, index），标记为 “master” 的是 master分支所代表的目录树。 HEAD指针: 每个git仓库有且仅有一个HEAD指针，它通常指向當前某个活動的本地分支指针(最初本地仓库master)。也可以是某个提交记录、某个tag，但这会让其处于 detached HEAD（游离头）状态，此状态下的所有提交都无效。 图中我们可以看出此时 \"HEAD\" 实际是指向 master 分支的一个\"游标\"。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的objects标识的区域为 Git 的对象库，实际位于 \".git/objects\" 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 \"git add\"命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 \"git reset HEAD\" 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 \"git rm --cached \u003cfile\u003e\" 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 \"git checkout .\" 或者 \"git checkout -- \u003cfile\u003e\" 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 \"git checkout HEAD .\" 或者 \"git checkout HEAD \u003cfile\u003e\" 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 基本常用命令 第一次使用git的时候，需要设置用户信息和用户邮箱，用于辨识提交者身份。 git config --global user.name \u003cgit用户名\u003e git config --global user.email \u003c邮箱地址\u003e git config --list # 查看当前用户信息 ","date":"2018-10-30","objectID":"/posts/git/:0:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"基本操作 git init # 把当前的目录变成可以用git进行版本控制的git仓库，生成隐藏.git文件。 git add XX # 把xx文件添加到暂存区去。 git add –A # git add --all的缩写，添加全部到暂存区 git add –u # 把文件的删除和修改添加到暂存区（不包括新增） git add . # 监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区 git commit -m \"message\" # 从暂存区提交到本地仓库 git commit -a -m \"message\" # 相当于省略git add，但是无法提交新增的文件 git push origin master # Git会把master分支推送到远程库对应的远程分支上 Tips “commit message\"内容尽量规范！ 当某一次提交后，突然想起漏提交了文件，或不小心提交了不满意的代码时， 可以使用git commit --amend -m \"message\"指令。它可以在不增加一个新的commit-id的情况下将新修改的代码追加到前一次的commit-id中。提交之后message也将被本次的message覆盖，所以还需要再次添加上次的message。 ","date":"2018-10-30","objectID":"/posts/git/:1:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"push git push origin branch-name git push –u origin master git push origin --delete branch-name # 删除远程分支 把当前master分支推送到远程库; -u表示记住分支和地址，下次使用git push即可。 ","date":"2018-10-30","objectID":"/posts/git/:2:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"remote git remote add origin reposityUrl # 关联一个远程库 git remote # 查看远程库的信息 git remote –v # 查看远程库的详细信息 ","date":"2018-10-30","objectID":"/posts/git/:3:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"clone git clone reposityUrl # 从远程库中克隆 git clone -b branchName reposityUrl # 克隆指定分支 ","date":"2018-10-30","objectID":"/posts/git/:4:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"pull git pull 从远程仓库拉下来到本地库然后合并相当于git fetch+git merge。 一般push前先拉去最新版本，避免代码冲突，如果有冲突需要解决了冲突才能提交。 import repositories同步更新 git pull 原链接 git push origin master ","date":"2018-10-30","objectID":"/posts/git/:5:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"fetch git fetch # 从远程库抓下最新版本，但是不合并 fetch是从远程库到本地库，但是未在工作区，需要git merge ","date":"2018-10-30","objectID":"/posts/git/:6:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"merge git merge dev # 在当前的分支上合并dev分支 分支合并也是在本地完成(从本地库到工作区)，新的分支只有在合并后才允许被删除。 如果分支合并是出现冲突需要解决了冲突才能合并，使用git status查看冲突文件。 ","date":"2018-10-30","objectID":"/posts/git/:7:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"branch,checkout git branch # 查看当前所有的分支 git branch name # 创建分支 git branch –r # 看远程所有分支 git branch –a # 查看本地远程分支 git branch –d name # 删除分支 git checkout name # 切换分支 git checkout –b name # 创建并切换到name分支上 git checkout -- file git checkout -- file相当于取消对文档的修改，将最新的本地版本库的本文件复制覆盖它。（比较危险！） ","date":"2018-10-30","objectID":"/posts/git/:8:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"reflog,log git log # 显示所有提交过的版本信息：commit id，提交者，日期 git reflog # 查看历史记录的commit id Tips 想看到自己的操作记录，则可以使用log与reflog，它两个的区别如下: git log命令可以显示所有提交过的版本信息； 如果感觉太繁琐，可以加上参数--pretty=oneline，只会显示版本号和提交时的备注信息。 git reflog可以查看所有分支的所有操作记录。（包括已经被删除的commit记录和reset的操作） ","date":"2018-10-30","objectID":"/posts/git/:9:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"reset git reset --hard HEAD^ git reset --hard HEAD~ # 回退到上一个版本 git reset --hard HEAD~100 # 回退到100个版本 git reset head -- file # 不加file则全部退回 git reset file # 将本地仓库的当前版本退回至暂存区，相当于取消暂存 版本退回是从本地仓库到暂存区，如果已经提交远程库，此时的版本是低于最新的版本的会拒绝提交， 需要用git push -f origin master强制提交。 特别提醒 如果你git reset --hard HEAD^+git push -f origin master执行完，github中的记录和本地文件都会回到退回的状态。简单来说就是一修改了一天的bug,完工后，你这一套操作直接打回原形。别慌（实际内心慌的一麻皮。。。） 通过git log -g命令来找到需要恢复的信息对应的commitid，可以通过提交的时间和记录来辨别, 找到执行reset --hard之前的那个commit对应的commit-id 通过git branch recover_branch commit-id 来建立一个新的分支 这样，就把到commitid为止的代码、各种提交记录等信息都恢复到了recover_branch分支上了。 ","date":"2018-10-30","objectID":"/posts/git/:10:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"status git status 查看你的文件在暂存区和工作目录的状态，默认是较为详细的显示，并提示你可以用何种命令完成你接下来可能要做的事情。 git status -s 较为简单的输出当前的状态，如： $ git status -s M README.md D hello.rb ?? world.java 你可以看到，在简短输出中，有两栏。第一栏是暂存区的，第二栏则是工作目录的。这里表示： README.md 在暂存区中的状态是 modify hello.rd 在工作目录中的状态是 delete world.java 还未添加到版本控制。 ","date":"2018-10-30","objectID":"/posts/git/:11:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"diff git diff XX # 查看XX文件修改了哪些内容 git diff # 工作目录和暂存区 git diff --cached # 暂存区和本地仓库 git diff HEAD # 工作目录和本地仓库 git diff --stat # 显示信息摘要 ","date":"2018-10-30","objectID":"/posts/git/:12:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"rm, mv git rm # 将文件从暂存区和工作目录删除，-f 为强制删除 git rm filename # 删除文件 git rm –r dirname # 删除文件夹 –r 表示递归所有子目录 git rm --cached \u003cpath\u003e # 将文件从暂存区中删除 git mv \u003cold_path\u003e \u003cnew_path\u003e git rm用来删除文件、目录。git mv命令用于移动或重命名一个文件、目录。 比如删除photos文件，本地删除后，远程仓库还会有，所以 git rm -r photos git commit -m \"删除相册\" git push ","date":"2018-10-30","objectID":"/posts/git/:13:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"submodule git submodule add # 添加子模组 git submodule init # 子模组初始化 git submodule update # 子模组更新 Note 当一个远程库有子模组时，直接clone子模组只是一个空文件夹，需要进入子模组的空文件夹init和update才行。 或者使用递归克隆git clone --recursive 远程库 子模组更新后，父模组必须更新，因为需要更新commit id。 ","date":"2018-10-30","objectID":"/posts/git/:14:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"tag git tag v1.0 git tag -a v1.0 # 给最新一次提交打标签 git tag -a \u003ctagname\u003e -m \"标签\" # 指定标签信息命令 git show \u003ctagname\u003e # 显示标签信息 git tag # 查看版本打的Tag git tag -d v1.0 # 删除本地标签 git push origin :refs/tags/v1.0 # 删除远程标签 $ git push [remote] [tag] # 提交指定tag $ git push [remote] --tags # 提交所有tag Note 当你执行git tag -a命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交85fc7e7(最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 $ git log --oneline --decorate --graph * d5e9fc2 (HEAD -\u003e master) Merge branch 'change_site' |\\ | * 7774248 (change_site) changed the runoob.php * | c68142b 修改代码 |/ * c1501a2 removed test.txt、add runoob.php * 3e92c19 add test.txt * 3b58100 (tag: v0.9) 第一次版本提交 ","date":"2018-10-30","objectID":"/posts/git/:15:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"stash git stash # 把当前的工作隐藏起来，等以后恢复现场后继续工作 git stash list # 查看所有被隐藏的文件列表 ","date":"2018-10-30","objectID":"/posts/git/:16:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"gitk gitk # git自带GUI gitk --all github,gitea等平台issue的常用标签 bug 描述的问题是一个bug enhancement 功能增强，没有feature也可以指 New feature or request feature 新功能 duplicate 问题重复 invalid 可用的，不是bug question 疑问，需要进一步的信息 wontfix 不会修复此问题 help-wanted 需要帮助 good first issue Good for newcomers 更多标签 license 其他 github上fork了别人的项目后，再同步更新别人的提交 常用Git命令清单 Gearn Git Branching ","date":"2018-10-30","objectID":"/posts/git/:17:0","tags":["Git"],"title":"Git常用指令汇总","uri":"/posts/git/"},{"categories":null,"content":"暫時不接受友鏈！ Warn: 超過兩年為更新或長期挂掉的站點將被取消！ -- 基本資訊 名稱：菠菜眾長 地址：https://lruihao.cn 描述：不怕萬人阻擋，只怕自己投降 Logo： avatar 或 gravatar 友情提醒 互換友鏈請按以上格式在評論留言。（僅限個人非商業部落格/網站）。 Warn: 網站失效、停止維護、內容不當都可能被取消連結！ 那些不尊重他人勞動成果，轉載不加出處的，或惡意行為的網站，還請您不要來進行交換了。 ","date":"2021-09-19","objectID":"/friends/:0:0","tags":null,"title":"友鏈","uri":"/friends/"},{"categories":null,"content":" 非常感谢朋友们的 coffee ~ 2018.09.28 francs AliPay ￥50 作为一个大学生，第一次在网上收到别人的支持，内心表示受宠若惊又非常开心。拿这 50 块买了半年腾讯云服务器!真的非常感谢老哥的支持！ 2018.10.26 francs QQ ￥8.8 今天学校运动会没课，睡到 9 点多起来看到 QQ 收到一个红包，也是很开心！感谢支持！ 2018.11 francs QQ ￥8.8 2018.12.04 * 昌升 AliPay ￥10 上课的时候听到了支付宝清脆的支付宝到账10元的声音！感谢评论区匿名打赏的兄dei! 2018.12.04 * 昌升 AliPay ￥18 晚上加了一个qq好友，聊天之中又收到支付宝的提示，才知道是谁打赏的，真的很感谢每笔打赏！ 2019.03.19 A*r WechatPay ￥2 2019 收到的第一笔打赏！每一份打赏支持我都心存感激！谢谢各位兄弟！231****047#qq.com 2020.01.17 * 喜洲 QQ ￥20.20 时隔一年再次因为这个博客收到打赏，谢谢大家看得起！有关博客的问题，我能解答的都会帮助你们。101****073 ","date":"2021-09-13","objectID":"/guestbook/:0:0","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":null,"content":" hacknical gitmemory ","date":"2021-09-07","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"期許 不卑不亢，不矜不伐，不驕不躁 不嗔，不怒，不爭，獨善其身 ","date":"2021-09-07","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["生活随笔"],"content":"後知後覺 2020 已經過去半年了，由於情緒過於複杂，一直不想去回憶總結那操蛋的一年。今天疫情原因居家辦公，得空靜下來，和自己對話，不知从何說起，想到哪寫到哪吧。 2020 始於新冠，終於疫情。中間夾雜太多遺憾，離別和壓力，20年可以説从年頭到年尾都糟糕透了。 ","date":"2021-06-21","objectID":"/posts/year-2020-2021/:0:0","tags":["总结"],"title":"和自己對話-2020\u00262021 總結","uri":"/posts/year-2020-2021/"},{"categories":["生活随笔"],"content":"離 首先是和 zxm 分手了，過程太糟心的，無疑成為了我一年渾渾噩噩的最大因素。 最後那段時光真的不想記住，這裡也就不再回憶了。就當衹是 19 年底最後的願望落空了吧。 分開后那個夏天酒勁大了很多， 也開始抽煙，記不得抽了多少隻烟，只知道手臂上多了幾個抽煙發呆不小心燙的煙疤。 分開後，各種不理智的打擾幾乎都是我。如果知道註定終有一別，我們應該好好說一聲再見的。 而不是一年后我看夠了你討厭我的樣子，諾諾地放下，不斷告訴自己她已經走遠了。 此次“告別”，拖的晚了些，真是抱歉了，和你在一起度過整个大學生涯，湖工一草一木都曾見證過我們的甜蜜，一起在ACM刷題，一起在圖書館學習，一起吃吃吃，當然還有煩人的爭吵。那過去四年，我從未感覺過的幸福，以及…遺憾。 其實和你分開到現在，我總會在半夜想起你，可這讓我真的太糾結了。想到你會讓我很痛苦，可若讓我忘記你，我是真的捨不得。可能你不會知道，其他人也不會知道，還記得你送我的哪個熱水袋的毛絨娃娃嗎，它也許知道。 可是，我真的要和過去的你説再見了，上次一別，希望往後不要再見面了，無法想像再見到你我的心情會有多複杂。 不過，還是要好好謝謝你，謝謝你的陪伴，山水一程，已是萬幸。 感謝你讓我在大學時光有了目標，變得更好。 感謝你，給了我愛與被愛的能力，讓我遇見更完整的自己。 其實我早就知道不可能了， 我早該放下了，衹是過去的記憶和承諾拖著我不肯讓我嚮前走去。 沒關係了，我們總要告別舊的人才能獲得新的生活。置死後生。 我知道，其實多年后，這段感情仍會是我的一個心結， 其實多年后，一切也不重要了，不介意心裡留一塊地給過去的你我。 ","date":"2021-06-21","objectID":"/posts/year-2020-2021/:1:0","tags":["总结"],"title":"和自己對話-2020\u00262021 總結","uri":"/posts/year-2020-2021/"},{"categories":["生活随笔"],"content":"別 生離死別，20年的末梢，平安夜那天，也是考研的第一天。那晚，我們一個大學四年朝夕相處的室友兄弟，選擇了燒炭，操，真他媽傻逼！說好的考研後“慶功宴”呢，還等著和你吹牛逼呢。 跨年前一周，幾個兄弟在微信QQ群裡給你發消息都一直不回，直到跨年那晚想打電話給你吹吹牛逼，微信 QQ 電話都打不通，就感覺不對勁了。由於比較晚了，想著第二天再打電話給你爸問問情況，我和小賀先後打過去，直接愣住了，你爸的語氣讓人心疼。那天的披薩如同嚼蠟。 之後呢，你爸爸為數不多發的幾條朋友圈都是在表達想你。 兄弟，一路走好，此刻沒有你愛的利群，點隻雙囍送你，永遠懷念。 ","date":"2021-06-21","objectID":"/posts/year-2020-2021/:2:0","tags":["总结"],"title":"和自己對話-2020\u00262021 總結","uri":"/posts/year-2020-2021/"},{"categories":["生活随笔"],"content":"\u0026 20 年呢也不是沒有收獲，那段時間一個人瘋狂加班。 部門的核心代碼幾乎都是我在維護優化和新增功能，也得以抬愛成為開發組組長。 還帶了20的實習生，从最基礎的開始教他們（真的累。。。），可惜最後留下的沒幾個，太過於浮躁了。 然後也學會了做飯，而且賣相口味都還可以，只可惜沒能給她做了。 我，不過是一介普通人， 生活，需要沉澱。 2021 寫到這吧，要熱飯了，年底再來… 又开始找回自己，和自己做朋友，让自己开心真是一件平凡的伟事。 ","date":"2021-06-21","objectID":"/posts/year-2020-2021/:3:0","tags":["总结"],"title":"和自己對話-2020\u00262021 總結","uri":"/posts/year-2020-2021/"},{"categories":["JavaScript"],"content":"起因 起因 事情是這樣，年前和朋友一起合租了一個房子，然後捏，生活嘛，除了開心，當然是乾飯最大啦！ 自然就會有購物，買菜等日常消費，那就要記賬，一開始是各自記在手機的便簽上，最後再算一下； 三個人，一共七种組合消費，排除各自消費的三種情況，也有四種 (AB, AC, BC, ABC)。好麻煩啊！！！ 經過 作為一個程序猿，怎麼能接受這麼麻煩的記賬方式呢，拿起筆就開始畫，於是有了下面這張圖的公式。簡單說明一下就是： 設前面說的四種組合為: X1, X2, X3, X4，個人實際付款總額為: Y1, Y2, Y3，那麼帶入未知數，我們就可以算出每個人最後結算時的錢: S1, S2, S3， 綜上所述，很好理解，當 S \u003e= 0 時，收紅包，當 S \u003c 0 時，發紅包。 OK，一個簡單的初中方程式已經到位了，下一步，思考一下，用什麼來運作這個這個方程。來，先跑個題，春節期間，不是每天都要在騰訊文檔上填表記錄活動軌跡嗎？ 再回來，那不如就用 excel 實現吧，三個人都可以在手機上編輯。好的，說做就做。 一頓操作，10 minutes later… 只新建了一個 excel 文件，O.o! 不會 excel，果斷放棄，另尋他路。 結果 回到本職，那不如寫個網站吧，可是畢業後，學生機服務器也過期了，怎麼搞？那就寫個純前端的，數據呢存哪裡？ 別急，重新擼一擼需求先： 存取消費數據 計算每月，實付(總分)，應付以及最後計算結算金額 按月查詢，月結賬單 三人皆可編輯 主要就是存取數據這點，沒有服務器，數據庫怎麼實現？ valine 可以實現無後端，那我是不是也可以，leancloud 文檔走一波，然後“數據表”設計一下，其實是 leancloud-storage Object ，於是有了以下東西，源碼放在 http://github.com/Lruihao/bill-note bill-note ","date":"2021-03-02","objectID":"/posts/bill_note/:0:0","tags":["Frontend","JavaScript","leancloud","VueJS"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill_note/"},{"categories":["JavaScript"],"content":"數據設計 去 leancloud 创建一个应用，再新增一个 Bill Class, 补充一下字段： name type description pay Number 消费金额 pay_description String 消费描述 pay_type String 消费类型 pay_user String 付款人 ","date":"2021-03-02","objectID":"/posts/bill_note/:1:0","tags":["Frontend","JavaScript","leancloud","VueJS"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill_note/"},{"categories":["JavaScript"],"content":"主要邏輯 ","date":"2021-03-02","objectID":"/posts/bill_note/:2:0","tags":["Frontend","JavaScript","leancloud","VueJS"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill_note/"},{"categories":["JavaScript"],"content":"初始化 set for yourself. AV.init({ appId: '', appKey: '', serverURL: '' }); ","date":"2021-03-02","objectID":"/posts/bill_note/:2:1","tags":["Frontend","JavaScript","leancloud","VueJS"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill_note/"},{"categories":["JavaScript"],"content":"存數據 //記賬提交按鈕事件監聽 document.querySelector('.submit').addEventListener('click',function(event){ event.preventDefault(); let formPay = document.querySelector('#form-pay'); let bill = new AV.Object('Bill'); bill.set('pay', Number(formPay.pay.value)); bill.set('pay_type', Number(formPay.pay_type.value)); bill.set('pay_user', Number(formPay.pay_user.value)); bill.set('pay_description', formPay.pay_description.value); bill.save().then((object) =\u003e { formPay.reset(); }, (function (error) { console.log(JSON.stringify(error)); alert('保存失敗'); })) }); ","date":"2021-03-02","objectID":"/posts/bill_note/:2:2","tags":["Frontend","JavaScript","leancloud","VueJS"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill_note/"},{"categories":["JavaScript"],"content":"取數據 /** * 獲取歷史消費記錄數據 * @param [start=0] 開始位置 * @param [count=15] 每次查詢筆數 */ function getBillData(start = 0,count = 15) { queryBill.descending('createdAt') .skip(start * count).limit(count) .find().then(function (response) { let billLength = response.length; if(billLength \u003e 0){ billVm.noMore = (billLength !== count) ? true : false; for(bill of response){ billVm.bills.push({ pay: bill.attributes.pay, payType: payType[bill.attributes.pay_type], payUser: payUser[bill.attributes.pay_user], payDescription: bill.attributes.pay_description, payDt: new Date(bill.createdAt).toLocaleString() }) } } else { billVm.noMore = true; } }); } /** * 獲取月賬單數據 * @param month 年月份 fmt: yyyy-MM */ function getMonthBill(month){ let dateTime = `${month}00:00:00` let startMonth = new Date(dateTime); let nextMonth = new Date(new Date(dateTime).setMonth(startMonth.getMonth() + 1)); let startDateQuery = new AV.Query('Bill'); startDateQuery.greaterThanOrEqualTo('createdAt', startMonth); let endDateQuery = new AV.Query('Bill'); endDateQuery.lessThan('createdAt', nextMonth); let MonthBillQuery = AV.Query.and(startDateQuery, endDateQuery); MonthBillQuery.find().then(function(response){ billVm.monthBill = { payType0: 0, payType1: 0, payType2: 0, payType3: 0, payUser0: 0, payUser1: 0, payUser2: 0 }; for(bill of response){ let {pay, pay_type, pay_user} = bill.attributes; billVm.monthBill[`payType${pay_type}`] += pay; billVm.monthBill[`payUser${pay_user}`] += pay; } }); } ","date":"2021-03-02","objectID":"/posts/bill_note/:2:3","tags":["Frontend","JavaScript","leancloud","VueJS"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill_note/"},{"categories":["JavaScript"],"content":"技術棧 leancloud-storage Vue.js HTML,CSS,JS 總結 簡單總結一下，登录功能不做，安不安全自己说了算。删除修改功能也不做，直接上 leacloud 操作，css 美化的样式也不写，干净又卫生！ 然后衍生一下，什么过年斗地主，天炸，麻将，字牌记账系统那不也是同理可得嘛！ over! ","date":"2021-03-02","objectID":"/posts/bill_note/:3:0","tags":["Frontend","JavaScript","leancloud","VueJS"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill_note/"},{"categories":["生活随笔"],"content":" 回顾2019，是从“迷茫”到“忙”的一年，何为“迷茫”，何为“忙”。 ","date":"2020-01-16","objectID":"/posts/year-2019/:0:0","tags":["总结"],"title":"2019年度总结","uri":"/posts/year-2019/"},{"categories":["生活随笔"],"content":"上半年·湘潭·湖南工程学院 java 2019年伊始，步入大三下学期， 回顾大学前段生涯，无论是ACM是实验室里所学的所谓算法(甚至现在已经忘记怎么写了)， 还是自己一时兴起折腾的简单网页，似乎都无法支撑自己找到工作，甚至实习。 于是乎，浓浓的\"迷茫\"和\"焦虑\"感来了。 由于\"卓越计划\"的缘故，大四我们就不在学校了，要去企业实习。 这正是我所担心的，没有一技之长，哪家公司会收我。 不得不走上新的学习旅程，我选择了java，我也不知道为什么选java，反正就是选了。 制定了计划当然要执行啊，所以从2019年刚开始，我先把java的基础复习了一遍， 然后在慕课网上开始刷课，然后碰到一些小例子时都会编程练习。 从我的博客记录显示，java学习一直持续到5月初。 期间还折腾了一段时间python，正是这小段时间的python， 让我有机会接触到了\"麻小科技\"，这里非常感谢捷哥，算起来也是认识多年的朋友了， 后来也认识了涛哥，非常感谢涛哥在技术方面给了我很多的指导。 后来机缘巧合之下，一场面试让我不得不考虑暂停我的java计划， 这场面试就是富士康C次的一场面试，面试官庆哥也就是我未来的主管， 当时庆哥面试时问了我们三个很简单的问题一个css选择器，一个数据库的查询，还有一个是css的盒子模型。 我当时数据库的那个联合查询没答出来，一紧张内外边距的英文padding和margin也忘记怎么拼写了。 双方还问了一些了解性的问题面试就这样结束了。 很幸运过了一两天就收到了邮件。 ","date":"2020-01-16","objectID":"/posts/year-2019/:1:0","tags":["总结"],"title":"2019年度总结","uri":"/posts/year-2019/"},{"categories":["生活随笔"],"content":"下半年·深圳·富士康科技集团 php 然后时间一晃而过来到了下半年，我来到了陌生的深圳，来到了富士康。 来到深圳后一周，捷哥说一起吃个饭，晚上一起走走， 然后那天我就去找捷哥吃饭了，吃的是顺德公的猪肚包鸡，很好吃。 然后也见到了涛哥，感觉涛哥是一个很谦逊很和蔼的人。非常感谢捷哥和涛哥在我刚来深圳的热情款待。 安顿好后，也开始实习工作了，前面的我所说的\"忙\"呢其实指的是\"充实\"， 在庆哥带领下的学习工作让我每天都过很充实，每天都能感觉到自己一点点的进步，真的非常庆哥的悉心培养。 从html5到php，然后ajax交互，SQL等等，几乎是从零开始教学，效果完全比得上外面的培训机构。 那段时间每天上班测试，学习MES系统流程，然后下班后学习新的知识，每天都能感觉充实带来的愉悦感。 不仅只有学习还有测试，公司的测试比在学校的考试真实多了，公司是要你真的掌握，所以会有理论知识学习，还会有实际操作。 后来大概12月初又学习了，部门平台的模组开发，12月份汇报，自己整体评价很行，松了一口气。 12月底正式接手了项目，拿到的新项目是两支论坛模组。 由于手上不够的原因，我被安排做前端开发，本以为前端会很容易。一直以来大家也都这样认为。 可是自己实际开发后才知道前端也是很容易出bug的，并且有时候前端的bug往往让你不知所措。 一切还需继续努力！ 12月26日，zxm考研结束，来深圳找我玩，和她一起在深圳逛了逛，去了深圳湾。 本来她还想去动物园的，但是老是睡过头，所以就没去了哈哈哈哈。 虽然我知道zxm喜欢吃肯德基，以前在湘潭也常陪她去， 但这一次深圳之旅，我才发现她真的太爱吃了，搞的我的不敢给她吃太多。 又不忍心拒绝她吃，所以来深圳就吃了好几次肯德基和麦当劳。 来到20年初，部门聚餐吃海鲜，和大家部门内的同事也都熟了，大家都很好相处， 很庆幸所在部门大家都是很好的学习工作氛围，没有那种老练职场的尔虞我诈。 1月初的一个周末还很荣幸的受邀参加了麻小科技的年会，和捷哥涛哥一起爬南山，然后一起在粗茶淡饭吃饭， 认识了很多很优秀的朋友，有在华为的，有腾讯的，也有清华博士在读的等等， 听他们说了一些话都觉得很有道理。 下午还一起去打了棋牌室打了桌球和麻将。 感觉陕西麻将和长沙麻将有点像，但和我们那的麻将打法略有不同。（输了十块哈哈哈哈） ","date":"2020-01-16","objectID":"/posts/year-2019/:2:0","tags":["总结"],"title":"2019年度总结","uri":"/posts/year-2019/"},{"categories":["生活随笔"],"content":"总结 总的来说，19 年还算顺利，下半年的实习没向家里要钱，凭自己能力\"活着\"，只希望 20 年和 zxm 更好，顺利毕业，活的更好！ ","date":"2020-01-16","objectID":"/posts/year-2019/:3:0","tags":["总结"],"title":"2019年度总结","uri":"/posts/year-2019/"},{"categories":["JavaScript"],"content":"注意 JS的加载分为两个部分：下载和执行。 浏览器在执行HTML的时候如果遇到\u003cscript\u003e时会停止页面的渲染,去下载和执行js的文件直接遇见\u003c/scirpt\u003e会继续渲染页面。故浏览器在执行js文件的时候浏览器表现为一片空白,为了解决这个问题ECMAScript定义了defer和async两个属性用于控制JS的下载和执行。 不带任何属性 同步模式，又称阻塞模式，我们平时使用的最多的一种方式。当浏览器解析到\u003cscript\u003e标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，是个同步阻塞的过程。 一般建议把\u003cscript\u003e标签放在\u003cbody\u003e结尾处，这样尽可能减少页面阻塞。 而如果想要异步执行script，则可以给其加上async或defer属性。 \u003cscript\u003e defer defer属性在HTML解析期间异步下载文件，并且只在HTML解析完成后才执行它。对于defer，我们可以理解是将外链的js放在了页面底部。js的加载不会阻塞页面的渲染和资源的加载。不过defer会按照原本的js的顺序执行，所以如果前后有依赖关系的js可以放心使用。 \u003cscript defer\u003e async async属性会在HTML解析期间异步下载文件，并在完成下载后立即暂停HTML解析器去执行script中的代码。在执行过程中浏览器处于阻塞状态，响应不了任何需求。如果js前后有依赖性，用async，就很有可能出错。 \u003cscript async\u003e 区别 ","date":"2019-09-08","objectID":"/posts/async_defer/:0:0","tags":["JavaScript","defer","async","Frontend"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async_defer/"},{"categories":["JavaScript"],"content":"相同点 加载文件时不阻塞页面渲染 对于inline的script无效（只适用有src的外部js） 使用这两个属性的脚本中不能调用document.write方法 有脚本的onload的事件回调 ","date":"2019-09-08","objectID":"/posts/async_defer/:1:0","tags":["JavaScript","defer","async","Frontend"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async_defer/"},{"categories":["JavaScript"],"content":"区别点 html4.0中定义了defer；html5.0中定义了async 浏览器支持不同 每一个async属性的脚本都在它下载结束之后立刻执行，同时会在window的load事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行。 那么这三种方式各在什么情况下使用呢？ 通常来说，尽可能使用async，然后是defer，最后不使用属性。 并遵循以下规则： 如果脚本是模块化的，并且不依赖于任何脚本，则使用async。 如果脚本依赖于或依赖于另一个脚本，则使用defer。 如果脚本很小并且有async脚本依赖该脚本，则不加属性。 兼容性 Internet Explorer 10、Firefox、Opera、Chrome 和 Safari 支持 async 属性。 所有主流浏览器都支持defer属性。 参考 https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html https://www.jianshu.com/p/17dc82bf08f1 ","date":"2019-09-08","objectID":"/posts/async_defer/:2:0","tags":["JavaScript","defer","async","Frontend"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async_defer/"},{"categories":["Java"],"content":" 基本功能： 给定一个密钥，读取文件内容，加密后，输出到另外一个文件。 这里使用文件输入流读取文件内容，然后每个字节和密码进行异或简单加密。加密完成，使用文件输出流写入另一个文件中。解密和加密方法一样。利用的是对同一个数异或两遍其值不变的性质。因此一个程序可以完成加密和解密功能。只需修改文件名即可。 文件加密解密 package cn.lruihao.base; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class EncryptFile { public static void main(String[] args) throws IOException { byte pwd=123;//加密/解密密码 FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/EncryptFile.java\");//待加密文件 FileOutputStream fout=new FileOutputStream(\"encrypted.txt\");//已加密文件 System.out.println(\"开始加密。。。\"); int n=f.available()/5; byte[] b=new byte[n];//以一个字节数组的长度读取和复制 int count=0; while((count=f.read(b,0,n))!=-1) { //写入之前先加密/解密 for(int i=0;i\u003ccount;i++) { b[i]=(byte)(b[i]^pwd);// } fout.write(b,0,count); } System.out.println(\"完成加密\"); f.close(); fout.close(); // f=new FileInputStream(\"encrypted.txt\"); // fout=new FileOutputStream(\"unencrypted.txt\"); // System.out.println(\"开始解密。。。\"); // n=f.available()/5; // b=new byte[n];//以一个字节数组的长度读取和复制 // count=0; // while((count=f.read(b,0,n))!=-1) { // //写入之前先加密/解密 // for(int i=0;i\u003ccount;i++) { // b[i]=(byte)(b[i]^pwd); // } // fout.write(b,0,count); // } // System.out.println(\"完成解密\"); // f.close(); // fout.close(); } } 文件复制 package cn.lruihao.base; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileStreamCopy { public static void main(String[] args) throws IOException { int size; FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/FileStreamCopy.java\"); FileOutputStream fout=new FileOutputStream(\"copy-of-file.txt\"); System.out.println(\"总长度：\"+(size=f.available())); int n=size/10; System.out.print(\"使用单字节方法读取后：\"); for(int i=0;i\u003cn;i++) { fout.write(f.read()); } System.out.println(\"剩余长度：\"+f.available()); System.out.println(\"读取一个字节数组后：\"); byte b[]=new byte[n]; f.read(b); fout.write(b); System.out.println(\"剩余长度：\"+f.available()); System.out.println(\"读取余下数据：\"); int count=0; while((count=f.read(b,0,n))!=-1) { //System.out.println(count); fout.write(b,0,count); } System.out.println(\"剩余长度：\"+f.available()); f.close(); fout.flush(); fout.close(); } } package cn.lruihao.base; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class BufferedStreamCopy { public static void main(String[] args) throws IOException { FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/BufferedStreamCopy.java\"); FileOutputStream fout=new FileOutputStream(\"copy-of-file.txt\"); BufferedInputStream bis=new BufferedInputStream(f); BufferedOutputStream bos=new BufferedOutputStream(fout); System.out.println(\"开始复制。。。\"); int n=f.available()/5; byte[] b=new byte[n]; int count=0; while((count=bis.read(b,0,n))!=-1) { bos.write(b,0,count); } System.out.println(\"复制完成\"); bis.close(); bos.flush(); bos.close(); f.close(); fout.flush(); fout.close(); } } ","date":"2019-05-02","objectID":"/posts/byteio/:0:0","tags":["Java","Backend"],"title":"文件加密解密（字节流）","uri":"/posts/byteio/"},{"categories":["生活随笔"],"content":" 时间过得真快，一下从大一到了大三，马上就要实习毕业等等了。 Success 富士康在学校有一个春招的机会，我和朋友抱着侥幸的心理去试了试。 虽然深知自己还身有很多缺点，但是不面试不知道，一面试都暴露出来了，以下记录一下自己的不足之处： php和sql的经典组合虽然有所接触了解，但是确实什么都会，得花时间学 html/css等虽然平时折腾博客这些应用的比较多，但是今天竟然紧张地忘记了margin和padding都不会写了 如上一条，公众表现能力有待加强。正如当今“酒香也怕巷子深”，何况“不香”。 惊喜的事说来就来，本来知道自己这么多缺点，这么菜后，觉得这个实习的offer是没戏了，没想到下午技术主管微信发来消息，说录用了。当场懵逼，受宠若惊的感觉！非常谢谢面试官老师！ 无论生活还是学习，希望以后的自己一定要保持一颗谦逊爱学的心，早日实现全栈工程师的梦想，还有早点存钱把大学学费的贷款还掉！ ","date":"2019-04-24","objectID":"/posts/1thintervivew/:0:0","tags":["面试"],"title":"第一次面试经历","uri":"/posts/1thintervivew/"},{"categories":["ACM"],"content":" 我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ 设公鸡，母鸡，小鸡数目分别为x,y,z(x\u003c=20,y\u003c=33,z\u003c=100) 约束条件 x+y+z=100 5x+3y+z/3=100 算法分析 若依次枚举x,y,x,则至少尝试21*34*100=71400次，显然效率太低。 在x,y的数目确定后，z的数目也就确定下来了100-x-y，无须再进行枚举，此时约束条件只有一个5x+3y+z/3=100.只需枚举x,y，共21*34=714次。 算法设计 #include\u003cstdio.h\u003e int main(){ int x,y,z; for(x=0;x\u003c=20;x++) //21*34=714 for(y=0;y\u003c=33;y++){ z=100-y-x; if(z%3==0 \u0026\u0026 (5*x+3*y+z/3)==100){//限定z能被3整除，进一步提高效率 printf(\"cock number:%d\\t\",x); printf(\"hen number:%d\\t\",y); printf(\"chick number:%d\\n\",z); } } return 0; } 运行解 cock number:0 hen number:25 chick number:75 cock number:4 hen number:18 chick number:78 cock number:8 hen number:11 chick number:81 cock number:12 hen number:4 chick number:84 ","date":"2019-03-30","objectID":"/posts/bqbj/:0:0","tags":["ACM"],"title":"百钱百鸡（枚举法）","uri":"/posts/bqbj/"},{"categories":["linux"],"content":"极速方便的一键配置与管理，免除繁琐的命令行操作，通过Web面板一键即可操作实现。可选择安装lamp或者lnmp环境，可创建及管理网站，可创建及管理数据库，可创建及管理FTP等等。宝塔官网介绍 系统要求 操作系统：全新系统(支持CentOS、Ubuntu、Debian、Fedora、Deepin)， 确保是干净的操作系统，没有安装过其它环境带的Apache/Nginx/php/MySQL 宝塔Linux6.0版本是基于centos7开发的，强烈建议使用centos7.x 系统 内存要求：内存要求最低512MB，推荐768MB以上，纯面板约占系统60MB内存 安装方法 官方号称2分钟装好面板，一键管理服务器。 使用 SSH 连接工具，如宝塔远程桌面助手连接到您的 Linux 服务器后，挂载磁盘，根据系统执行相应命令开始安装（大约2分钟完成面板安装）： yum install -y wget \u0026\u0026 wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026\u0026 sh install.sh wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 sudo bash install.sh wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 bash install.sh wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026\u0026 bash install.sh 搭建ftp和云盘服务器 可以很傻瓜式的搭建自己的云盘，和平时用的比较多的ftp服务器。搭建静态网站也可以用ftp来上传文件。 ","date":"2019-03-18","objectID":"/posts/bt/:0:0","tags":["linux","server","宝塔面板"],"title":"宝塔面板安装","uri":"/posts/bt/"},{"categories":["Java"],"content":"主要方法 static type[] copyof(type[] original,int length) static int binarysearch(type[] a,type key) static boolean equals(type[] a,type[] b) static void fill(type[] a,type val) static void fill(type[] a,int fromindex,int toindex,type val) static void sort(type[] a) ","date":"2019-01-18","objectID":"/posts/arrays/:0:1","tags":["Java","Collator","Comparator","Backend"],"title":"Arrays类及基本使用","uri":"/posts/arrays/"},{"categories":["Java"],"content":"实例代码 package Arrays; import java.text.Collator; import java.util.Arrays; import java.util.Comparator; public class ArraysDemo { public static void main(String agrs[]) { Integer arr[]=new Integer[9]; for(int i=0;i\u003c9;i++) arr[i]=(int)(Math.random()*100); //显示，排序数组 System.out.print(\"原内容：\"); display(arr); Arrays.sort(arr); System.out.print(\"排序后：\"); display(arr); //将值-1分配给数组arr中下标从0到3-1的位置 Arrays.fill(arr, 0,3,-1); System.out.print(\"fill()后：\"); display(arr); //搜索23 System.out.print(\"值23的位置：\"); int index =Arrays.binarySearch(arr, 23);//二分查找 System.out.print(index);//如果查找不到，index为负 System.out.print(\"\\n插入0在3号位置：\"); Arrays.fill(arr,3,4,0); display(arr); System.out.print(\"值0的位置：\"); index =Arrays.binarySearch(arr, 0); System.out.print(index); Integer arr2[]=new Integer[8]; arr2=Arrays.copyOf(arr, arr2.length); //复制8个 System.out.print(\"\\n复制后的数组：\"); display(arr2); if(Arrays.equals(arr, arr2)) System.out.println(\"两数组相同！\"); else System.out.println(\"两数组不相同！\"); System.out.println(\"----------------------------------------\"); String[] str = {\"计算机\",\"黄桑\",\"通信\",\"李瑞豪\"}; Arrays.sort(str); for(int i=0;i\u003cstr.length;i++) System.out.print(str[i]+\" \"); System.out.println(\"\"); //Collator类是用来执行分语言环境的字符串比较，这里用的CHINA Comparator com=Collator.getInstance(java.util.Locale.CHINA);//获取Comparator对象，参数表示按中文排序 //根据指定的 \"比较器\" 产生的顺序对 \"指定对象数组\" 进行排序 Arrays.sort(str,com);//sort(T[] a,Comparator\u003c?super T\u003ec) for(int i=0;i\u003cstr.length;i++) System.out.print(str[i]+\" \"); } static void display(Integer arr[]) { for(int i=0;i\u003carr.length;i++) System.out.print(arr[i]+\" \"); System.out.println(\"\"); } } ","date":"2019-01-18","objectID":"/posts/arrays/:0:2","tags":["Java","Collator","Comparator","Backend"],"title":"Arrays类及基本使用","uri":"/posts/arrays/"},{"categories":["Java"],"content":"程序运行结果 原内容：41 0 44 96 49 96 30 6 87 排序后：0 6 30 41 44 49 87 96 96 fill()后：-1 -1 -1 41 44 49 87 96 96 值23的位置：-4 插入0在3号位置：-1 -1 -1 0 44 49 87 96 96 值0的位置：3 复制后的数组：-1 -1 -1 0 44 49 87 96 两数组不相同！ ---------------------------------------- 李瑞豪 计算机 通信 黄桑 黄桑 计算机 李瑞豪 通信 ","date":"2019-01-18","objectID":"/posts/arrays/:0:3","tags":["Java","Collator","Comparator","Backend"],"title":"Arrays类及基本使用","uri":"/posts/arrays/"},{"categories":["Java"],"content":"标识符： 给类，接口，方法或者变量起名字的符号 ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:1","tags":["Backend","Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"组成规则： A:英文字母大小写 B:数字 C:_和$ ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:2","tags":["Backend","Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"注意事项： A:不能以数字开头 B:不能是Java中的关键字 C:区分大小写 Student,student 这是两个名称 ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:3","tags":["Backend","Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"常见命名方式： A:包 其实就是文件夹,用于解决相同类名问题 全部小写 单级：com 多级：cn.itcast B:类或者接口 一个单词：首字母大写 Student,Person,Teacher 多个单词：每个单词的首字母大写 HelloWorld,MyName,NameDemo C:方法或者变量 一个单词：全部小写 name,age,show() 多个单词：从第二个单词开始，每个单词首字母大写 myName,showAllStudentNames() D:常量 一个单词：全部大写 AGE 多个单词：每个单词都大写，用_连接 STUDENT_MAX_AGE ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:4","tags":["Backend","Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["生活随笔"],"content":" 以前每年都会在QQ空间写每年的总结，可是现在已经过了肆意在空间写说说的年纪了。所幸还有博客这一席之地。 18年主要的收获，经历大概就在下面了，可还是没有学到什么硬本事，寒假还是要学习一下 java 和 jsp。 首先最开心的是在狗年刚开始3月底回到湘潭后，拿下了驾照（年前挂了一次很不爽），可以开共享汽车了，体验共享时代的新滋味。 然后是11月份的软考，虽然没有认真准备考试，还是过了（上午压线）。不知道是今年的容易还是怎么的，反正我考完就觉得挺容易的。 5月底搭建了现在这个hexo静态博客，还收到了一些网上朋友的打赏，感谢！ 用打赏的钱买了两个服务器一个国内的，一个国外的。搭了一个文件浏览器作为自己的~~网盘~~,还搭了一个ss梯子供自己翻墙使用。 参加了 2018 年 ACM 的湘潭全国邀请赛，在湘大，虽然很遗憾没有拿奖，但就当走过这步吧，略过。 暑假结束，退出了 E313ACM 实验室，也就没有刷题打比赛了。 大二获得了个国家励志，还不错。hhhh有奖金! 真的很菜但是退实验之前，学院的编程比赛还是运气好拿了个三等奖。 ","date":"2019-01-12","objectID":"/posts/year-2018/:0:0","tags":["总结"],"title":"2018年度总结","uri":"/posts/year-2018/"},{"categories":["hexo","Git"],"content":"备份hexo博客 //如果themes/next(主题文件)下面有.git，请删除这个.git文件夹。 cd hexo git init //初始化本地仓库 git add source themes scaffolds _config.yml package.json package-lock.json //将必要的文件依次添加 git commit -m \"blog hexo\" git branch hexo //新建hexo分支 git checkout hexo //切换到hexo分支上 git remote add origin git@github.com:username/username.github.io.git //将本地与Github项目对接 git push origin hexo //push到Github项目的hexo分支上 ","date":"2018-11-03","objectID":"/posts/blog_backup/:0:1","tags":["hexo","Git","Nodejs"],"title":"hexo 博客源码备份","uri":"/posts/blog_backup/"},{"categories":["hexo","Git"],"content":"在其他终端克隆和更新hexo博客 nodejs,git,hexo已经安装好,即搭建完成 克隆hexo博客备份 git clone -b hexo git@github.com:username/username.github.io.git //将Github中hexo分支clone到本地 cd user.github.io npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init 这样我们的备份文件就会原封不动的拷贝到本地。 写新文章并备份和部署（备用操作） 其实源码拷下来了，这步不做我们也知道怎么做了，完全没必要按照教程死搬硬套。灵活一点就行了。 //进入username.github.io文件夹,应是hexo分支 git pull origin hexo //本地和远端的融合 hexo new post \"new post name\" //写新文章 git add source git commit -m \"xxx\" git push origin hexo //备份 hexo d -g //部署 参考 ","date":"2018-11-03","objectID":"/posts/blog_backup/:0:2","tags":["hexo","Git","Nodejs"],"title":"hexo 博客源码备份","uri":"/posts/blog_backup/"},{"categories":["生活随笔"],"content":"备案 经过时间长达20多天的备案之旅今天终于结束了，也闭馆了20多天，也按相关要求把ICP备案号和公安备案号加载了网站和博客底部。只是今天去岳塘分局签网络安全告知书的时候不小心把身份证落在那个办公室了。亏我走之前一秒还在提醒自己，唉！不过那个办公室的大姐姐挺好的，前面跟我说好星期一来，我还今天上午提前给她打了电话，她还下楼给我开办公楼楼道的门禁，还有我身份证落在那里她说先帮我收着，有时间再去拿！总之，这个姐姐的服务态度五星好评！手动@岳塘分局B204的姐姐。 备案完成也算放下一块提着的石头，可以睡个好觉了！ZzZzzzz ","date":"2018-10-29","objectID":"/posts/beian/:0:0","tags":["生活随笔","网站备案"],"title":"网站备案之旅","uri":"/posts/beian/"},{"categories":["ACM"],"content":"题目链接：小希的迷宫 ","date":"2018-08-01","objectID":"/posts/hdu1272/:1:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272(并查集or树性质)","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"并查集： 无回路 单连通 并查集做，首先想到的是判断两个点是否连通，不连通就合并，已连通的话说明会形成回路，则可以判定No，交了一发错了。 想了一下没有考虑到多个连通域的情况，该题必须只有一个连通域 ","date":"2018-08-01","objectID":"/posts/hdu1272/:2:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272(并查集or树性质)","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"树的性质： 既然单连通无回路，则这肯定是一棵树；那么edge=v-1; 最后注意空树的情况，至于自环我这里No也过了，没有去验证自环Yes的情况了 //并查集 #include\u003cbits/stdc++.h\u003eusing namespace std; int pre[100001]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int a,int b){ int x=find(a),y=find(b); if(x!=y) pre[y]=x; } int main(){ int a,b,flag,i,sum; while(1) { flag = 0; while(~scanf(\"%d%d\",\u0026a,\u0026b) \u0026\u0026 a!=0 \u0026\u0026 b!=0){ if(a==-1 \u0026\u0026 b==-1) return 0; if(pre[a]==0)pre[a]=a; if(pre[b]==0)pre[b]=b; if(find(a)==find(b))flag = 1; else if(flag!=1) join(a,b); } for(sum = 0,i=1;i\u003c100001;i++){ if(pre[i]==i)sum++; pre[i] = 0; } if(sum\u003e1 || flag == 1) printf(\"No\\n\"); else printf(\"Yes\\n\"); } } //1 2 3 4 0 0 No 没有连通 //0 0 Yes //1 1 0 0 No(该代码) //树性质 #include \u003cstdio.h\u003ebool s[100001]; int main() { int a,b,i,len,num,v; for(i=0;i\u003c100001;++i) s[i]=false; len=0,num=0,v=0; while(1) { scanf(\"%d%d\",\u0026a,\u0026b); if(a==-1\u0026\u0026b==-1) break; if(a==0\u0026\u0026b==0) { if(v==0) { printf(\"Yes\\n\"); continue; } if(num==len-1) //划重点！！ printf(\"Yes\\n\"); else printf(\"No\\n\"); num=len=v=0; for(i=0;i\u003c100001;++i) s[i]=false; continue; } v=1; if(s[a]==false) len++;//点数 if(s[b]==false) len++; s[a]=s[b]=true; num++;//边数 } return 0; ","date":"2018-08-01","objectID":"/posts/hdu1272/:3:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272(并查集or树性质)","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"并查集入门推荐：超有爱的并查集~ 题目链接：畅通工程 题意分析： 首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。 #include\u003ciostream\u003e#include\u003ccstdio\u003eusing namespace std; int pre[1010]; int findd(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } int main(){ int n,m,i,sum,r1,r2,star,end1; while(scanf(\"%d\",\u0026n)\u0026\u0026n){ sum=n-1; for(i=1;i\u003c=n;i++) pre[i]=i; scanf(\"%d\",\u0026m); while(m--){ scanf(\"%d%d\",\u0026star,\u0026end1); r1=findd(star); r2=findd(end1); if(r1!=r2){ pre[r1]=r2; sum--; } } printf(\"%d\\n\",sum); } return 0; } 基础回顾： find()函数找根结点的两种写法如下： 第一种递归： int find(int x) { return x == pre[x] ? x : find(pre[x]); } 第二种： int find(int x) { int root, temp; root = x; while(root != pre[root]) root = pre[root]; while(x != root) { temp = pre[x]; pre[temp] = root; x = temp; } return root; } 合并函数 void join(int x,int y){ int fx=find(x); int fy=find(y); if(fx!=fy) pre[fx]=fy; } ","date":"2018-07-31","objectID":"/posts/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/:0:0","tags":["ACM","并查集","HDU","C++","C"],"title":"畅通工程-HDU-1232(并查集经典模板)","uri":"/posts/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/"},{"categories":["ACM"],"content":"两题水过，暴力，找规律。。 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:0:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"托米的赌球 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:1:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"托米的划分 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:2:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"a #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ int c[13],d[13]={100,50,20,10,5,2,1,50,20,10,5,2,1}; int i,t; cin\u003e\u003et; int a,b; while(t--){ memset(c,0,sizeof(c)); cin\u003e\u003ea\u003e\u003eb; for(i=0;i\u003c7;i++){ int x=0; if(a\u003ec[i]){ x=a/d[i]; c[i]+=x; a-=x*d[i]; } } for(i=7;i\u003c13;i++){ int x=0; if(b\u003ec[i]){ x=b/d[i]; c[i]+=x; b-=x*d[i]; } } cout\u003c\u003cc[0]; for(i=1;i\u003c13;i++) cout\u003c\u003c\" \"\u003c\u003cc[i]; cout\u003c\u003cendl; } return 0; } ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:3:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"b f(n)=f(n-1)+n-1; #include\u003cbits/stdc++.h\u003eusing namespace std; long long sum; int main(){ int n; int t; cin\u003e\u003et; while(t--){ sum=1; cin\u003e\u003en; if(n==1) sum=0; for(int i=3;i\u003c=n;i++) sum+=i-1; cout\u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:4:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["others"],"content":"在线算法 在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。 在计算机科学中，一个在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。相对的，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。例如，选择排序在排序前就需要知道所有待排序元素，然而插入排序就不必。 因为在线算法并不知道整个的输入，所以它被迫做出的选择最后可能会被证明不是最优的，对在线算法的研究主要集中在当前环境下怎么做出选择。对相同问题的在线算法和离线算法的对比分析形成了以上观点。如果想从其他角度了解在线算法可以看一下流算法（关注精确呈现过去的输入所使用的内存的量），动态算法（关注维护一个在线输入的结果所需要的时间复杂度）和在线机器学习。 一个很好的展示在线算法概念的例子是 加拿大旅行者问题，这个问题的目标是在一个有权图中以最小的代价到达一个目标节点，但这个有权图中有些边是不可靠的可能已经被剔除。然而一个旅行者只有到某个边的一个端点时才能确定该边是否已经被移除了。最坏情况下，该问题会变得简单了，即所有的不确定的边都被移除该问题将会变成通常的最短路径问题。 ","date":"2018-07-26","objectID":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/:1:0","tags":["在线离线算法"],"title":"在线离线算法","uri":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"},{"categories":["others"],"content":"离线算法 离线算法( off line algorithms)，是指基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。 设计策略 在执行算法前输入已知的基本假设 前提 具有问题完全信息 算法设计策略都是基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果，通常将这类具有问题完全信息前提下设计出的算法称为离线算法( off line algorithms) ","date":"2018-07-26","objectID":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/:2:0","tags":["在线离线算法"],"title":"在线离线算法","uri":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"},{"categories":["ACM"],"content":"Codeforces Round 498 (Div. 3) A. Adjacent Replacements（水）","date":"2018-07-22","objectID":"/posts/adjacent-replacements/","tags":["Codeforces","ACM","C++"],"title":"Adjacent Replacements","uri":"/posts/adjacent-replacements/"},{"categories":["ACM"],"content":"A. Adjacent Replacements 第一次打cf就做出一道这样的找规律的题，打到自闭。 #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ int n,a[1001]; cin\u003e\u003en; int i; int flag=0; for(i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; if(!(a[i]\u00261)) a[i]--; if(!flag) {cout\u003c\u003ca[i];flag=1;} else cout\u003c\u003c\" \"\u003c\u003ca[i]; } return 0; } ","date":"2018-07-22","objectID":"/posts/adjacent-replacements/:0:0","tags":["Codeforces","ACM","C++"],"title":"Adjacent Replacements","uri":"/posts/adjacent-replacements/"},{"categories":["ACM"],"content":"链接:https://www.nowcoder.com/acm/contest/133/A 来源:牛客网 ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:0","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"题目描述 现在有一棵被Samsara-Karma染了k种颜色的树，每种颜色有着不同的价值,Applese觉得Samsara-Karma染的太难看了，于是打算把整棵树重新染成同一种颜色，但是，由于一些奥妙重重的原因，每一次染色Applese可以选择两个有边相连的点，将其中一个染成另一个的颜色。而进行一次这样的操作需要付出两种颜色价值和的代价， 现在，Applese的钱要用来买书(game)，所以他想要最小化代价 ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:1","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"输入描述: 输入包括若干行第一行包括一个数n，表示这棵树有n个节点第二行包括n个数，第i个数表示第i个节点的颜色coli 注意：一个颜色的标号即价值接下来的n - 1行，每行包括两个数u, v，表示u节点与v节点之间有一条无向边n ≤ 100000, 1 ≤ coli ≤ 1e9，数据保证是一棵树 ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:2","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"输出描述: 输出包括一行第一行包括一个数，表示最小代价 ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:3","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"示例1 输入 4 2 3 4 3 1 2 2 3 3 4 输出 12 蒟蒻暴力枚举-_-! #include \u003cbits/stdc++.h\u003e using namespace std; const int MAXN=1e5+10; int a[MAXN]; map\u003cint, int \u003ema; set\u003cint\u003ese; int x[MAXN],y[MAXN]; int main() { int n; scanf(\"%d\",\u0026n); for (int i = 1; i \u003c=n ; ++i) { scanf(\"%d\",\u0026a[i]); se.insert(a[i]); } for (int i = 1; i \u003cn ; ++i) { scanf(\"%d%d\",\u0026x[i],\u0026y[i]); } long long ans=1e14,sum=0; set\u003cint\u003e::iterator it; for (it=se.begin(); it !=se.end() ; ++it) { sum=0; for (int j = 1; j \u003c=n ; ++j) { if((*it)!=a[j]) sum+=((*it)+a[j]); } ans=min(sum,ans); } printf(\"%lld\\n\",ans); return 0; } 最后想说这都过了什么鬼，不会数据这么弱吧？？！?我只枚举了最小的价值颜色的情况，唉，不管了不管了。 #include\u003cbits/stdc++.h\u003eusing namespace std; int a[1000000],n,m,k=1,t,ans=0; int main() { scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;++i) scanf(\"%d\",\u0026a[i]); sort(a+1,a+n+1); for(int i=2;i\u003c=n;++i) if(a[i]!=a[1]) ans+=a[i]+a[1]; printf(\"%d\",ans); return 0; } ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:4","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"假设有一个n行m列的迷宫，每个单位要么是空地(用1表示)要么是障碍物(用0表示). 如和找到从起点到终点的最短路径？利用BFS搜索，逐步计算出每个节点到起点的最短距离， 以及最短路径每个节点的前一个节点。最终将生成一颗以起点为根的BFS树。此时BFS可以求出任意一点到起点的距离。 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"图 1 3 0 21 23 2 0 17 20 22 4 0 14 0 0 5 0 12 15 18 6 8 10 0 19 7 9 11 13 16 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:1:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"输入 6 5 1 1 0 1 1 1 0 1 1 1 1 0 1 0 0 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:2:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"输出 1 2 4 5 6 8 10 12 14 17 20 21 23 12//最短距离 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:3:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"代码 #include\u003ciostream\u003e#include\u003cqueue\u003e#include\u003ccstdio\u003e#include\u003ccstring\u003e#include\u003cvector\u003eusing namespace std; const int maxn=100+5; int G[maxn][maxn]; //存图的d=id int path[maxn]; //存每个节点的父节点，即路径 int n,m; //n行 m列 int k=1;//记录编号 int end_num; int vx[5] = {-1,1,0,0}; //vx vy用来计算一个节点周围上下左右4个节点 int vy[5] = {0,0,-1,1}; bool vis[maxn][maxn]; //判断某节点是否已经被访问过 struct node { int x; int y; int id; int parent=0; node(int a,int b,int c) { x=a; y=b; id=c; } }; int main() { //freopen(\"in.txt\",\"r\",stdin); memset(G,0,sizeof(G)); memset(vis,0,sizeof(vis)); memset(path,0,sizeof(path)); cin\u003e\u003en\u003e\u003em; for(int i=1; i\u003c=n; i++) for(int j=1; j\u003c=m; j++) { cin\u003e\u003eG[i][j]; } queue\u003cnode\u003e q; node v=node(1,1,1); q.push(v); vis[1][1]=1; while(!q.empty()) { node u=q.front(); q.pop(); path[u.id]=u.parent;//记录每个点的父节点 for(int i=0; i\u003c4; i++) { int tx=u.x+vx[i]; int ty=u.y+vy[i]; if(G[tx][ty]\u0026\u0026!vis[tx][ty])//有路可走且未访问 { vis[tx][ty]=1; //cout\u003c\u003ctx\u003c\u003cty\u003c\u003cendl; node v=node(tx,ty,++k); end_num=k; v.parent=u.id; q.push(v); } } } vector\u003cint\u003e ans; //cout\u003c\u003cend_num\u003c\u003cendl; while(end_num)//从后面开始找父亲节点 { ans.push_back(end_num); end_num=path[end_num]; } int s=0; while(!ans.empty()) { s++; cout\u003c\u003c*(ans.end()-1)\u003c\u003c' ';//ans最后一个元素是0 ans.pop_back(); } cout\u003c\u003cendl\u003c\u003cs-1; return 0; } ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:4:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"百度知道 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1、每行数字左右对称，由1开始逐渐变大，然后变小，回到1。 2、第n行的数字个数为n个。 3、第n行数字和为2^(n－1)。 4、每个数字等于上一行的左右两个数字之和。可用此性质写出整个帕斯卡三角形。 5、将第2n+1行第1个数，跟第2n+2行第3个数、第2n+3行第5个数……连成一线，这些数的和是第2n个斐波那契数。将第2n行第2个数，跟第2n+1行第4个数、第2n+2行第6个数……这些数之和是第2n-1个斐波那契数。 6、第n行的第1个数为1，第二个数为1×(n-1)，第三个数为1×(n-1)×（n-2）/2，第四个数为1×(n-1)×（n-2）/2×（n-3）/3…依此类推。 此数列中各行中的数字正好是二项式a+b乘方后，展开始终各项的系数。如： (a+b)^1=a^1+b^1 (a+b)^2=a^2+2ab+b^2 (a+b)^3=a^3+3a^2b+3ab^2+b^3 …… (a+b)^6=a^6+6a^5b+15a^4b^2+20a^3b^3+15a^2b^4+6ab^5+b^6（注意发现规律） …… 二项式展开式：","date":"2018-07-22","objectID":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/:0:0","tags":["数学","杨辉三角"],"title":"杨辉三角","uri":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"},{"categories":["ACM"],"content":"广度优先搜索（BFS） 广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。访问了就入队。 ","date":"2018-07-22","objectID":"/posts/dfs_bfs/:0:1","tags":["ACM","BFS","DFS","搜索","C","C++"],"title":"深搜广搜","uri":"/posts/dfs_bfs/"},{"categories":["ACM"],"content":"深度优先搜索（DFS） 深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。 #include \u003cbits/stdc++.h\u003e#define N 5 using namespace std; int maze[N][N] = {//无权有向图邻接矩阵 { 0, 1, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 0 } }; int visited[N]; void DFS(int start) { cout \u003c\u003c start\u003c\u003c \" \"; visited[start] = 1; for (int i = 0; i \u003c N; i++) { if (!visited[i] \u0026\u0026 maze[start][i] == 1)//没访问过且为邻居节点 DFS(i); } } void BFS(int start){ queue\u003cint\u003e Q;//队列 Q.push(start); visited[start] = 1; while (!Q.empty()) { int front = Q.front();//头 cout \u003c\u003c front \u003c\u003c \" \"; Q.pop(); for (int i = 0; i \u003cN; i++) { if (!visited[i] \u0026\u0026 maze[front][i] == 1) { visited[i] = 1; Q.push(i); } } } } int main() { memset(visited,0,sizeof(visited)); for (int i = 0; i \u003c N; i++)//不连通的情况 { if (visited[i] == 1)//访问过 continue; DFS(i); } cout\u003c\u003cendl; memset(visited,0,sizeof(visited)); for (int i = 0; i \u003c N; i++)//不连通的情况 { if (visited[i] == 1)//访问过 continue; BFS(i); } return 0; } 传送门 ","date":"2018-07-22","objectID":"/posts/dfs_bfs/:0:2","tags":["ACM","BFS","DFS","搜索","C","C++"],"title":"深搜广搜","uri":"/posts/dfs_bfs/"},{"categories":["ACM"],"content":"时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 有一个长度为n的序列a，已知a[1]=a[n]=1，且对于2 \u003c= x \u003c= n，a[x] / a[x-1]是以下三个数字之一 [ 1，-2，0.5 ],问有多少种不同的序列满足题意。 两个序列不同当且仅当它们有至少一个位置上的数字不同，序列a可以为任何实数。 输入描述: 一个整数 表示n (1\u003c= n \u003c= 1e3) 输出描述: 一个整数 表示答案模109+7 示例1 输入 5 输出 7 解题思路： 整体来看，a[x] = a[x-1] * [1, -2, 0.5]，那么等于从n-1个[1,-2,0.5]中选出n-1个数值相乘（a[x-1]=a[x-2] * [1,-2,0.5]同理化简式子）， 最后答案要是1，所以-2就必须有偶数个，同理0.5的个数要等于-2.顺序无关. 那所有的转换中，就只要保证有若干组(-2,-2,0.5,0.5)存在 表示偶数个2的个数与偶数个0.5的个数组合；组合数用二项式系数，杨辉三角来求。 #include \u003cbits/stdc++.h\u003eusing namespace std; const int maxn = 1e3 + 5; const int mod = 1e9 + 7; long long c[maxn][maxn]; int main(){ for(int i = 0; i \u003c maxn; i++){//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(int j = 1; j \u003c i; j++) c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod; } int n; while(~scanf(\"%d\", \u0026n)){ n--; long long ans = 0; for(int i = 0; i*2 \u003c= n; i += 2){ ans = (ans%mod + (c[n][i]*c[n-i][i])%mod)%mod; } printf(\"%lld\\n\", ans); } return 0; } ","date":"2018-07-18","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B18-%E5%BA%8F%E5%88%97/:0:0","tags":["组合数学","ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛18-序列","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B18-%E5%BA%8F%E5%88%97/"},{"categories":["ACM"],"content":"弱鸡还是弱鸡啊最简单的背包问题——。——！ ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:0:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["ACM"],"content":"1) 问题描述: 假设有一个能装入总体积为T的背包和n件体积分别为W1，W2，···，Wn的物品，能否从n件物品中挑选若干件恰好装满背包，即使W1+W2+···+Wn=T，要求找出所有满足上述条件的解。例如：当T=10，共6件物品，物品的体积为{1，2，3，4，5，8}，那么可找到下列4组解：（1，2，3，4）、（1，4，5）、（2，3，5）、（2、8）。 ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:1:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["ACM"],"content":"2) 实现提示： 可利用回溯法的设计思想来解决背包问题。首先，将物品排成一列，然后顺序选取物品装入背包，假设已选取了前i件物品之后背包还没有装满，则继续选取第i+1件物品，若该件物品“太大”不能装入，则丢弃而继续选取下一件，直至背包装满为止。但如果在剩余的物品中找不到合适的物品以填满背包，则说明“刚刚”装入背包的那件物品“不合适”，应将它取出“丢弃一边”，继续再从“它之后”的物品中选取，如此重复，直至求得满足条件的解，或者无解。由于回溯求解的规则是“后进先出”，因此要用到栈。 使用栈作为该程序的数据结构，利用栈进行语法检查，以深度优先的搜索方式解空间，实现递归过程和函数的调用，在设计时还使用C语言的数组及其循环语言来实现程序。 运用回溯法解题，在搜索解空间树时，只要其左儿子节点是一个可行结点，搜索就进入左子树，在右子树中有可能包含最优解是才进入右子树搜索。否则将右子树剪去。 #include \u003cstdio.h\u003e#include \u003cwindows.h\u003e#define size 50 struct stacks { int data[size]; int top; } stack; void backpack(int number,int V,int w[]){ int i,j=1,k=0; int flag=0; do { while (V \u003e 0 \u0026\u0026 k \u003c= number) { if (V \u003e= w[k]) { stack.data[stack.top] = k;//第k个物品的体积下标 stack.top++; V -= w[k]; } k++; } if (V == 0) { flag=1; printf(\"第%d个符合条件的解：\", j); for (i = 0; i \u003c stack.top; i++) { printf(\"%d \", w[stack.data[i]]); } j++; printf(\"\\n\"); } //k满时回溯 k = stack.data[--stack.top]; stack.data[stack.top] = 0; V += w[k]; k++; } while (!(stack.top == 0 \u0026\u0026 k == number)); if(!flag){ printf(\"背包无解！\\n\"); } } void judge(int number,int V,int w[]){ int i,s = 0; for (i = 0; i \u003c number; i++) s = s + w[i]; if(V \u003e s){ printf(\"背包无解！\\n\"); exit(0); } if(V==s){ printf(\"只有一个符合条件的解：%d\\n\", V); exit(0); } } int main() { int w[size]; int V; int i = 0; int j = 0; int number; printf(\"\\t**简单背包问题**\\n\\n\"); printf(\"\\n请输入可供选择装入物品的个数：\\n\"); scanf(\"%d\", \u0026number); printf(\"\\n请输入各件物品的体积：\\n\"); for (i = 0; i \u003c number; i++) scanf(\"%d\", \u0026w[i]); //排序 for(i=0;i\u003cnumber;i++) for(j=i+1;j\u003cnumber;j++) if(w[i]\u003ew[j]){ w[i]=w[i]^w[j]; w[j]=w[i]^w[j]; w[i]=w[i]^w[j]; } printf(\"\\n请输入背包的总体积：\\n\"); scanf(\"%d\", \u0026V); while(V \u003c 0){ printf(\"输入背包体积错误！重新输入！\\n\"); scanf(\"%d\",\u0026V); } judge(number,V,w); //初始化栈 for (i = 0; i \u003c number; i++) stack.data[i] = 0; stack.top = 0; backpack(number,V,w); return 0; } --这么简单的问题我都费力，太辣鸡了 ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:2:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["生活随笔"],"content":"呃呃呃呃呃，今天四六级考试我昨天才知道，而就在昨天做计算机组成原理的课设接线的时候，我买了一个域名lruihao.cn 做完后实验后开开心心回到宿舍解析域名，实名认证什么，coding和github双部署什么的，在一切都完成后本打算享受地躺在床上欣赏一下自己的“杰作”的， 可是最后部署失败，作为小白的我，当然看不懂，然后又各种百度谷歌，翻博客，还是没有解决，于是乎我刚刚搞好的www.lruihao.cn 强势的显示出404错误， 额，因为我不知道原因的情况下一激动把coding托管的代码删除了，还好github上还有个备份，被自己的操作蠢哭。 搞到晚上11多还是没有解决，介于第二天四级考试，不舍地睡着了，当然也睡得很快hhhhh，确实有点累，中午没午休。。。今天7:30醒来准备好考试相关工具后，又搞了一下，还是无果，考试完，和女朋友吃了个饭，送到亲民后，我很快回到寝室继续研究，实在不懂，我做出一个大胆的决定，我打算重新搭hexo，然后我git，node，hexo 所有的东西都删了，简单暴力，重新来了一遍。。。 最后，写这篇流水账不是想说我有多牛逼，多无聊（不过好像是有点。。。），我只是想试试重装后能不能部署，这篇博客能不能发出去。。。。唉ε=(´ο｀* ))) ","date":"2018-06-16","objectID":"/posts/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%80%83%E8%AF%95/:0:0","tags":["生活随笔"],"title":"四六级考试","uri":"/posts/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%80%83%E8%AF%95/"},{"categories":["ACM"],"content":" 来自一位大佬的演讲 尊敬的领导、教练，亲爱的参赛选手们： 大家好，我是来自广东工业大学的tmk。今天很荣幸能够站在这里代表全体参赛选手发言，与大家分享我的经历和感受。 刚开始来到大学的时候，我一心向学，本着“好好学习，天天向上，为校争光，不搞对象”的信念，想在大学一展宏图。因为高中OI的挫败，我在刚上大学的时候就选择了ACM这条“不归路”。一开始是因为高中的遗憾，到后来就完全是因为信念和兴趣慢慢一直搞到现在。当时的我还不知道踏上ACM这条路的苦，而如今的我却也尝到了ACM带给我的乐。 在这三年里，有数不清的夜晚，我的舍友们在寝室里开黑，而我和我的队友在机房里开黑；在这三年里，有数不清的周末，我的舍友们在校园里驰骋，而我和我的队友在题库里驰骋；在这三年里，有数不清的假期，我的舍友们在召唤师峡谷里征战，而我和我的队友在中国各省市征战。三年过去了，我的舍友们成为了offer收割机，而我和我的队友成为了气球收割机。 为了变强是一个痛苦且漫长的过程，只有耐得住寂寞，才能守得住繁华。我的一位队友为了变强甚至牺牲了自己的头发，仅仅是因为他担心他的头发阻碍了他思维的发散。他变秃了也变强了。 三年的 ACM 让我成长很多，收获很多。我也从一个“好好学习天天向上为校争光不搞对象”的无知青年变成了一个写的了工程查得出异常的准程序员。我觉得三年献身于ACM的日子是值得的，和一大堆萌萌的男孩子们在屋子里面一个又一个通宵奋斗的酣畅淋漓的日子是值得的，看着谈恋爱的大家一会儿哀伤一会儿忧愁而我与代码自得其乐矢志不渝的日子是值得的。此外他还给我带来两个最好的小伙伴，是他们的一路陪伴，让我有勇气一直走下去。我和他们走过的地方，比我和女朋友去过的地方还要多。噢，对了，我好像没有女朋友。总而言之，请珍惜你们的队友，他们是你们在大学里为数不多一起奋斗的小伙伴。希望大家像我一样，也爱着ACM，为自己心爱的努力。 最后预祝各位参赛选手们取得理想的成绩，也预祝本次大赛圆满成功。谢谢大家。 ","date":"2018-06-15","objectID":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80/:0:0","tags":["ACM","2018湘潭邀请赛"],"title":"18湘潭邀请赛参赛队员代表发言","uri":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80/"},{"categories":["ACM"],"content":"题目链接（hdu复赛） 2018年湘潭邀请赛，在湘大举行，当时一起打的过去的，因为没出市就方便点。第一次参加现场赛，首先反省一下自己，比赛前算法先不说(没有好好搞过)，就连普通的题，数学性质的题都很少刷，什么都不会，然后英语不说四六级的东西，很多专业英语词汇都没有好好了解过，主要的原因还是刷题刷少了，英文题刷少了。理所当然，成功拿下一铁，湘潭赛打铁告终。 比赛开始，这次是三个人没人一份纸质题目，拿到题目，看最后一题，k.2018发现可以做，(事实证明确实是一道水题)，我就在做这题，他们看了a题，好像是k题一顿操作后提交，错了，一直到比赛结束都没做出来，后来回去看别人的题解，发现自己情况没有分析全面，其实是完全可以解出来的，真的做的太少太少了。a题最后也是没过，还有一个f题，sort，我最初的想法是用stl里的那个sort排序，只要对sort的compare函数做处理应该可以完成排序，比赛之前我看过，但是不熟悉，zxm她也看了我就交给她了，最后好像因为爆long double的问题也没做出来。 哎，菜还是菜，很多算法都不懂，数据结构也没学好，很有一段时间我都特别头疼算法，不想学，费劲，觉得自己不适合学计算机，更不适合ACM。有时候又想，不适合好像总是loser的借口！总是在后悔和偷懒的矛盾中！ 最后，放上，“参赛奖\"羞辱自己，也是鞭策！ ","date":"2018-06-14","objectID":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93/:0:0","tags":["ACM","2018湘潭邀请赛","总结"],"title":"18湘潭邀请赛总结","uri":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93/"},{"categories":["ACM"],"content":"B. Higher h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has no papers and he is going to publish some subsequently. If he works on a paper for x hours, the paper will get (a·x) citations, where a is a known constant. It’s clear that x should be a positive integer. There is also a trick – one can cite his own papers published earlier. Given Bobo has n working hours, ﬁnd the maximum h-index of him. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:0","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Input The input consists of several test cases and is terminated by end-of-ﬁle. Each test case contains two integers n and a. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:1","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Output For each test case, print an integer which denotes the maximum h-index. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:2","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Constraint • 1≤ n ≤109 • 0≤ a ≤ n • The number of test cases does not exceed 104. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:3","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Sample Input 3 0 3 1 1000000000 1000000000 ","date":"2018-06-14","objectID":"/posts/b-higher/:1:4","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Sample Output 1 2 1000000000 ","date":"2018-06-14","objectID":"/posts/b-higher/:1:5","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Note For the ﬁrst sample, Bobo can work 3 papers for 1 hour each. With the trick mentioned, he will get papers with citations 2,1,0. Thus, his h-index is 1. For the second sample, Bobo can work 2 papers for 1 and 2 hours respectively. He will get papers with citations 1+1,2+0. Thus, his h-index is 2. 题意：给定n个小时，可以用其中x(1\u003c=x\u003c=n)个小时写一篇论文，那么这篇论文的\"既定\"引用数将会是x*a(a为给定正整数)；此外，已经写好的论文将会被其后写成的论文所引用，也就是说，这篇论文的总引用数将会是\"既定\"引用数+其后论文篇数；问在所有的写论文方案中(例如一种方案就是用n个小时写n篇论文，每篇论文各花1小时(可以得到这n篇论文的引用数))，h最大为多少(h的含义同上题)(每一种方案都对应着一个h，求这些h中的最大者) 思路：最优方案(即对应h值最大的方案)是平摊n小时写成n篇论文(证明未知)；此时n篇论文的引用数为a,a+1,a+2,…,a+n-1，引用数为a+i时，引用数大于等于它的论文有n-i篇，令a+i=n-i得i=(n-a)/2,所以h=a+(n-a)/2; 后AC代码 #include\u003ccstdio\u003e int main(){ int n,a; while(scanf(\"%d%d\",\u0026n,\u0026a)!=EOF){ printf(\"%d\\n\",a+(n-a)/2); } return 0; } ","date":"2018-06-14","objectID":"/posts/b-higher/:1:6","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"A. Easy h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has published many papers. Given a0,a1,a2,…,an which means Bobo has published ai papers with itations exactly i, ﬁnd the h-index of Bobo. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:0","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Input The input consists of several test cases and is terminated by end-of-ﬁle. The ﬁrst line of each test case contains an integer n. The second line contains (n+1) integers a0,a1,…,an. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:1","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Output For each test case, print an integer which denotes the result. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:2","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Constraint • 1≤ n ≤2·105 • 0≤ ai ≤109 • The sum of n does not exceed 250,000. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:3","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Sample Input 1 1 2 2 1 2 3 3 0 0 0 0 ","date":"2018-06-14","objectID":"/posts/a-easy/:1:4","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Sample Output 1 2 0 题意：给定被引用次数为0~n的论文分别有几张，找到最大的h，满足被引用次数大于等于h的论文至少有h张 思路：在区间[0,n]内二分答案；或直接从n~0遍历找到第一个满足条件的h 后AC代码 #include \"bits/stdc++.h\"using namespace std; int main(){ int a[200005]; int n; int i; while(cin\u003e\u003en){ for(i=0;i\u003c=n;i++) cin\u003e\u003ea[i]; int sum=a[n]; for(i=n;i\u003e=0;){ if(sum\u003e=i){ cout\u003c\u003ci\u003c\u003cendl; break; } else sum+=a[--i]; } if(i\u003c0) cout\u003c\u003c\"0\"\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/a-easy/:1:5","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["others"],"content":"1. \u0026运算 \u0026运算通常用于二进制取位操作，例如一个数 \u0026 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数. ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"2. |运算 |运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数| 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"3. ^运算 ^运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：异或0都不变，异或1则取反。 ^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即a ^ b ^ b = a。^运算可以用于简单的加密，比如你想对你MM说1314520，但怕别人知道，于是双方约定拿你的生日19880516作为密钥。1314520^19880516 = 20665500，你就把20665500告诉MM。MM再次计算20665500 ^ 19880516的值，得到1314520，于是她就明白了你的企图。 还可以用异或来进行快速地交换数据， a=2;b=3;//先转化成二进制 a=a^b; b=a^b; a=a^b; 操作后a=3;b=2; ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:3:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"4. ~ 运算 ~运算的定义是把内存中的0和1全部取反。使用~运算时要格外小心，你需要注意整数类型有没有符号。如果~的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000到$FFFF依次表示的。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:4:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"5. «运算 a « b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 «2 = 400。可以看出，a « b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。 通常认为a « 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。 定义一些常量可能会用到«运算。你可以方便地用1 «16 – 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用«来定义Max_N等常量。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:5:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"6. »运算 和«相似，a » b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们也经常用» 1来代替div 2，比如二分查找、堆的插入操作等等。想办法用»代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60% 传送门 原文:http://www.matrix67.com/blog/archives/263 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:6:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["生活随笔"],"content":"从此故乡只有冬夏，再无春秋。","date":"2018-06-03","objectID":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/","tags":["生活随笔"],"title":"戏子春秋","uri":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/"},{"categories":["生活随笔"],"content":" 从此故乡只有冬夏，再无春秋。  时间急促得仿佛还在昨天，还没有清楚地认识到这句话的其中含义时，我早已离开它，远去。 　自此，一江绿水东去，桃花竞开，春洒满园；瑟瑟秋风里，稻谷黄时，落木萧萧；故乡的春秋成为回忆尘封在我的脑海深处。 　三月，这里和故乡一样雨下得缠绵，却尽带着他乡的味道。在不是滋润自己的那方水土上，哪怕是喜雨之人，亦只有料峭的寒意。雨下到这里才懂得，为何古来才子佳人逢阴雨连绵天总是带着一股莫名的惆怅。原是这般由头！我与他们，并无二般，想起故乡来。 　故乡的春是在牛耕上的。太爷说，老牛伏在岸边饮水时节就是春耕了。到那时，耕牛头角披红挂彩，鼻挂铜色大铃，以祈愿今年平安，田地丰收；当耕牛喘着鼻息，缓缓地哞哞叫着走下田，是其在田地里大展身手的机会。故而，二月春耕总是会见到红布条装扮的水牛在田间劳作，彩带飘逸，好生招摇，尤其是农夫哼起那极具故乡气息的耕牛民歌，如高山流水般，伴着清脆的铜铃声隐隐飘去……在春末，三月桃花尽开，漫山望去，粉红红一片，甚是好看。小时看到总以为身处仙山，而后来，陶渊明一篇《桃花源记》就以为自己是那秦时避乱而住在桃花源中的后人。每每与外人谈起家乡的桃花山时，必然是一副神气十足的傲气样子。我想，这也是自己不知不觉中受家人影响，又倾心桃花的缘故吧。 　印象中，家里人都爱这漫山遍野的桃花。太爷爱赏花，山上桃花开得极好的时候，便移栽了数株桃花留在了院子里，天好天坏，都能观赏上好一会儿。太婆还在的时候，桃花次第开，她就会拾掇许多桃花下来做成桃花糕，那桃花糕香香糯糯的味道飘散四周，总能把我馋来。后来，太婆故去，奶奶学着太婆开始做起了桃花糕，却总是没有太婆做的如意。但奶奶的桃花酒，受到父辈们的一致好评。每当酒坛从土里挖出，揭开红布，酒气便带着桃花的香甜扑鼻而来。父辈们在太爷种的桃花树下把酒话桑麻，颇有一副桃花坞里桃花庵，桃花庵里桃花仙的样子。现如今记忆远去，酒香却长留下来，记起时，那酒酣甜得喜人。 　故乡的秋从九月农收渐起，那时候一家老小在浓浓的秋意里忙忙碌碌，直至十月方才得些许闲暇日子。 　稻谷黄时，是秋最盛的时候。父辈们清晨便出发去地里收稻谷。晌午，我兴起与祖母前去送饭。正午的太阳烈得很，父辈们大颗大颗的汗直往下掉，稻谷机嘈杂得很。这才想起太爷教我的诗，“妇姑荷箪食，童稚携壶浆”，就是这样的情景无差。那时候不懂得父辈的辛苦，只知奔入山间，捕捉蚱蜢，蛐蛐等趣物。等傍晚将近，坐在板车谷袋上，兴尽而回，一天就算结束。渐渐长大，再也不敢胡闹，不知是童趣少了还是知了人事愈发迷惘了？ 　窗外又下起雨，心里竟也惆怅起来。并非是洗过的衣服久晾未干，而是伴着那股湿意而来，藏在雨里的那点点乡愁。这边的桃花也开得好，往窗外，密密一片，不免想起了太爷书房里的书画：花是春时花，却非故乡花。人是故乡人，却是他乡客。所见时，不过是从戏子变成看客了罢。 ","date":"2018-06-03","objectID":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/:0:0","tags":["生活随笔"],"title":"戏子春秋","uri":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/"},{"categories":["生活随笔"],"content":"一直觉得中国古代神话 能称得上传奇的只有两个人物： 一是猴子 一是哪吒 百世蕴灵育出只石猴 大闹天宫腾云驾雾 三年怀胎生了个哪吒 东海屠龙翻江倒海 可以说 除了这两人 没人再能当得起离经放纵四个字的 但称得上悲剧的 约摸也只有这两个 一个五行山下压五百年 揭了封印 戴上金箍无悲无喜 拜佛西天 唤孙悟空 一个削肉还母剔骨还父 塑了莲身 站上火轮无怨无恨 封神南门 号三太子 这尘世最擅长的事 大抵就是抹杀疏狂者的落拓 磨平豪纵者的傲骨 斩灭叛世者的孤妄 ","date":"2018-05-31","objectID":"/posts/%E7%8C%B4%E5%AD%90%E4%B8%8E%E5%93%AA%E5%90%92/:0:0","tags":["生活随笔"],"title":"猴子与哪吒","uri":"/posts/%E7%8C%B4%E5%AD%90%E4%B8%8E%E5%93%AA%E5%90%92/"},{"categories":null,"content":" “每天早晨叫醒你的不是鬧鐘，而是你的夢想。” 我有過靠著這種信念撐下來的日子，我見過自己努力的樣子，至於現在的自己配不配得上當初努力的自己， 其實也不重要了，還望披荊斬棘，不改初心。 不怕萬人阻擋，只怕自己投降。你如何回憶，決定你是一個怎樣的人！ 從大一伊始，打 ACM 比賽，訓練刷題，再到毅然決然離開實驗室，選擇陌生的 Web 開發，從工作前的一無所知到，到前端開發，後端開發，到教實習生，到面試新人，到開始乏味。這一路走來，好奇心，探索欲，瞎擇騰，或許還有愛意，都是支撐我的動力。 時間並不會因為你的迷茫和遲疑而停留，就像你在看到這篇博客的時候，不知道有多少人正風雨兼程趕赴夢想。沒有誰生來就是神牛，千裏之行，始於足下！比自己優秀的人有很多，永遠不要感動自己，保持謙遜，沈澱自己，感謝每一個曾經努力的自己。不必執著於過去，也不必過度擔憂未來，望披荊斬棘，不忘初心。 最開始寫博客，是在打 ACM 的時候，深受一個學長的博客影響，他的博客是 hexo 搭建的，ID 是 [戎碼一生]，所以我也照葫蘆畫瓢用 hexo 搭建了一個，一用就是 3 年，博客名字原 “博採眾長” 改为 “菠菜眾長”，因為不能用成語作為網站名字，就這個原因。 直到 21 年下半年，升級 windows 11, 系統出了 BUG, 整理磁盤不小心把代碼刪掉了，就乾脆換成 hugo 了。 ","date":"2018-05-28","objectID":"/posts/hello_world/:0:0","tags":null,"title":"Hello World","uri":"/posts/hello_world/"}]