[{"categories":["Git"],"content":" 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 介绍 先通过几张图片来大致了解一下 Git 的工作原理吧！ 文章开头的流程图已经简单明了地说明了 Git 常用操作的工作流程，下图换种风格再展示一次： 提到 Git 就会联想到 github, 下图从 Git 的角度简单说明了一些 Github 常用操作的关系： 下面这个图则展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 \"index\" 的区域是暂存区（stage, index），标记为 “master” 的是 master分支所代表的目录树。 HEAD指针: 每个git仓库有且仅有一个HEAD指针，它通常指向當前某个活動的本地分支指针(最初本地仓库master)。也可以是某个提交记录、某个tag，但这会让其处于 detached HEAD（游离头）状态，此状态下的所有提交都无效。 图中我们可以看出此时 \"HEAD\" 实际是指向 master 分支的一个\"游标\"。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的objects标识的区域为 Git 的对象库，实际位于 \".git/objects\" 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 \"git add\"命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 \"git reset HEAD\" 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 \"git rm --cached \u003cfile\u003e\" 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 \"git checkout .\" 或者 \"git checkout -- \u003cfile\u003e\" 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 \"git checkout HEAD .\" 或者 \"git checkout HEAD \u003cfile\u003e\" 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 基本常用命令 第一次使用git的时候，需要设置用户信息和用户邮箱，用于辨识提交者身份。 git config --global user.name \u003cgit用户名\u003e git config --global user.email \u003c邮箱地址\u003e git config --list # 查看当前用户信息 ","date":"2018-10-30","objectID":"/posts/git/:0:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"基本操作 git init # 把当前的目录变成可以用git进行版本控制的git仓库，生成隐藏.git文件。 git add XX # 把xx文件添加到暂存区去。 git add –A # git add --all的缩写，添加全部到暂存区 git add –u # 把文件的删除和修改添加到暂存区（不包括新增） git add . # 监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区 git commit -m \"message\" # 从暂存区提交到本地仓库 git commit -a -m \"message\" # 相当于省略git add，但是无法提交新增的文件 git push origin master # Git会把master分支推送到远程库对应的远程分支上 Tips “commit message\"内容尽量规范！ 当某一次提交后，突然想起漏提交了文件，或不小心提交了不满意的代码时， 可以使用git commit --amend -m \"message\"指令。它可以在不增加一个新的commit-id的情况下将新修改的代码追加到前一次的commit-id中。提交之后message也将被本次的message覆盖，所以还需要再次添加上次的message。 ","date":"2018-10-30","objectID":"/posts/git/:1:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"push git push origin branch-name git push –u origin master git push origin --delete branch-name # 删除远程分支 把当前master分支推送到远程库; -u表示记住分支和地址，下次使用git push即可。 ","date":"2018-10-30","objectID":"/posts/git/:2:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"remote git remote add origin reposityUrl # 关联一个远程库 git remote # 查看远程库的信息 git remote –v # 查看远程库的详细信息 ","date":"2018-10-30","objectID":"/posts/git/:3:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"clone git clone reposityUrl # 从远程库中克隆 git clone -b branchName reposityUrl # 克隆指定分支 ","date":"2018-10-30","objectID":"/posts/git/:4:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"pull git pull 从远程仓库拉下来到本地库然后合并相当于git fetch+git merge。 一般push前先拉去最新版本，避免代码冲突，如果有冲突需要解决了冲突才能提交。 import repositories同步更新 git pull 原链接 git push origin master ","date":"2018-10-30","objectID":"/posts/git/:5:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"fetch git fetch # 从远程库抓下最新版本，但是不合并 fetch是从远程库到本地库，但是未在工作区，需要git merge ","date":"2018-10-30","objectID":"/posts/git/:6:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"merge git merge dev # 在当前的分支上合并dev分支 分支合并也是在本地完成(从本地库到工作区)，新的分支只有在合并后才允许被删除。 如果分支合并是出现冲突需要解决了冲突才能合并，使用git status查看冲突文件。 ","date":"2018-10-30","objectID":"/posts/git/:7:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"branch,checkout git branch # 查看当前所有的分支 git branch name # 创建分支 git branch –r # 看远程所有分支 git branch –a # 查看本地远程分支 git branch –d name # 删除分支 git checkout name # 切换分支 git checkout –b name # 创建并切换到name分支上 git checkout -- file git checkout -- file相当于取消对文档的修改，将最新的本地版本库的本文件复制覆盖它。（比较危险！） ","date":"2018-10-30","objectID":"/posts/git/:8:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"reflog,log git log # 显示所有提交过的版本信息：commit id，提交者，日期 git reflog # 查看历史记录的commit id Tips 想看到自己的操作记录，则可以使用log与reflog，它两个的区别如下: git log命令可以显示所有提交过的版本信息； 如果感觉太繁琐，可以加上参数--pretty=oneline，只会显示版本号和提交时的备注信息。 git reflog可以查看所有分支的所有操作记录。（包括已经被删除的commit记录和reset的操作） ","date":"2018-10-30","objectID":"/posts/git/:9:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"reset git reset --hard HEAD^ git reset --hard HEAD~ # 回退到上一个版本 git reset --hard HEAD~100 # 回退到100个版本 git reset head -- file # 不加file则全部退回 git reset file # 将本地仓库的当前版本退回至暂存区，相当于取消暂存 版本退回是从本地仓库到暂存区，如果已经提交远程库，此时的版本是低于最新的版本的会拒绝提交， 需要用git push -f origin master强制提交。 特别提醒 如果你git reset --hard HEAD^+git push -f origin master执行完，github中的记录和本地文件都会回到退回的状态。简单来说就是一修改了一天的bug,完工后，你这一套操作直接打回原形。别慌（实际内心慌的一麻皮。。。） 通过git log -g命令来找到需要恢复的信息对应的commitid，可以通过提交的时间和记录来辨别, 找到执行reset --hard之前的那个commit对应的commit-id 通过git branch recover_branch commit-id 来建立一个新的分支 这样，就把到commitid为止的代码、各种提交记录等信息都恢复到了recover_branch分支上了。 ","date":"2018-10-30","objectID":"/posts/git/:10:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"status git status 查看你的文件在暂存区和工作目录的状态，默认是较为详细的显示，并提示你可以用何种命令完成你接下来可能要做的事情。 git status -s 较为简单的输出当前的状态，如： $ git status -s M README.md D hello.rb ?? world.java 你可以看到，在简短输出中，有两栏。第一栏是暂存区的，第二栏则是工作目录的。这里表示： README.md 在暂存区中的状态是 modify hello.rd 在工作目录中的状态是 delete world.java 还未添加到版本控制。 ","date":"2018-10-30","objectID":"/posts/git/:11:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"diff git diff XX # 查看XX文件修改了哪些内容 git diff # 工作目录和暂存区 git diff --cached # 暂存区和本地仓库 git diff HEAD # 工作目录和本地仓库 git diff --stat # 显示信息摘要 ","date":"2018-10-30","objectID":"/posts/git/:12:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"rm, mv git rm # 将文件从暂存区和工作目录删除，-f 为强制删除 git rm filename # 删除文件 git rm –r dirname # 删除文件夹 –r 表示递归所有子目录 git rm --cached \u003cpath\u003e # 将文件从暂存区中删除 git mv \u003cold_path\u003e \u003cnew_path\u003e git rm用来删除文件、目录。git mv命令用于移动或重命名一个文件、目录。 比如删除photos文件，本地删除后，远程仓库还会有，所以 git rm -r photos git commit -m \"删除相册\" git push ","date":"2018-10-30","objectID":"/posts/git/:13:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"submodule git submodule add # 添加子模组 git submodule init # 子模组初始化 git submodule update # 子模组更新 Note 当一个远程库有子模组时，直接clone子模组只是一个空文件夹，需要进入子模组的空文件夹init和update才行。 或者使用递归克隆git clone --recursive 远程库 子模组更新后，父模组必须更新，因为需要更新commit id。 ","date":"2018-10-30","objectID":"/posts/git/:14:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"tag git tag v1.0 git tag -a v1.0 # 给最新一次提交打标签 git tag -a \u003ctagname\u003e -m \"标签\" # 指定标签信息命令 git show \u003ctagname\u003e # 显示标签信息 git tag # 查看版本打的Tag git tag -d v1.0 # 删除本地标签 git push origin :refs/tags/v1.0 # 删除远程标签 $ git push [remote] [tag] # 提交指定tag $ git push [remote] --tags # 提交所有tag Note 当你执行git tag -a命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。 如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。 例如，假设我们发布了提交85fc7e7(最后一行)，但是那时候忘了给它打标签。 我们现在也可以： $ git tag -a v0.9 85fc7e7 $ git log --oneline --decorate --graph * d5e9fc2 (HEAD -\u003e master) Merge branch 'change_site' |\\ | * 7774248 (change_site) changed the runoob.php * | c68142b 修改代码 |/ * c1501a2 removed test.txt、add runoob.php * 3e92c19 add test.txt * 3b58100 (tag: v0.9) 第一次版本提交 ","date":"2018-10-30","objectID":"/posts/git/:15:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"stash git stash # 把当前的工作隐藏起来，等以后恢复现场后继续工作 git stash list # 查看所有被隐藏的文件列表 ","date":"2018-10-30","objectID":"/posts/git/:16:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["Git"],"content":"gitk gitk # git自带GUI gitk --all github,gitea等平台issue的常用标签 bug 描述的问题是一个bug enhancement 功能增强，没有feature也可以指 New feature or request feature 新功能 duplicate 问题重复 invalid 可用的，不是bug question 疑问，需要进一步的信息 wontfix 不会修复此问题 help-wanted 需要帮助 good first issue Good for newcomers 更多标签 license 其他 github上fork了别人的项目后，再同步更新别人的提交 常用Git命令清单 Gearn Git Branching ","date":"2018-10-30","objectID":"/posts/git/:17:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["PHP"],"content":" 基于Laravel7开发，Markdown语法的个人独立博客。Cell Blog,也是我的毕业设计作品，目前已開源。 功能 支持Markdown,文章实时预览效果 支持多种编程语言代码高亮 编辑器图片上传 后台上传文件管理 文章搜索 文章分类 文章标签 热门文章 随机格言 文章管理(发布，评论开关，排序) 自定义导航(显示开关，排序) 自定义页面(发布开关) 友情链接(显示开关，排序) COS桶相册 丰富的博客配置(方便扩展，支持自定义JS脚本) 不蒜子计数 Leancloud计数 Valine评论插件 文章分享插件 截图 安装 注意事项：PHP取消禁用函数putenv()和symlink()，安装fileinfo扩展。 下载 git clone https://github.com/Lruihao/cell-blog.git 进入站点 cd cell-blog 生成.env cp .env.example .env 编辑.env环境配置 APP_URL=http://localhost #使用本地文件系统存储文件时，必须填写正确地址 APP_DEBUG=false #关闭调试 DB_HOST= #数据库地址 DB_PORT=3306 #数据库端口 DB_DATABASE= #数据库名称 DB_USERNAME= #数据库用户 DB_PASSWORD= #数据库密码 打开app\\Providers\\AppServiceProvider.php,注释SystemController:load() 防止后续步骤报错 public function boot() { Schema::defaultStringLength(191); //SystemController::load(); } 安装项目依赖 composer install 生成key php artisan key:generate 运行数据迁移和后台数据填充 php artisan admin:install已包含数据迁移命令php artisan migrate G:\\cell-blog\\app\\Admin directory already exists !无需理会，继续执行剩下命令即可。 php artisan admin:install php artisan admin:import media-manager php artisan db:seed 默认下使用了本地文件系统，创建storage目录在public的软链接 php artisan storage:link 打开app\\Providers\\AppServiceProvider.php,取消注释SystemController:load() public function boot() { Schema::defaultStringLength(191); SystemController::load(); } 将博客网站根目录指向入口public目录 如果使用Nginx，要设置伪静态 location / { try_files $uri $uri/ /index.php?$query_string; } 启动服务后，在浏览器打开http://localhost/admin/,使用用户名admin和密码admin登录. License Cell Blog is open-sourced software licensed under the MIT license. ","date":"2020-07-25","objectID":"/posts/cell-blog-install/:0:0","tags":["PHP","Laravel","Markdown","Backend"],"title":"cell-blog 功能介绍与安装","uri":"/posts/cell-blog-install/"},{"categories":["JavaScript"],"content":"信息 cos 桶相册，终于！！终于来了！！，idea 来自[兰州小红鸡-给hexo静态博客添加动态相册功能]， 功能虽好，但是还是先友情提示！ 开放API是一个很危险的操作，意味着你的cos桶里面的所有资源包括目录结构都暴露的整个世界中，所以建议不要放一些比较私密的照片，保护自己的隐私，提防不良用心之人。下面就开始吧！ 创建腾讯云 cos 存储桶 就创建一个 COS 就好了！有几点注意事项： 权限设置为共有读私有写 policy 权限设置整个桶的读操作 跨域访问 CORS 设置，自己随意 上传照片 首先我这个 cos 相册，相册分类就是文件夹分类，所以cos桶里面先新建不同的文件夹，文件夹名称就是相册名称， 每个相册里面需要放置一张名称为**“封面.jpg”**的图片作为该相册的封面。 ","date":"2019-11-24","objectID":"/posts/cos-album/:0:0","tags":["CosAlbum","腾讯云cos桶","Frontend","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/posts/cos-album/"},{"categories":["JavaScript"],"content":"上传工具 COSBrowser GUI工具,桌面/移动版 【官方、推荐】 COSCMD 命令行工具 【官方】 PicGo 图床上传工具 【第三方、推荐】 食用方式 下载地址，别忘点赞哈 http://github.com/Lruihao/cos-album 首先，下载源码，引入 cos-album.css 和 cos-album.js 然后，在你的 js 中 new 一个 Cosalbum 对象( xmlLink 后不需要添加/) ","date":"2019-11-24","objectID":"/posts/cos-album/:1:0","tags":["CosAlbum","腾讯云cos桶","Frontend","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/posts/cos-album/"},{"categories":["JavaScript"],"content":"Step1 \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"cos-album.min.css?v=1.1.2\"\u003e \u003cscript type=\"text/javascript\" src=\"cos-album.min.js?v=1.1.2\"\u003e\u003c/script\u003e ","date":"2019-11-24","objectID":"/posts/cos-album/:2:0","tags":["CosAlbum","腾讯云cos桶","Frontend","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/posts/cos-album/"},{"categories":["JavaScript"],"content":"Step2 \u003cscript type=\"text/javascript\"\u003e new Cosalbum({ 'xmlLink': 'https://img-xxxxxxxxxx.cos.ap-chengdu.myqcloud.com', 'prependTo': '.cos-album', 'viewNum': 8, 'imgUrl': '//img.lruihao.cn' }); \u003c/script\u003e ","date":"2019-11-24","objectID":"/posts/cos-album/:3:0","tags":["CosAlbum","腾讯云cos桶","Frontend","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/posts/cos-album/"},{"categories":["JavaScript"],"content":"Params param type default description xmlLink String 需要解析的騰訊云COS桶XML鏈接 prependTo String ‘body’ 可選解析相冊到某個節點 viewNum Number 4 每個相冊顯示的照片數目 copyUrl String href CDN 链接,雙擊複製 URL Since: 1.1.6 imgType String [‘jpg’, ‘jpeg’, ‘png’, ‘gif’, ‘svg’] 图片類型 Since: 1.1.6 videoType String [‘mp4’, ‘mp3’, ‘avi’, ‘mov’, ‘qt’] 視頻類型 Since: 1.1.6 viewport 视个人情况添加。 hexo 中使用时 css 和 js 都需要做适当调整，配合加密功能使用等等，这里不再展开。 注：代码设定不加载根目录文件，所以可以利用静态服务把源码部署在根目录，配合 PicGo、COSBrowser 上传来搭建个人图床。 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003ecos-album\u003c/title\u003e \u003c!-- \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e --\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"cos-album.css\"\u003e \u003cscript type=\"text/javascript\" src=\"cos-album.js\" defer\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e new Cosalbum({ 'xmlLink': 'https://img-xxxxxxxxxx.cos.ap-chengdu.myqcloud.com', 'prependTo': '.cos-album', 'viewNum': 8, 'copyUrl': '//img.lruihao.cn' }); \u003c/script\u003e \u003c!-- 你的其他内容，如评论等 --\u003e \u003c/body\u003e \u003c/html\u003e cos-album demo changelog 2020-9-28 22:46 升級：相冊封裝成類，可以更方便new出來 優化：相冊圖片樣式優化 2019-11-24 10:52:34 修改整理了一下代码，分割功能为函数，并写了注释，更加方便伸手党! 未实现 fancybox 加密功能 分页显示 ","date":"2019-11-24","objectID":"/posts/cos-album/:4:0","tags":["CosAlbum","腾讯云cos桶","Frontend","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/posts/cos-album/"},{"categories":["hugo"],"content":"過程 以前的 hexo 博客是自己寫的友鏈模板，換到 hugo 後想著在網上隨便找一個範本用著就好，然而並沒有自己想要的 layout, 幾乎都是使用 shortcodes 的，代碼風格有點問題且 shortcodes 作為友鏈添加的方式是真的麻煩。就只好自己寫羅。 友情鏈接範本 https://lruihao.cn/friends/ ","date":"2021-10-05","objectID":"/posts/hugo-friends/:0:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["hugo"],"content":"創建模板 開始之前去看了 hugo 的官網，再看了一下 go 模板的語法。 新建 layouts/friends/single.html {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- $params := .Scratch.Get \"params\" -}} \u003cdiv class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated pulse faster\"\u003e {{- .Title -}} \u003c/h1\u003e {{- /* Subtitle */ -}} {{- with $params.subtitle -}} \u003ch2 class=\"single-subtitle\"\u003e{{ . }}\u003c/h2\u003e {{- end -}} {{- /* Friend links */ -}} {{- $loading := resources.Get \"svg/loading.svg\" | minify -}} \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003clink rel=\"stylesheet\" href=\"/friends/css/_friends.css\" /\u003e \u003cdiv class=\"friend-links\"\u003e {{ range $index, $friend := .Site.Data.friends }} \u003ca class=\"friend-link\" title=\"{{ $friend.discription }}\" href=\"{{ $friend.url | safeURL }}\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\"\u003e {{ if $friend.avatar }} \u003cimg class=\"friend-avatar lazyload\" src=\"{{ $loading.RelPermalink }}\" data-src=\"{{ $friend.avatar }}\" alt=\"{{ $friend.nickname }}\" /\u003e {{ else }} \u003csvg class=\"friend-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{ add 1 $index }}\"\u003e\u003c/use\u003e \u003c/svg\u003e {{ end }} \u003cspan class=\"friend-nickname\" title=\"{{ $friend.nickname }}\"\u003e@{{ $friend.nickname }}\u003c/span\u003e \u003c/a\u003e {{ end }} \u003c/div\u003e {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/div\u003e {{- end -}} ","date":"2021-10-05","objectID":"/posts/hugo-friends/:1:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["hugo"],"content":"模板樣式 新建文件 _friends.css /** * @Description: Style of layout named 'Friend links'. * @Author: lruihao.cn * @Updated: 2021/9/20 19:26 */ .friend-links { margin-top: 1rem; display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; } @media (max-width: 576px) { .friend-links { justify-content: space-around; } } .friend-link { width: 150px; height: 200px; font-size: 1rem; text-align: center; background: rgba(255,255,255,0.3); box-sizing: border-box; box-shadow: 3px 3px 5px #aaa; border-radius: 5px; border:none; transition-duration: 0.3s; margin-bottom: 1rem; display: flex; flex-direction: column; justify-content: space-between; } .friend-link:hover { background: #fff; transform: scale(1.03); box-shadow: 0 0 3px #aaa; } .friend-avatar { object-fit: cover; object-position: center; width: 100%!important; height: 150px!important; border-radius: 5px; margin: 0; padding: 0; } .friend-nickname{ display: block; position: relative; color: #2bbc8a; font-weight: bold; max-width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; line-height: 18px; margin-bottom: 1rem; } .friend-nickname:hover { color: #d480aa; } ","date":"2021-10-05","objectID":"/posts/hugo-friends/:2:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["hugo"],"content":"友鏈頁面 hugo new friends/index.md 將 _friends.css 放到 content/friends/css/ 打開友鏈頁面 content/friends/index.md --- title: \"友鏈\" date: 2021-09-19T12:33:48+08:00 type: \"friends\" --- ","date":"2021-10-05","objectID":"/posts/hugo-friends/:3:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["hugo"],"content":"數據 新建數據文件 data/friends.yml, 數據格式為： # - nickname: 标题# avatar: 头像# url: 站点# discription: 描述- nickname:Lruihaoavatar:https://gravatar.loli.net/avatar/3f985efb5907ca52944a3cd7edd51606?d=wavatar\u0026v=1.3.10url:https://lruihao.cndiscription:不怕萬人阻擋，只怕自己投降 ","date":"2021-10-05","objectID":"/posts/hugo-friends/:4:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["hugo"],"content":"結語 這樣每次添加友鏈或者刪除友鏈衹要操作數據文件 friends.yml 就好，乾淨又衛生！ 友鏈頁面 content/friends/index.md 繼承了基礎頁面的功能，內容評論等 ","date":"2021-10-05","objectID":"/posts/hugo-friends/:5:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["hugo"],"content":"使用 Shell 腳本管理 Hugo 本地博客","date":"2021-10-04","objectID":"/posts/hugo-admin/","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"摘要 在使用 hugo 寫博客的過程中會使用到一些命令，包括 Git 的使用也會用到 Git 命令，但是這些命令我感覺知道就好，沒必要因輸入命令儿增加寫博客和部署博客的額外工作。 自然要想辦法簡化這些過程，Git 還好有 SourceTree 等工具，Hugo 卻沒有，也懶得去網絡上找類似以前 hexo 有 hexo-admin 的插件可以讓大家在瀏覽器寫博客，因為我覺得這和靜態博客初衷背道而馳，於是我就折中方案，寫了一個滿足日常需求的 Shell 腳本，生成管理本地博客。 ","date":"2021-10-04","objectID":"/posts/hugo-admin/:0:0","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"實現 一共六個腳本，防止 hugo-site/_localadmin/ 下 _localadmin/ ├── auto_push.sh # 自動化提交源碼 ├── hugo_builder.sh # 構建 hugo 命令 ├── hugo_main.sh # 主介面入口 ├── hugo_server.sh # 啟動本地服務 ├── post_generator.sh # 創建文章 └── public_async.sh # 同步 public 子模組 ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:0","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"post_generator.sh 輸入文章名稱 (建議使用英文) 文章是否會插入圖片等資源 (默認：否) #!/bin/bash #author: Lruihao cd .. read -p \"Please enter the article name: \" postName if [ -z $postName ];then echo \"The article name is required!\" else read -p \"Will there be pictures in this article? [y/n]...\" choice if [ $choice = \"y\" ];then hugo new posts/$postName/index.md else hugo new posts/$postName.md fi fi ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:1","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"hugo_server.sh cd .. hugo server --disableFastRender ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:2","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"hugo_builder.sh cd .. hugo --minify ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:3","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"public_async.sh cd .. git submodule update --remote git add public git commit -m \"Feat: Update public module commit id\" ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:4","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"auto_push.sh 不輸入 Git 提交訊息會使用腳本中默認訊息 Docs: 『菠菜眾長』内容更新 YYYY-MM-DD week hh:mm::ss #!/bin/bash #author: Lruihao cd .. # 是否需要每次提交自動更新子模組 # git submodule update --remote # git add public # git commit -m \"Feat: Update public module commit id\" git add . read -p \"Please enter commit message: \" commitMsg if [ -z $commitMsg ];then commitMsg=\"Docs: 『菠菜眾長』内容更新 $(date +'%F %a %T')\" fi git commit -m \"$commitMsg\" git push ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:5","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"hugo_main.sh 可單獨執行子腳本也可以通過主介面來選擇序號執行 #!/bin/bash #author: Lruihao echo \"Please enter the serial number to work\" echo \"--------------------------------------\" echo \"1. post generator\" echo \"2. hugo server\" echo \"3. hugo build\" echo \"4. public async\" echo \"5. auto push\" echo \"--------------------------------------\" echo \"Press Ctrl+C to stop\" read num case $num in 1) sh post_generator.sh ;; 2) sh hugo_server.sh ;; 3) sh hugo_builder.sh ;; 4) sh public_async.sh ;; 5) sh auto_push.sh ;; *) echo \"There is no such serial number\" ;; esac echo \"Press any key to continue...\" read x clear sh hugo_main.sh ","date":"2021-10-04","objectID":"/posts/hugo-admin/:1:6","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo"],"content":"使用 將 hugo_main.sh 建立桌面快捷鍵 雙擊 hugo_main.sh 進入根據提示使用即可 由於一般寫博客會便邊寫邊預覽，所以一般開兩個主介面窗口，如下圖： 一個選擇 2 啟動本地服務 一個用於生成文章，部署文章等 Hugo AdminHugo Admin \" Hugo Admin ","date":"2021-10-04","objectID":"/posts/hugo-admin/:2:0","tags":["shell","hugo"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["hugo","Git"],"content":"解決痛點 Github Actions 真是靜態博客的福音，有了它 hugo, hexo 等博客構建過程可以丟給 Github 的服務器幫我們做了。 也就是説實現了在線寫靜態博客的需求。 ","date":"2021-10-04","objectID":"/posts/github-actions/:0:0","tags":["hugo","Github Actions","Git","腾讯云cos桶"],"title":"Hugo 使用 Github Actions 部署到 Github Pages 和 腾讯云cos桶","uri":"/posts/github-actions/"},{"categories":["hugo","Git"],"content":"準備 工作流程設計到兩個倉庫和一個 cos 桶，例如： Lruihao/hugo-blog # Blog source repository Lruihao/lruihao.github.io # Github pages repository blog-1256932288 # COS bucket ","date":"2021-10-04","objectID":"/posts/github-actions/:1:0","tags":["hugo","Github Actions","Git","腾讯云cos桶"],"title":"Hugo 使用 Github Actions 部署到 Github Pages 和 腾讯云cos桶","uri":"/posts/github-actions/"},{"categories":["hugo","Git"],"content":"Github Actions ","date":"2021-10-04","objectID":"/posts/github-actions/:2:0","tags":["hugo","Github Actions","Git","腾讯云cos桶"],"title":"Hugo 使用 Github Actions 部署到 Github Pages 和 腾讯云cos桶","uri":"/posts/github-actions/"},{"categories":["hugo","Git"],"content":"創建 workflows 任務 創建 hugo-site/.github/workflows/deploy.yml, 這個文件會寫一些命令告訴 Github 在我們提交源碼的時候，它要幫我們做哪些事情。 name:Auto Deploy hugoon:[push]jobs:Explore-GitHub-Actions:runs-on:ubuntu-lateststeps:- name:Check out repository codeuses:actions/checkout@v2with:submodules:recursive # Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:latestextended:true- name:Build Hugo static filesrun:hugo --minify- name:Deploy to Github Pagesuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.GP_DEPLOY_KEY }}external_repository:Lruihao/lruihao.github.iopublish_branch:mainpublish_dir:./publiccommit_message:${{ github.event.head_commit.message }}- name:Install coscmdrun:sudo pip install coscmd- name:Configure coscmdenv:COS_SECRET_ID:${{ secrets.COS_SECRET_ID }}COS_SECRET_KEY:${{ secrets.COS_SECRET_KEY }}COS_BUCKET_NAME:blog-1256932288 # Change for yourselfCOS_BUCKET_REGION:ap-chengdu # Change for yourselfrun:coscmd config -a $COS_SECRET_ID -s $COS_SECRET_KEY -b $COS_BUCKET_NAME -r $COS_BUCKET_REGION- name:Deploy to COS Bucketrun:coscmd upload -r -s --delete -f public/ / ","date":"2021-10-04","objectID":"/posts/github-actions/:2:1","tags":["hugo","Github Actions","Git","腾讯云cos桶"],"title":"Hugo 使用 Github Actions 部署到 Github Pages 和 腾讯云cos桶","uri":"/posts/github-actions/"},{"categories":["hugo","Git"],"content":"配置 Github Pages 密鑰 為了讓 Lruihao/hugo-blog 提交代碼后自動部署到 Lruihao/lruihao.github.io, 需要生成一對 ssh key. ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key) 打開 Lruihao/hugo-blog 倉庫的 settings, 再点击 Secrets, 然後添加 private key, name 为 GP_DEPLOY_KEY 打開 Lruihao/lruihao.github.io, 点击 Deploy keys, 添加 public key, name 隨意，Allow write access 一定要勾上，否則無法提交 ","date":"2021-10-04","objectID":"/posts/github-actions/:2:2","tags":["hugo","Github Actions","Git","腾讯云cos桶"],"title":"Hugo 使用 Github Actions 部署到 Github Pages 和 腾讯云cos桶","uri":"/posts/github-actions/"},{"categories":["hugo","Git"],"content":"配置 COS 密鑰 打開 Lruihao/hugo-blog 倉庫的 settings, 再点击 Secrets, 然後添加 COS 桶的 secret_id 和 secret_key: COS_SECRET_ID COS_SECRET_KEY 至此，Github Pages 和 COS 都已經可以通過 Github Actions 自動部署了，有部署記錄后， 打開 Lruihao/hugo-blog -\u003e Actions 可以看到構建過程和結果，構建失敗也會收到 Github 發給你的郵件。 ","date":"2021-10-04","objectID":"/posts/github-actions/:2:3","tags":["hugo","Github Actions","Git","腾讯云cos桶"],"title":"Hugo 使用 Github Actions 部署到 Github Pages 和 腾讯云cos桶","uri":"/posts/github-actions/"},{"categories":["hugo","Git"],"content":"COS 自動同步 (備用) 本小節內容和 Github Actions 無關，僅作為 COS 備用上傳方式。 COSBrowser 下載 COS 官方軟件 COSBrowser 點開右上角 工具箱 選擇 文件同步 選擇 本地文件夹 eg. hugo-site/public 選擇 存储桶目录 同步类型：單次同步、自動同步、定時同步 同步前先執行 hugo 構建命令，eg. hugo --minify 有 Github actions 選單次同步就好，在 Github 不好用時可用。 ","date":"2021-10-04","objectID":"/posts/github-actions/:3:0","tags":["hugo","Github Actions","Git","腾讯云cos桶"],"title":"Hugo 使用 Github Actions 部署到 Github Pages 和 腾讯云cos桶","uri":"/posts/github-actions/"},{"categories":["hugo"],"content":" 电脑升级 win 11 后，分盘操作存在 bug, 然后又不小心把装代码的盘格式化了，虽然都有备份到 github, 但是当时为了省事，hexo Node 安装的很多以来插件都没有备份，现在又现在不到了，所以 hexo 博客没办法完整复原，另外，早就觉得基于 Node 的 hexo 实在有些臃肿，且博客内容多了以后部署太慢，就干脆乘机换了好了，经过一段时间寻找，最终选择了基于 Go 的 hugo, 记录一下迁移过程及待办事项。 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:0:0","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"Hugo 准备 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:0","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"概念 Hugo is a fast and modern static site generator written in Go, and designed to make website creation fun again. 那 hugo 基于编译语言 GO 构建，对于静态页面的构建肯定是碾压 hexo 的存在，其官方标语也是很直白 \"The world’s fastest framework for building websites\", 作为先后使用过 hexo 和 hugo 的我来说，这确实名副其实。 gohugo ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:1","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"安装 hugo 提供了很多种安装方式，Git, Docker, Binary. 个人电脑使用二进制安装是最方便快捷的，无需安装其他依赖。 到 Hugo Releases 下载对应的 windows 操作系统版本的 Hugo 二进制文件，玩就要玩全的，所以我就选择了扩展版本，此次选择的最新版为 hugo_extended_0.88.1_Windows-64bit.zip, 然后自行解压安装即可。 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:2","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"生成站点 使用 Hugo 快速生成站点，比如希望生成到 /path/to/site 路径： hugo new site /path/to/site 站点目录结构： ▸ archetypes/ # 配置文章模板，相当于 hexo 的 scaffolds ▸ content/ # 文章页面内容，相当于 hexo 的 source ▸ data/ # 可存放一些 yaml, json, toml 格式的数据 ▸ layouts/ # 页面布局源码，改造主题可不动主题源码 ▸ static/ # 静态文件存放 config.toml # 站点配置文件，相当于 hexo 的 _config.yml ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:3","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"创建文章 注： 路径要写以 content/ 为根目录的相对路径 hugo new path/fileName ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:4","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"添加主题 添加主题的方式选用 Git 子模组的形式，为了日后快速升级，避免在使用 hexo 中因大量魔改 next 主题而导致难以升级的困扰。 精挑细选最终选择了 LoveIt git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 在 config.toml 添加 theme = \"LoveIt\" ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:5","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"在本地启动网站 使用以下命令启动网站: hugo serve --disableFastRender 去查看 http://localhost:1313 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:6","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"hugo build 使用以下命令生成静态文件，然后自己可手动选择部署到 github pages 或 COS 等服务器 hugo --minify ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:1:7","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"Hugo\u0026LoveIt 使用 LoveIt 主题文档 - 基本概念 写作指南 LoveIt 主题文档 - 内容 LoveIt 主题文档 - 内置 Shortcodes LoveIt 主题文档 - 扩展 Shortcodes ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:2:0","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"Todo list hugo-blog https://github.com/Lruihao/hugo-blog 原来 hexo 做了大量的美化和扩展功能，迁移到 hugo 想尽可能多的保留。取之精华，去其糟粕。 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:3:0","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"Base 迁移 hexo 所有文章内容 迁移 hexo 所有页面内容 留言页面 网友打赏支持页面，整合到留言页面 重写关于页面，一切从简 友情链接页面 重写 404 页面 热度页面整合到 404 页面 站点时间和不蒜子计数改到 hello-world 页面 新增页面 cos-album 和 🍚饭醉团伙🍷 整合到博客 cos-album/ 新增 demo/, 以子模组的形式存放前端 demo serverless 记账本 博客 valine 评论，阅读数迁移，可用 leancloud API 写代码转化(但似乎没必要) 博客 SEO 优化迁移 Github actions 自动部署到 Github pages 和 COS 脚本编写 hugo 本地管理 shell 脚本工具编写 知乎卡片式链接 改成 hugo shortcodes, 取名 cardlink zxm/沐目体 归档 :( 安装 沐目体 压缩 沐目体 fontspider 沐目体 post 修订 typyit 配合 随机诗词和网易云热评 API 实时预览功能 base on Vuejs [恋爱叙事体] love 归档 [光] 归档 hugo 内容加密研究 Lruihao/hugo-blog/README.md 撰写，发布 1.0.0 版本做完整备份，base on theme version 更换 gravatar 头像 博客在线编辑器研究 github1s 等 ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:3:1","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":["hugo"],"content":"Theme LoveIt hugo LoveIt 主题整体优化，必要时建 PR 或 issue 到 LoveIt 仓库 (LoveIt 已停更一年多) 先把自己发现和 LoveIt 原 repo 的 issue 尽可能的修复，修改的原则是：不改动原项目代码， 唯一途径就是在站点相同的目录用新增的方式替代修改、删除操作。 之后再等等看作者是否还会更新，如已做大量的更改，再做考虑整合为一个新的主题。 CSS 优化，背景，元素圆角化，外圆内方，居中对其等 沐目体引入 TOC 序号生成 Fix: 无标题时也会生成目录的 BUG subtitle 等细节优化 Fix: typeit 打印代码时跑版的问题 Fix: 文章 h1 标题多行跑版 Code Review ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:3:2","tags":["hugo","hexo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":null,"content":"暫時不接受友鏈！ Warn: 超過兩年為更新或長期挂掉的站點將被取消！ -- 基本資訊 名稱：菠菜眾長 地址：https://lruihao.cn 描述：不怕萬人阻擋，只怕自己投降 Logo： avatar 或 gravatar 友情提醒 互換友鏈請按以上格式在評論留言。（僅限個人非商業部落格/網站）。 Warn: 網站失效、停止維護、內容不當都可能被取消連結！ 那些不尊重他人勞動成果，轉載不加出處的，或惡意行為的網站，還請您不要來進行交換了。 ","date":"2021-09-19","objectID":"/friends/:0:0","tags":null,"title":"友鏈","uri":"/friends/"},{"categories":null,"content":"Welcome 非常感谢朋友们的 ☕☕☕~ 2018.09.28 francs AliPay ￥50 作为一个大学生，第一次在网上收到别人的支持，内心表示受宠若惊又非常开心。拿这 50 块买了半年腾讯云服务器!真的非常感谢老哥的支持！ 2018.10.26 francs QQ ￥8.8 今天学校运动会没课，睡到 9 点多起来看到 QQ 收到一个红包，也是很开心！感谢支持！ 2018.11 francs QQ ￥8.8 2018.12.04 * 昌升 AliPay ￥10 上课的时候听到了支付宝清脆的支付宝到账10元的声音！感谢评论区匿名打赏的兄dei! 2018.12.04 * 昌升 AliPay ￥18 晚上加了一个qq好友，聊天之中又收到支付宝的提示，才知道是谁打赏的，真的很感谢每笔打赏！ 2019.03.19 A*r WechatPay ￥2 2019 收到的第一笔打赏！每一份打赏支持我都心存感激！谢谢各位兄弟！231****047#qq.com 2020.01.17 * 喜洲 QQ ￥20.20 时隔一年再次因为这个博客收到打赏，谢谢大家看得起！有关博客的问题，我能解答的都会帮助你们。101****073 ","date":"2021-09-13","objectID":"/guestbook/:0:0","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":null,"content":" Hacknical Gitmemory My summary ","date":"2021-09-07","objectID":"/about/:0:0","tags":null,"title":"關於","uri":"/about/"},{"categories":null,"content":"初衷 初衷 ","date":"2021-09-07","objectID":"/about/:1:0","tags":null,"title":"關於","uri":"/about/"},{"categories":null,"content":"期許 不卑不亢，不矜不伐，戒驕戒躁 不嗔不怒，不爭不棄，獨善其身 ","date":"2021-09-07","objectID":"/about/:2:0","tags":null,"title":"關於","uri":"/about/"},{"categories":null,"content":"Todo list recently ","date":"2021-09-07","objectID":"/about/:3:0","tags":null,"title":"關於","uri":"/about/"},{"categories":null,"content":"Study/Code myself hexo to hugo COS Album v1.1.8 valine-admin 重构 jsDoc \u0026 PHPDoc uni-app 學習與實踐 dart flutter 閱讀 《計算機網絡》 閱讀 《操作系統》 閱讀 《算法與數據結構》 Web UI 設計 ","date":"2021-09-07","objectID":"/about/:3:1","tags":null,"title":"關於","uri":"/about/"},{"categories":null,"content":"Life 臨帖 《心經 - 赵孟頫》 臨帖 《真草千字文》 閱讀 《笑場 - 李誕》 進度: 1/2 閱讀 《神雕俠侶 - 金庸》 進度: 1/4 打籃球🏀 減脂到 \u003c60kg 重裝系統后缺失的軟體 wampserver axure vscode Git SourceTree ","date":"2021-09-07","objectID":"/about/:3:2","tags":null,"title":"關於","uri":"/about/"},{"categories":null,"content":"Work Axios \u0026 Promise PHP 備課，帶新人 研究標籤机編程，對接 MES, OrmIT, OIS 系統 jQuery 改原生 個性化推薦選單 深入理解 Mysql ES6 VueJs 全家桶 MVVM ","date":"2021-09-07","objectID":"/about/:3:3","tags":null,"title":"關於","uri":"/about/"},{"categories":["CSS"],"content":" Sass 和 Less 都屬於 CSS 前置處理器，CSS 前置處理器定義了一種新的語言，其基本思想是，用一種專門的程式設計語言，為 CSS 增加了一些程式設計的特性，將 CSS 作為目標生成檔，然後開發者就只要使用這種語言進行CSS的編碼工作。 轉化成通俗易懂的話來說就是**“用一種專門的程式設計語言，進行 Web 頁面樣式設計，再通過編譯器轉化為正常的 CSS 檔，以供專案使用”。** 為什麼，什麼時候要使用 CSS 前置處理器？ (Why, When) CSS 有具體以下幾個缺點： 語法不夠強大，比如無法嵌套書寫，導致模組化開發中需要書寫很多重複的選擇器 沒有變數和合理的樣式複用機制，使得邏輯上相關的屬性值必須以字面量的形式重複輸出，導致難以維護 這就導致了我們在工作中無端增加了許多工作量。而使用 CSS 前置處理器可大大提高了我們的開發效率： 提供 CSS 缺失的樣式層複用機制 減少冗餘碼 提高樣式代碼的可維護性。 但是，CSS 的好處在於簡便、隨時隨地被使用和調試。這就使得預編譯 CSS 步驟的加入具有以下缺點： 開發工作流中多了一個環節，調試也變得更麻煩 預編譯很容易造成後代選擇器的濫用 所以我們在實際項目中衡量預編譯方案時，還是得想想，比起帶來的額外維護開銷，CSS 前置處理器有沒有解決更大的麻煩。 系統級框架開發 (大型複雜的樣式設計) 持續維護 Less、Sass/Scss 是什麼？ (What) ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:0:0","tags":["less","sass","scss","Frontend"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"Less 是一種動態樣式語言. 對 CSS 賦予了動態語言的特性，如變數、繼承、運算、函數。 Less 既可以在用戶端上運行 (支援IE 6+, Webkit, Firefox)，也可在服務端運行。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:1:0","tags":["less","sass","scss","Frontend"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"Sass 是一種動態樣式語言，Sass 語法屬於縮排語法， 比 CSS 比多出好些功能(如變數、嵌套、運算,混入(Mixin)、繼承、顏色處理，函數等)，更容易閱讀。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:2:0","tags":["less","sass","scss","Frontend"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"Sass 與 Scss 的關係 Sass 的縮排語法，對於寫慣 CSS 的前端開發者來說很不直觀，也不能將 CSS 代碼加入到 Sass 裡面，因此 Sass 語法進行了改良，Sass 3 就變成了 Scss(Sassy CSS)。與原來的語法相容，只是用{}取代了原來的縮進。Sass 相當於 Scss 的嚴格模式。 Sass 和 Less 的比較 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:3:0","tags":["less","sass","scss","Frontend"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"相同點 Less 和 Sass 在語法上有些共性，比如下面這些： 混入(Mixins)——class中的class 參數混入——可以傳遞參數的class，就像函數一樣 嵌套規則——Class中嵌套class，從而減少重複的代碼 運算——CSS中用上數學 顏色功能——可以編輯顏色 名字空間(namespace)——分組樣式，從而可以被調用 作用域——局部修改樣式 JavaScript 賦值——在CSS中使用JavaScript運算式賦值 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:4:0","tags":["less","sass","scss","Frontend"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["CSS"],"content":"不同點 實現方式 Less是基於JavaScript，是在用戶端處理的 Sass是基於Ruby的，是在伺服器端處理的 關於變數在Less和Sass中的唯一區別就是Less用@，Sass用$ less 中的變量運算可帶、可不帶單位，Sass 需要帶單位元 語法不同，請詳見 Less、Sass 官網 選用 Less 還是 Sass ? 無論是學習資料，討論情況，以及項目使用情況 Sass/Scss 都優於 Less，比如 Bootstrap 4 就使用的 Sass, 但是 Less 的使用更加簡單，使用門檻也較低，內網開發的情況，Less 則更加適合。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:5:0","tags":["less","sass","scss","Frontend"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["JavaScript"],"content":"簡介 Lightbox (燈箱)，用来放大显示图片覆盖于当前页面之上。其是用CSS来定义图片容器，用一幅半透明的png图片实现渐变阴暗的效果。 一般的網頁，圖片是使用 img 標籤寫在 HTML 頁面中，圖片點擊并不會放大，想放大看圖片要麼方法整個網頁，要麼複製圖片鏈接新開窗口，操作繁瑣，而使用 Lightbox 的網站可以点击缩略图浮层显示大图，放大後可点击键盘←、→键切换图片，也可以鼠标点击左右箭头切换。按下键盘Esc键或者点击关闭按钮可輕鬆關閉圖層，圖片流覽的體驗度是遠遠大於未使用的 Lightbox 的網站。 實現思路 大概思路就在每个图片的点击事件中添加图层与图片副本。 /** * @author github.com@flymysql */ let container = document.documentElement||document.body; let img,div,src,btnleft,btnright; var imgid=0; let x,y,w,h,tx,ty,tw,th,ww,wh; let closeMove=function(){ if(div==undefined){ return false; } div.style.opacity=0; img.style.height=h+\"px\"; img.style.width=w+\"px\"; img.style.left=x+\"px\"; img.style.top=(y - container.scrollTop)+\"px\"; // 延迟移除dom setTimeout(function(){ div.remove(); img.remove(); btnright.remove(); btnleft.remove(); },100); }; let closeFade=function(){ if(div==undefined){ return false; } div.style.opacity=0; img.style.opacity=0; // 延迟移除dom setTimeout(function(){ div.remove(); img.remove(); btnright.remove(); btnleft.remove(); },100); }; let style=function() { btnleft.style.cssText=` position:fixed; border-radius: 50%;; left:${x - 20}px; top:${y - container.scrollTop + h/2}px; width:50px; height:50px; border: 0px; background-color: rgba(200,200,200,0.8); font-size: 20px; z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; btnright.style.cssText=` position:fixed; border-radius: 50%; left:${x + w + 20}px; top:${y - container.scrollTop + h/2}px; width:50px; border: 0px; height:50px; font-size: 20px; background-color: rgba(200,200,200,0.8); z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; btnleft.innerText=\"\u003c\"; btnright.innerText=\"\u003e\"; img.style.cssText=` position:fixed; border-radius: 12px; left:${x}px; top:${y - container.scrollTop}px; width:${w}px; height:${h}px; z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); opacity:0; `; } // 监听滚动关闭层 document.addEventListener(\"scroll\",function(){ closeFade(); }); document.querySelectorAll(\"img\").forEach(v=\u003e{ if (v.parentNode.localName!='a') { v.id=imgid; imgid++; v.addEventListener(\"click\",function(e){ // 注册事件 // 记录小图的位置个大小 x=e.target.offsetLeft; y=e.target.offsetTop; w=e.target.offsetWidth; h=e.target.offsetHeight; src=e.target.src; id=e.target.id; // 创建遮罩层 div=document.createElement(\"div\"); div.style.cssText=` position:fixed; left:0; top:0; bottom:0; right:0; background-color: rgba(25,25,25,0.8); z-index:99999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; document.body.appendChild(div); setTimeout(function(){ div.style.opacity=1; },0); // (此处可以加loading) // 创建副本 img=new Image(); btnright=document.createElement(\"button\"); btnleft=document.createElement(\"button\"); img.src=src; style(); btnleft.onclick=function(){ if(id===0){ alert(\"已经是第一张了！\"); return; } var left=document.getElementById(id-1); img.src=left.src; x=left.offsetLeft; y=left.offsetTop; w=left.offsetWidth; h=left.offsetHeight; style(); id--; } btnright.onclick=function(){ id++; if(id\u003e=imgid){ alert(\"已经是最后一张了！\"); return; } var right=document.getElementById(id); img.src=right.src; x=right.offsetLeft; y=right.offsetTop; w=right.offsetWidth; h=right.offsetHeight; style(); } img.onload=function(){ document.body.appendChild(img); document.body.appendChild(btnright); document.body.appendChild(btnleft); // 浏览器宽高 wh=window.innerHeight; ww=window.innerWidth; // 目标宽高和坐标 if(w/h\u003cww/wh){ th=wh-80; tw=w/h*th \u003e\u003e 0; tx=(ww - tw) / 2; ty=40; } else{ tw=ww*0.8; th=h/w*tw \u003e\u003e 0; tx=ww*0.1; ty=(wh-th)/2; } // 延迟写入否则不会有动画 setTimeout(function(){ img.style.opacity=1; img.style.height=th+\"px\"; img.style.width=tw+\"px\"; img.style.left=tx+\"px\"; img.style.top=ty+\"px\"; btnleft.style.left=(tx-90)+\"px\"; btnleft.style.top=(ty+th/2)+\"px\"; btnright.style.left=(tx+tw+40)+\"px\"; btnright.style.top=(ty+th/2)+\"px\"; // 点击隐藏 div.onclick=img.onclick=closeMove; },10); }; });//end event } });//end forEach fancybox fancybox 是一個完善的 lightbox 插件 jQuery lightbox script for displaying images, videos and more. Touch enabled, responsive and fully custo","date":"2021-06-21","objectID":"/posts/lightbox/:0:0","tags":["Lightbox","JavaScript","Frontend"],"title":"Lightbox","uri":"/posts/lightbox/"},{"categories":["JavaScript"],"content":"Quick start Add latest jQuery and fancyBox files \u003cscript src=\"https://code.jquery.com/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003clink href=\"/path/to/jquery.fancybox.min.css\" rel=\"stylesheet\"\u003e \u003cscript src=\"/path/to/jquery.fancybox.min.js\"\u003e\u003c/script\u003e Create links \u003ca data-fancybox=\"gallery\" href=\"big_1.jpg\"\u003e \u003cimg src=\"small_1.jpg\"\u003e \u003c/a\u003e \u003ca data-fancybox=\"gallery\" href=\"big_2.jpg\"\u003e \u003cimg src=\"small_2.jpg\"\u003e \u003c/a\u003e Enjoy! ","date":"2021-06-21","objectID":"/posts/lightbox/:1:0","tags":["Lightbox","JavaScript","Frontend"],"title":"Lightbox","uri":"/posts/lightbox/"},{"categories":["生活随笔"],"content":"後知後覺 2020 已經過去半年了，由於情緒過於複杂，一直不想去回憶總結那操蛋的一年。今天疫情原因居家辦公，得空靜下來，和自己對話，不知从何說起，想到哪寫到哪吧。 2020 始於新冠，終於疫情。中間夾雜太多遺憾，離別和壓力，20年可以説从年頭到年尾都糟糕透了。 ","date":"2021-06-21","objectID":"/years/2020-2021/:0:0","tags":["总结","生活随笔"],"title":"和自己對話-2020\u00262021 總結","uri":"/years/2020-2021/"},{"categories":["生活随笔"],"content":"離 首先是和 zxm 分手了，過程太糟心的，無疑成為了我一年渾渾噩噩的最大因素。 最後那段時光真的不想記住，這裡也就不再回憶了。就當衹是 19 年底最後的願望落空了吧。 分開后那個夏天酒勁大了很多， 也開始抽煙，記不得抽了多少隻烟，只知道手臂上多了幾個抽煙發呆不小心燙的煙疤。 分開後，各種不理智的打擾幾乎都是我。如果知道註定終有一別，我們應該好好說一聲再見的。 而不是一年后我看夠了你討厭我的樣子，諾諾地放下，不斷告訴自己她已經走遠了。 此次“告別”，拖的晚了些，真是抱歉了，和你在一起度過整个大學生涯，湖工一草一木都曾見證過我們的甜蜜，一起在ACM刷題，一起在圖書館學習，一起吃吃吃，當然還有煩人的爭吵。那過去四年，我從未感覺過的幸福，以及…遺憾。 其實和你分開到現在，我總會在半夜想起你，可這讓我真的太糾結了。想到你會讓我很痛苦，可若讓我忘記你，我是真的捨不得。可能你不會知道，其他人也不會知道，還記得你送我的哪個熱水袋的毛絨娃娃嗎，它也許知道。 可是，我真的要和過去的你説再見了，上次一別，希望往後不要再見面了，無法想像再見到你我的心情會有多複杂。 不過，還是要好好謝謝你，謝謝你的陪伴，山水一程，已是萬幸。 感謝你讓我在大學時光有了目標，變得更好。 感謝你，給了我愛與被愛的能力，讓我遇見更完整的自己。 其實我早就知道不可能了， 我早該放下了，衹是過去的記憶和承諾拖著我不肯讓我嚮前走去。 沒關係了，我們總要告別舊的人才能獲得新的生活。置死後生。 我知道，其實多年后，這段感情仍會是我的一個心結， 其實多年后，一切也不重要了，不介意心裡留一塊地給過去的你我。 ","date":"2021-06-21","objectID":"/years/2020-2021/:1:0","tags":["总结","生活随笔"],"title":"和自己對話-2020\u00262021 總結","uri":"/years/2020-2021/"},{"categories":["生活随笔"],"content":"別 生離死別，20年的末梢，平安夜那天，也是考研的第一天。那晚，我們一個大學四年朝夕相處的室友兄弟，選擇了燒炭，操，真他媽傻逼！說好的考研後“慶功宴”呢，還等著和你吹牛逼呢。 跨年前一周，幾個兄弟在微信QQ群裡給你發消息都一直不回，直到跨年那晚想打電話給你吹吹牛逼，微信 QQ 電話都打不通，就感覺不對勁了。由於比較晚了，想著第二天再打電話給你爸問問情況，我和小賀先後打過去，直接愣住了，你爸的語氣讓人心疼。那天的披薩如同嚼蠟。 之後呢，你爸爸為數不多發的幾條朋友圈都是在表達想你。 兄弟，一路走好，此刻沒有你愛的利群，點隻雙囍送你，永遠懷念。 ","date":"2021-06-21","objectID":"/years/2020-2021/:2:0","tags":["总结","生活随笔"],"title":"和自己對話-2020\u00262021 總結","uri":"/years/2020-2021/"},{"categories":["生活随笔"],"content":"\u0026 20 年呢也不是沒有收獲，那段時間一個人瘋狂加班。 部門的核心代碼幾乎都是我在維護優化和新增功能，也得以抬愛成為開發組組長。 還帶了20的實習生，从最基礎的開始教他們（真的累。。。），可惜最後留下的沒幾個，太過於浮躁了。 然後也學會了做飯，而且賣相口味都還可以，只可惜沒能給她做了。 我，不過是一介普通人， 生活，需要沉澱。 2021 寫到這吧，要熱飯了，年底再來… 又开始找回自己，和自己做朋友，让自己开心真是一件平凡的伟事。 ","date":"2021-06-21","objectID":"/years/2020-2021/:3:0","tags":["总结","生活随笔"],"title":"和自己對話-2020\u00262021 總結","uri":"/years/2020-2021/"},{"categories":["JavaScript"],"content":"just for backup of watermark. Watermark Class /* global Tiger */ Tiger.Watermark = function Watermark() { var _wmObserver; var _wmParentObserver; var _windowsWidth = window.outerWidth; var _windowsHeight = window.outerHeight; /** * create Dom of watermark's container * @param {Tiger.Watermark} watermark */ var _createContainer = function (watermark) { watermark._container = document.createElement('div'); $(watermark._container).appendTo('.tiger-main-container') .addClass('tiger-watermark-container') .addClass(watermark.options.className) .attr('aria-hidden', true); }; /** * create watermark's Dom * @param {Tiger.Watermark} watermark * @param {Object} options */ var _createWatermark = function (watermark, options) { options.rowSpaceing = options.rowSpaceing || 50; options.colSpaceing = options.colSpaceing || 30; options.width = options.width || 150; options.height = options.height || 20; let navbarHeight = $('.tiger-navbar').outerHeight() || 0; let rows = parseInt((_windowsHeight - navbarHeight) / (options.height + options.rowSpaceing)); let cols = parseInt(_windowsWidth / (options.width + options.colSpaceing)); let offsetLeft = (_windowsWidth - options.width * cols - options.colSpaceing * (cols - 1)) / 2; let offsetTop = navbarHeight / 2 + (_windowsHeight - options.height * rows - options.rowSpaceing * (rows - 1)) / 2; for (let row = 0; row \u003c rows; row++) { let top = offsetTop + (options.rowSpaceing + options.height) * row; for (let col = 0; col \u003c cols; col++) { let left = offsetLeft + (options.colSpaceing + options.width) * col; $(document.createElement('div')).appendTo(watermark._container) .addClass('tiger-watermark') .css({ 'left': `${left}px`, 'top': `${top}px`, 'width': `${options.width}px`, 'height': `${options.height}px`, 'transform': `rotate(${options.rotate}deg)`, 'opacity': `${options.opacity}`, 'font-size': `${options.fontSize}rem` }) .html(options.content); } } }; /** * Re render watermark * @param {Tiger.Watermark} watermark * @param {Object} options */ var _render = function (watermark, options){ _wmObserver.disconnect(); $(watermark._container).empty(); _createWatermark(watermark, options); _wmObserver.observe(watermark._container, { attributes: true, childList: true, characterData: true, subtree:true }); }; /** * Observe watermark and watermark's parentNode mutations * @param {Tiger.Watermark} watermark */ var _addObserve = function(watermark){ //observe watermark element and its child element _wmObserver = new MutationObserver(function(mutations, observer) { _render(watermark, watermark.options); }); _wmObserver.observe(watermark._container, { attributes: true, childList: true, characterData: true, subtree:true }); //observe parent element, recreate if the element is deleted _wmParentObserver = new MutationObserver(function(mutations) { for(m of mutations){ if(m.type === 'childList' \u0026\u0026 m.removedNodes.length \u003e 0 \u0026\u0026 $('.tiger-watermark-container').length !== 1) { $(watermark._container).appendTo('.tiger-main-container'); } } }); _wmParentObserver.observe(watermark._container.parentNode, { childList: true, subtree: true }); }; /** * windows resize listener * @param {Tiger.Watermark} watermark */ var _addResizeListener = function(watermark){ $(window).on('resize', function(){ if(window.outerHeight !== _windowsHeight || window.outerWidth !== _windowsWidth){ _windowsHeight = window.outerHeight; _windowsWidth = window.outerWidth; _render(watermark, watermark.options); } }); }; /** * Tiger.Watermark.\u003cbr/\u003e * create watermark for webpage and automatic adjust when windows resie. * @param {Object} options * @param {String} options.content watermark's text * @param {Number} [options.width=150] watermark's width. unit: px * @param {Number} [options.height=20] watermark's height. unit: px * @param {Number} [options.RowSpaceing=50] row spaceing of watermarks. unit: px * @param {Number} [options.colSpaceing=30] col spaceing of watermarks. unit: px * @param {Number} [options.rotate=15] watermark's tangent angle. unit: deg * @p","date":"2021-05-23","objectID":"/posts/watermark-fixed/:0:0","tags":["watermark","JavaScript","Frontend"],"title":"watermark base on position fixed","uri":"/posts/watermark-fixed/"},{"categories":["Fullstack"],"content":"程式碼的持續優化 對一個入門的工程師來說，掌握程式語法與模仿範例實作是基本的能力。那有了這樣的基本能之後，要如何寫出更好的程式呢？怎樣才能夠成為一個「優秀」的新手工程師呢？事實上，寫出會動的程式不難，但想寫出好的程式其實是需要刻意練習的。大部分的人會建議要「多練習、多實作」，但我認為在大量練習之外，適時的「優化程式」也是提升「程式碼品質」重要的關鍵。而在「優化程式」可以分成兩個角度： 程式執行效能更好 程式碼結構更精簡 程式執行效能就是從速度跟空間來思考，執行時間越短、變數佔用空間越小。而程式碼結構則會從可讀性和精簡來衡量，例如：變數的命名有沒有意義、程式碼有沒有冗余、繁瑣的部分等等。只不過新手很容易停留在寫出程式的喜悅以及受到固有的解題思考，而忽略優化的過程。 透過「Code Review」是推薦新手的方法，經由反饋與討論來找出程式中可優化的空間。 Code Review 的關注點 以我自己的經驗來說，Review 一份專案的時候會關注： 程式能不能正常操作，有没有什么明显的错误？（低標） 程式碼當中有沒有奇怪的地方？（優化） 第一個關注點是程式碼的低標，結果正確與可正常運行一定是最重要的。如果程式無法運行動或存在很明顯的問題，那再多的優化都沒有意義。除了確保執行之外，同時也會檢查一下是否有低級的邏輯失誤或是安全性的疑慮，像是資料庫沒有正確關閉或密碼明碼沒有加密之類的問題。 第二個關注點是「程式碼品質提升」的部分，我會把它定義成程式運作上沒有問題，但看起來很不舒服或執行效率很差的部分。大致上可以從以下幾點下手： 命名有沒有意義/不一致 資料庫的正規化情況 是否存在特別複雜的程式片段（例如多次的資料庫查詢、多層的迴圈使用） 重複的程式碼有沒有定義成 function 冗長的程式碼能不能拆分成 function 不過一次的 Code Review 建議著重在 3 - 5 個優化地方，比較容易聚焦在優化的品質。根據時程的壓力，決定 Code Review 迭代的次數。 從架構的規劃到細節的優化 在拿到一份程式碼時，通常會先掃過一眼程式的檔案結構，是否有不該上傳的檔案或缺漏。 以這個例子來說，第一眼會覺得檔案配置蠻結構化的。但再多看一點會發現存在幾個冗餘的檔案，例如：-filesqqqq、diff，甚至 /icon 資料夾也不該放在最上層。 進入程式的第一步先從 package.json 檔案開始，確認一下專案的基本資訊是否完整、使用到的套件與版本，以及程式的進入點是什麼。然後打開進入點的檔案（通常會命名成 app 或 main），通常有幾個點需要注意：「套件的載入順序」會建議從第三方套件 → 自定義的模組 → 程式內的變數這樣順序定義；「善用 MVC 的架構」將非主程式的部分依照功能拆分模組，避免檔案資訊量太雜亂。接著就會從 Router → Controller → Service → View 的流程一個一個功能，以下分享一些存在優化空間的程式碼： 善用工具，已有的工具，不用自己手刻 變數名稱不建議用大寫開頭（通常是用在 Class 的命名） 保持優化的空間與彈性 「優化其實是一種取捨」，不需要也不應該追求一步到位。開發往往都是在品質跟產出做取捨，初期可以把開發目標放在「先求可以動，再求持續優化」的節奏上。新手需要在意的點有幾下兩點： 很容易把重點全部放在程式碼的產出上而忽略的程式碼的品質。 停留在做出成果的喜悅，而停滯了優化的步調。 因此，會建議在開發當下就「多想」兩秒鐘，感覺可優化但來不及的部分先在旁邊加個註解提醒自己。另外也養成一段時間回頭看之前的程式碼的習慣，試著刻意找出可以優化改進的部分。專案的提交可能會有期限，但程式碼的優化沒有盡頭。面對相同的專案與程式碼，唯有透過不停的迭代優化才能打造更好的程式，同時也見證了你和程式一起變得更好的過程。所以建立逐步優化的空間，養成持續提升程式碼品質的習慣，才是一個新手工程師需要修煉的心法。 ","date":"2021-03-04","objectID":"/posts/codereview/:0:0","tags":["codereview","Fullstack"],"title":"Code Review 怎麼做？新手工程師如何提升「程式碼品質」","uri":"/posts/codereview/"},{"categories":["JavaScript","VueJS"],"content":"起因 起因 事情是這樣，年前和朋友一起合租了一個房子，然後捏，生活嘛，除了開心，當然是乾飯最大啦！ 自然就會有購物，買菜等日常消費，那就要記賬，一開始是各自記在手機的便簽上，最後再算一下； 三個人，一共七种組合消費，排除各自消費的三種情況，也有四種 (AB, AC, BC, ABC)。好麻煩啊！！！ 經過 作為一個程序猿，怎麼能接受這麼麻煩的記賬方式呢，拿起筆就開始畫，於是有了下面這張圖的公式。簡單說明一下就是： 設前面說的四種組合為: X1, X2, X3, X4，個人實際付款總額為: Y1, Y2, Y3，那麼帶入未知數，我們就可以算出每個人最後結算時的錢: S1, S2, S3， 綜上所述，很好理解，當 S \u003e= 0 時，收紅包，當 S \u003c 0 時，發紅包。 OK，一個簡單的初中方程式已經到位了，下一步，思考一下，用什麼來運作這個這個方程。來，先跑個題，春節期間，不是每天都要在騰訊文檔上填表記錄活動軌跡嗎？ 再回來，那不如就用 excel 實現吧，三個人都可以在手機上編輯。好的，說做就做。 一頓操作，10 minutes later… 只新建了一個 excel 文件，O.o! 不會 excel，果斷放棄，另尋他路。 結果 回到本職，那不如寫個網站吧，可是畢業後，學生機服務器也過期了，怎麼搞？那就寫個純前端的，數據呢存哪裡？ 別急，重新擼一擼需求先： 存取消費數據 計算每月，實付(總分)，應付以及最後計算結算金額 按月查詢，月結賬單 三人皆可編輯 主要就是存取數據這點，沒有服務器，數據庫怎麼實現？ valine 可以實現無後端，那我是不是也可以，leancloud 文檔走一波，然後“數據表”設計一下，其實是 leancloud-storage Object ，於是有了以下東西，源碼放在 Github bill-note http://github.com/Lruihao/bill-note ","date":"2021-03-02","objectID":"/posts/bill-note/:0:0","tags":["JavaScript","leancloud","VueJS","Frontend"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill-note/"},{"categories":["JavaScript","VueJS"],"content":"數據設計 去 leancloud 创建一个应用，再新增一个 Bill Class, 补充一下字段： name type description pay Number 消费金额 pay_description String 消费描述 pay_type String 消费类型 pay_user String 付款人 ","date":"2021-03-02","objectID":"/posts/bill-note/:1:0","tags":["JavaScript","leancloud","VueJS","Frontend"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill-note/"},{"categories":["JavaScript","VueJS"],"content":"主要邏輯 ","date":"2021-03-02","objectID":"/posts/bill-note/:2:0","tags":["JavaScript","leancloud","VueJS","Frontend"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill-note/"},{"categories":["JavaScript","VueJS"],"content":"初始化 set for yourself. AV.init({ appId: '', appKey: '', serverURL: '' }); ","date":"2021-03-02","objectID":"/posts/bill-note/:2:1","tags":["JavaScript","leancloud","VueJS","Frontend"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill-note/"},{"categories":["JavaScript","VueJS"],"content":"存數據 //記賬提交按鈕事件監聽 document.querySelector('.submit').addEventListener('click',function(event){ event.preventDefault(); let formPay = document.querySelector('#form-pay'); let bill = new AV.Object('Bill'); bill.set('pay', Number(formPay.pay.value)); bill.set('pay_type', Number(formPay.pay_type.value)); bill.set('pay_user', Number(formPay.pay_user.value)); bill.set('pay_description', formPay.pay_description.value); bill.save().then((object) =\u003e { formPay.reset(); }, (function (error) { console.log(JSON.stringify(error)); alert('保存失敗'); })) }); ","date":"2021-03-02","objectID":"/posts/bill-note/:2:2","tags":["JavaScript","leancloud","VueJS","Frontend"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill-note/"},{"categories":["JavaScript","VueJS"],"content":"取數據 /** * 獲取歷史消費記錄數據 * @param [start=0] 開始位置 * @param [count=15] 每次查詢筆數 */ function getBillData(start = 0,count = 15) { queryBill.descending('createdAt') .skip(start * count).limit(count) .find().then(function (response) { let billLength = response.length; if(billLength \u003e 0){ billVm.noMore = (billLength !== count) ? true : false; for(bill of response){ billVm.bills.push({ pay: bill.attributes.pay, payType: payType[bill.attributes.pay_type], payUser: payUser[bill.attributes.pay_user], payDescription: bill.attributes.pay_description, payDt: new Date(bill.createdAt).toLocaleString() }) } } else { billVm.noMore = true; } }); } /** * 獲取月賬單數據 * @param month 年月份 fmt: yyyy-MM */ function getMonthBill(month){ let dateTime = `${month}00:00:00` let startMonth = new Date(dateTime); let nextMonth = new Date(new Date(dateTime).setMonth(startMonth.getMonth() + 1)); let startDateQuery = new AV.Query('Bill'); startDateQuery.greaterThanOrEqualTo('createdAt', startMonth); let endDateQuery = new AV.Query('Bill'); endDateQuery.lessThan('createdAt', nextMonth); let MonthBillQuery = AV.Query.and(startDateQuery, endDateQuery); MonthBillQuery.find().then(function(response){ billVm.monthBill = { payType0: 0, payType1: 0, payType2: 0, payType3: 0, payUser0: 0, payUser1: 0, payUser2: 0 }; for(bill of response){ let {pay, pay_type, pay_user} = bill.attributes; billVm.monthBill[`payType${pay_type}`] += pay; billVm.monthBill[`payUser${pay_user}`] += pay; } }); } ","date":"2021-03-02","objectID":"/posts/bill-note/:2:3","tags":["JavaScript","leancloud","VueJS","Frontend"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill-note/"},{"categories":["JavaScript","VueJS"],"content":"技術棧 leancloud-storage Vue.js HTML,CSS,JS 總結 簡單總結一下，登录功能不做，安不安全自己说了算。删除修改功能也不做，直接上 leacloud 操作，css 美化的样式也不写，干净又卫生！ 然后衍生一下，什么过年斗地主，天炸，麻将，字牌记账系统那不也是同理可得嘛！ over! ","date":"2021-03-02","objectID":"/posts/bill-note/:3:0","tags":["JavaScript","leancloud","VueJS","Frontend"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/posts/bill-note/"},{"categories":["PHP"],"content":" Cell Blog 开发记录，项目地址 搭建php环境 安装wampserver 安装composer 更换aliyun源 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 新建laravel项目 composer create-project --prefer-dist laravel/laravel cell-blog \"7.*\" 或者 composer global require laravel/installer laravel new blog 下载debugbar composer require barryvdh/laravel-debugbar --dev 修改语言时区 修改config/app.php，将local的值 en 改成 zh-CN(laravel-admin自带zh-CN)： # 时区 'timezone' =\u003e 'Asia/Shanghai', # 语言 'locale' =\u003e 'zh-CN', 配置数据库 首先确保安装好了laravel，并且数据库连接设置正确。 APP_URL=http://cell.blog DB_CONNECTION=mysql DB_HOST=127.0.0.1 DB_PORT=3307 DB_DATABASE=cell_blog DB_USERNAME=root DB_PASSWORD=123456 下载laravel-admin cd cell-blog composer require encore/laravel-admin 卸载命令composer remove xxx 然后运行下面的命令来发布资源： php artisan vendor:publish --provider=\"Encore\\Admin\\AdminServiceProvider\" 在该命令会生成配置文件config/admin.php，可以在里面修改安装的地址、数据库连接、以及表名，建议都是用默认配置不修改。 然后运行下面的命令完成安装： php artisan admin:install 运行这个命令的时候，如果遇到了下面的错误: SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 1000 bytes (SQL: alter tableusersadd uniqueusers_email_unique(email)) 参考这个issue来解决 https://github.com/z-song/laravel-admin/issues/1541 在app\\Providers\\AppServiceProvider.php添加默认值 \u003c?php namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Support\\Facades\\Schema; //add fixed sql class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. * * @return void */ public function boot() { Schema::defaultStringLength(191); //add fixed sql } /** * Register any application services. * * @return void */ public function register() { // } } 启动服务后，在浏览器打开 http://localhost/admin/ ,使用用户名 admin 和密码 admin 登录. 报错Disk [admin] not configured, please add a disk config in config/filesystems.php 在config/filesystems.php中disks处添加以下配置后执行php artisan storage:link来创建软链接（windows和linux的软链接不一样不能直接复制！） 宝塔执行时删除禁用函数putenv(),symlink() 'admin' =\u003e [ 'driver' =\u003e 'local', 'root' =\u003e storage_path('app/public/system'), 'url' =\u003e env('APP_URL').'/storage/system', 'visibility' =\u003e 'public', ], 或 'admin' =\u003e [ 'driver' =\u003e 'local', 'root' =\u003e public_path('uploads'), 'url' =\u003e env('APP_URL').'/public/uploads/', 'visibility' =\u003e 'public', ], 下载dcat-admin composer require dcat/laravel-admin 然后运行下面的命令来发布资源： php artisan admin:publish 在该命令会生成配置文件config/admin.php，可以在里面修改安装的地址、数据库连接、以及表名，建议都是用默认配置不修改。 然后运行下面的命令完成安装： php artisan admin:install 迁移文件创建表 php artisan make:migration create_articles_table php artisan make:migration create_tags_table php artisan make:migration create_categories_table php artisan make:migration create_article_tags_table php artisan make:migration create_navigations_table php artisan make:migration create_friendship_links_table php artisan make:migration create_pages_table php artisan make:migration create_systems_table php artisan make:migration create_mottoes_table 运行迁移 php artisan migrate 创建模型model php artisan make:model Models/Article php artisan make:model Models/Category php artisan make:model Models/Tag php artisan make:model Models/Navigation php artisan make:model Models/FriendshipLink php artisan make:model Models/Page php artisan make:model Models/System php artisan make:model Models/Motto 创建控制器 php artisan admin:make ArticleController --model=App\\Models\\Article php artisan admin:make CategoryController --model=App\\Models\\Category php artisan admin:make TagController --model=App\\Models\\Tag php artisan admin:make NavigationController --model=App\\Models\\Navigation php artisan admin:make FriendshipLinkController --model=App\\Models\\FriendshipLink php artisan admin:make PageController --model=App\\Models\\Page php artisan admin:make SystemController --model=App\\Models\\System php artisan admin:make MottoController --model=App\\Models\\Motto 添加后台路由 app/Admin/routes.php $router-\u003eresource('articles', ArticleController::class); $router-\u003eresource('categories', CategoryController::class); $router-\u003eresource('tags', TagController::class); $router-\u003eresource('navigations', Navigati","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:0:0","tags":["PHP","Laravel","Markdown","Backend"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["PHP"],"content":"存放本地表情 public\\vendor\\laravel-admin-ext\\editormd\\editormd-1.5.0\\images\\emojis 修改editormd.js及editormd.min.js // Emoji graphics files url path editormd.emoji = { path : \"/iamges/emojis/\", ext : \".png\" }; ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:1:0","tags":["PHP","Laravel","Markdown","Backend"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["PHP"],"content":"图片上传 ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:2:0","tags":["PHP","Laravel","Markdown","Backend"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["PHP"],"content":"csrf 419错误 可以在VerifyCsrfToken.php中添加白名单跳过验证，或者手动添加csrf验证器： 修改image-dialog.js的var dialogContent 参考 if (settings.crossDomainUpload) { action += \"\u0026callback=\" + settings.uploadCallbackURL + \"\u0026dialog_id=editormd-image-dialog-\" + guid; } //添加csrf验证 var csrfToken = $('meta[name=\"csrf-token\"]').attr('content'); var csrfField = \"\"; if (csrfToken) { csrfField = \"\u003cinput type='hidden' name='_token' value='\" + csrfToken + \"' /\u003e\"; } markdown 转 HTML https://www.zhiqiexing.com/119.html Laravel Markdown安装 composer require graham-campbell/markdown php artisan vendor:publish 扩展表格 composer require league/commonmark config/markdown.php 'extensions' =\u003e [ League\\CommonMark\\Extension\\TaskList\\TaskListExtension::class, ], Eloquent 模型事件 Eloquent 模型可以触发事件，允许你在模型生命周期中的多个时间点调用如下这些方法：retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, restoring, restored。事件允许你在一个指定模型类每次保存或更新的时候执行代码。 retrieved 事件会在从数据库中获取已存在模型时触发。当一个新模型被首次保存的时候，creating 和 created 事件会被触发。如果一个模型已经在数据库中存在并调用 save 方法，updating/updated 事件会被触发，无论是创建还是更新，saving/saved 事件都会被触发。 添加后台验证码 依赖php扩展fileinfo 添加验证码 Media manager composer require laravel-admin-ext/media-manager php artisan admin:import media-manager 'extensions' =\u003e [ 'media-manager' =\u003e [ // Select a local disk that you configured in `config/filesystem.php` 'disk' =\u003e 'public' ], ], 给laravel-admin增加锁屏功能 composer require laravel-admin-ext/lock-screen 'route' =\u003e [ 'prefix' =\u003e 'demo', 'namespace' =\u003e 'App\\\\Admin\\\\Controllers', // 在中间件数组中加上'admin.lock' 'middleware' =\u003e ['web', 'admin', 'admin.lock'], ], 前台设计 创建控制器 php artisan make:controller HomeController php artisan make:controller ArticleController php artisan make:controller CategoryController php artisan make:controller TagController php artisan make:controller PageController 后台img灯箱 https://github.com/laravel-admin-extensions/grid-lightbox composer require laravel-admin-ext/grid-lightbox php artisan vendor:publish --tag=laravel-admin-grid-lightbox ","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:2:1","tags":["PHP","Laravel","Markdown","Backend"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["Python"],"content":" 使用python模拟浏览器行为刷csdn访问量，脚本仅做学习，请勿滥用~ 直接丢代码，把代码挂到服务器上可以策马奔腾~，也可以生成二进制文件放到Windows桌面上随时使用~ 打包exe参考 #!/usr/bin/python # -*- coding: utf-8 -*- __author__ = 'lruihao.cn' import urllib.request import re import time from bs4 import BeautifulSoup opener = urllib.request.build_opener() opener.addheaders = [('User-agent', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36')] def get_article_url(page,name): endurl = \"/\"+name+\"/article/details/........\" print(name) p = re.compile(endurl) url = \"http://blog.csdn.net/\"+name+\"/article/list/\"+str(page) # 使用build_opener()是为了让python程序模仿浏览器进行访问 html = opener.open(url).read().decode('utf-8') allfinds = p.findall(html) return allfinds #print('allfinds',allfinds) def start_do(allfinds): urlBase = \"http://blog.csdn.net\" # 需要将网址合并的部分 # 页面中的网址有重复的，需要使用set进行去重复 mypages = list(set(allfinds)) for i in range(len(mypages)): mypages[i] = urlBase + mypages[i] print('要刷的网页有：') for index, page in enumerate(mypages): print(str(index), page) # 设置每个网页要刷的次数 brushNum = 1 # 所有的页面都刷 print('下面开始刷了哦：') for index, page in enumerate(mypages): for j in range(brushNum): try: pageContent = opener.open(page).read().decode('utf-8') # 使用BeautifulSoup解析每篇博客的标题 soup = BeautifulSoup(pageContent) blogTitle = str(soup.title.string) blogTitle = blogTitle[0:blogTitle.find('-')] print(str(j), blogTitle) except urllib.error.HTTPError: print('urllib.error.HTTPError') time.sleep(3) # 出现错误，停几秒先 except urllib.error.URLError: print('urllib.error.URLError') time.sleep(3) # 出现错误，停几秒先 time.sleep(0.5) # 正常停顿，以免服务器拒绝访问 def main(name): for page in range(1,5): print(\"************第\"+str(page)+\"页*************\") endurl = get_article_url(page,name) start_do(endurl) if __name__ == '__main__': name = input(\"输入你的csdn用户名：\") if name==\"\": name = \"qq_39520417\" #cheung99857 while 1: main(name) print(\"开始休息...\") time.sleep(40) 主函数也可以这样写实现同时刷多人的访问量，人多可以适当减少休眠时间，当然有兴趣的可以尝试一下多线程~ if __name__ == '__main__': # 多用户 names = [\"qq_39520417\",\"cheung99857\"] while 1: for name in names: main(name) print(\"开始休息...\") # 控制休眠时间相当于控制刷新的速度 time.sleep(30) ","date":"2020-03-26","objectID":"/posts/csdnvisiter/:0:0","tags":["Python","Backend","脚本"],"title":"使用Python刷csdn访问量","uri":"/posts/csdnvisiter/"},{"categories":["Fullstack"],"content":" \u003c秒\u003e \u003c分钟\u003e \u003c小时\u003e \u003c日期 day-of-month\u003e \u003c月份\u003e \u003c星期 day-of-week\u003e 基本语法 位置字段约束取值可使用的特殊符号1秒必须0-59, - \\* /2分钟必须0-59, - \\* /3小时必须0-23（0 为午夜）, - \\* /4日期必须1-31, - \\* ? /5月份必须1-12、JAN-DEC, - \\* /6星期必须1-7、SUN-SAT, - ? / 特殊符号的用法 符号含义用法\\*所有值代表一个字段的所有可能取值。如将\u003c分钟\u003e 设为\\*，表示每一分钟。?不指定值用于可以使用该符号的两个字段中的一个，在一个表达式中只能出现一次。如任务执行时间为每月 10 号，星期几无所谓，那么表达式中\u003c日期\u003e 设为10，\u003c星期\u003e 设为?。-范围如\u003c小时\u003e 为10-12，即10 点、11 点、12 点。,分隔多个值如\u003c星期\u003e 为MON,WED,FRI，即周一、周三、周五。/增量如\u003c秒\u003e 设为0/15，即从 0 秒开始，以 15 秒为增量，包括 0、15、30、45 秒；5/15 即 5、20、35、50 秒。\\*/ 与0/ 等效，如\u003c日期\u003e 设为1/3，即从每个月的第一天开始，每 3 天（即每隔 2 天）执行一次任务。各字段以空格或空白隔开。JAN-DEC、SUN-SAT 这些值不区分大小写，比如 MON 和 mon 效果一样。 举例如下表达式说明0 0/5 \\* \\* \\* ?每隔 5 分钟执行一次10 0/5 \\* \\* \\* ?每隔 5 分钟执行一次，每次执行都在分钟开始的 10 秒，例如 10:00:10、10:05:10 等等。0 30 10-13 ? \\* WED,FRI每周三和每周五的 10:30、11:30、12:30、13:30 执行。0 0/30 8-9 5,20 \\* ?每个月的 5 号和 20 号的 8 点和 10 点之间每隔 30 分钟执行一次，也就是 8:00、8:30、9:00 和 9:30。","date":"2020-03-25","objectID":"/posts/cron/:0:0","tags":["linux","shell","Cron"],"title":"CRON 表达式的基本语法","uri":"/posts/cron/"},{"categories":["Python"],"content":"信息 这件事还得从一只蝙蝠说起… 算了，昨天下午3点半，我还在王者峡谷Timing,突然潇X巴哥打了个电话给我说关于自动打卡的想法… 哎，反正就是由于疫情需要每天健康打卡汇报给学校，然后每天提交一样的太麻烦了，就想写个程序自动打卡… 我和潇X巴哥确定思路后兵分两路： 他用java写个后台自动刷多人的，再弄个网页给用户填写账号密码保存在数据库； 我想的就很直接，只刷一个人的，python 模拟浏览器登录后打卡，再设置定时任务（多人则设定多个）； Windows运行效果 核心代码 适用湖南工程学院的打卡系统。 请勿滥用代码提交不实健康信息，隐瞒疫情将受到相关法律处理！ 完整代码 def lajaDaka(): # 登录 r1 = requests.post(login_url, data=login,headers=headers,verify=False) if r1.status_code == 200: print(time.strftime(\"%Y:%m:%d:%H:%M\", time.localtime())) print(login[\"username\"] + \" 登录成功！\") # 拿到登录后的cookie并添加到header中 header1 = r1.headers headers[\"Cookie\"] = header1[\"Set-Cookie\"] else: return # 打卡 r2 = requests.post(daka_url, data=daka,headers=headers,verify=False) response2=r2.json() if r2.status_code != 200: print(\"打卡失败！\") return if response2[\"result\"] == True: print(\"打卡成功！\") else: print(response2[\"errorInfoList\"][0][\"message\"]) if __name__==\"__main__\": lajaDaka() 自动运行 ","date":"2020-03-25","objectID":"/posts/daka/:0:0","tags":["Python","脚本","HTTP","Backend"],"title":"新冠疫情未返校未返工第N天之“自动打卡”","uri":"/posts/daka/"},{"categories":["Python"],"content":"Windows 适用python代码控制休眠时间 if __name__==\"__main__\": while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) # 设置每天8点发送 if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t脚本将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后打卡\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t脚本将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后打卡\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"软件明天开始将在每天8点发送数据！\") lajaDaka() time.sleep(24*60*60-int(now_min)*60) ","date":"2020-03-25","objectID":"/posts/daka/:1:0","tags":["Python","脚本","HTTP","Backend"],"title":"新冠疫情未返校未返工第N天之“自动打卡”","uri":"/posts/daka/"},{"categories":["Python"],"content":"linux(云服务器) 搭建python环境下载依赖后，使用shell脚本定时执行。 python /home/python/yiban_daka/daka.py CRON表达式的基本语法 潇x巴哥的java web版本 符合程序员的应该有的简洁和方便，干净又卫生！ http://39.105.174.214/index.html ","date":"2020-03-25","objectID":"/posts/daka/:2:0","tags":["Python","脚本","HTTP","Backend"],"title":"新冠疫情未返校未返工第N天之“自动打卡”","uri":"/posts/daka/"},{"categories":["生活随笔"],"content":" 回顾2019，是从“迷茫”到“忙”的一年，何为“迷茫”，何为“忙”。 ","date":"2020-01-16","objectID":"/years/2019/:0:0","tags":["总结","生活随笔"],"title":"2019年度总结","uri":"/years/2019/"},{"categories":["生活随笔"],"content":"上半年·湘潭·湖南工程学院 java 2019年伊始，步入大三下学期， 回顾大学前段生涯，无论是ACM是实验室里所学的所谓算法(甚至现在已经忘记怎么写了)， 还是自己一时兴起折腾的简单网页，似乎都无法支撑自己找到工作，甚至实习。 于是乎，浓浓的\"迷茫\"和\"焦虑\"感来了。 由于\"卓越计划\"的缘故，大四我们就不在学校了，要去企业实习。 这正是我所担心的，没有一技之长，哪家公司会收我。 不得不走上新的学习旅程，我选择了java，我也不知道为什么选java，反正就是选了。 制定了计划当然要执行啊，所以从2019年刚开始，我先把java的基础复习了一遍， 然后在慕课网上开始刷课，然后碰到一些小例子时都会编程练习。 从我的博客记录显示，java学习一直持续到5月初。 期间还折腾了一段时间python，正是这小段时间的python， 让我有机会接触到了\"麻小科技\"，这里非常感谢捷哥，算起来也是认识多年的朋友了， 后来也认识了涛哥，非常感谢涛哥在技术方面给了我很多的指导。 后来机缘巧合之下，一场面试让我不得不考虑暂停我的java计划， 这场面试就是富士康C次的一场面试，面试官庆哥也就是我未来的主管， 当时庆哥面试时问了我们三个很简单的问题一个css选择器，一个数据库的查询，还有一个是css的盒子模型。 我当时数据库的那个联合查询没答出来，一紧张内外边距的英文padding和margin也忘记怎么拼写了。 双方还问了一些了解性的问题面试就这样结束了。 很幸运过了一两天就收到了邮件。 ","date":"2020-01-16","objectID":"/years/2019/:1:0","tags":["总结","生活随笔"],"title":"2019年度总结","uri":"/years/2019/"},{"categories":["生活随笔"],"content":"下半年·深圳·富士康科技集团 php 然后时间一晃而过来到了下半年，我来到了陌生的深圳，来到了富士康。 来到深圳后一周，捷哥说一起吃个饭，晚上一起走走， 然后那天我就去找捷哥吃饭了，吃的是顺德公的猪肚包鸡，很好吃。 然后也见到了涛哥，感觉涛哥是一个很谦逊很和蔼的人。非常感谢捷哥和涛哥在我刚来深圳的热情款待。 安顿好后，也开始实习工作了，前面的我所说的\"忙\"呢其实指的是\"充实\"， 在庆哥带领下的学习工作让我每天都过很充实，每天都能感觉到自己一点点的进步，真的非常庆哥的悉心培养。 从html5到php，然后ajax交互，SQL等等，几乎是从零开始教学，效果完全比得上外面的培训机构。 那段时间每天上班测试，学习MES系统流程，然后下班后学习新的知识，每天都能感觉充实带来的愉悦感。 不仅只有学习还有测试，公司的测试比在学校的考试真实多了，公司是要你真的掌握，所以会有理论知识学习，还会有实际操作。 后来大概12月初又学习了，部门平台的模组开发，12月份汇报，自己整体评价很行，松了一口气。 12月底正式接手了项目，拿到的新项目是两支论坛模组。 由于手上不够的原因，我被安排做前端开发，本以为前端会很容易。一直以来大家也都这样认为。 可是自己实际开发后才知道前端也是很容易出bug的，并且有时候前端的bug往往让你不知所措。 一切还需继续努力！ 12月26日，zxm考研结束，来深圳找我玩，和她一起在深圳逛了逛，去了深圳湾。 本来她还想去动物园的，但是老是睡过头，所以就没去了哈哈哈哈。 虽然我知道zxm喜欢吃肯德基，以前在湘潭也常陪她去， 但这一次深圳之旅，我才发现她真的太爱吃了，搞的我的不敢给她吃太多。 又不忍心拒绝她吃，所以来深圳就吃了好几次肯德基和麦当劳。 来到20年初，部门聚餐吃海鲜，和大家部门内的同事也都熟了，大家都很好相处， 很庆幸所在部门大家都是很好的学习工作氛围，没有那种老练职场的尔虞我诈。 1月初的一个周末还很荣幸的受邀参加了麻小科技的年会，和捷哥涛哥一起爬南山，然后一起在粗茶淡饭吃饭， 认识了很多很优秀的朋友，有在华为的，有腾讯的，也有清华博士在读的等等， 听他们说了一些话都觉得很有道理。 下午还一起去打了棋牌室打了桌球和麻将。 感觉陕西麻将和长沙麻将有点像，但和我们那的麻将打法略有不同。（输了十块哈哈哈哈） ","date":"2020-01-16","objectID":"/years/2019/:2:0","tags":["总结","生活随笔"],"title":"2019年度总结","uri":"/years/2019/"},{"categories":["生活随笔"],"content":"总结 总的来说，19 年还算顺利，下半年的实习没向家里要钱，凭自己能力\"活着\"，只希望 20 年和 zxm 更好，顺利毕业，活的更好！ ","date":"2020-01-16","objectID":"/years/2019/:3:0","tags":["总结","生活随笔"],"title":"2019年度总结","uri":"/years/2019/"},{"categories":["SQL"],"content":" SQL增删改查(CRUD)语句与常用函数总结。 ","date":"2020-01-16","objectID":"/posts/sql/:0:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"SQL Introduction 一般我们对数据库的操作主要分为四种，增C(CREATE)、删D(DELETE)、改U(UPDATE)、查R(READ)，所以，我就从CRUD这四个方面来制作查询表。 开发规则: 尽量减少对数据库的访问次数，且不能查询无用的数据，浪费效能（例如：我只要男生的数据，你把所有人的数据都查询出来）。 属于SQL语法的要使用大写 （SELECT, WHERE, INSERT etc…）。 属于使用者自己定义的要使用小写（表名、列名 etc…）。 表名与列名前后使用 ` 包起来，防止与关键字冲突（例如： INSERT INTO `user` VALUES(‘a’,‘b’); ）。 禁止使用 Table Join。 禁止使用 Oracle Trigger。 禁止使用 SELECT * （为了加强代码可读性）。 不能将查询数据库的 SQL 放在循环中查询。 ","date":"2020-01-16","objectID":"/posts/sql/:1:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"新增（CREATE） 功能 语句 创建数据库 CREATE DATABASE \u003c数据库名\u003e; 创建数据表 CREATE TABLE \u003c表名\u003e (\u003c列名1\u003e \u003c数据类型\u003e \u003c约束条件\u003e,\u003c列名2\u003e \u003c数据类型\u003e \u003c约束条件\u003e,\u003c列名3\u003e \u003c数据类型\u003e \u003c约束条件\u003e,......\u003c该表的的约束条件1\u003e \u003c该表的的约束条件2\u003e...); 插入数据 INSERT INTO \u003c表名\u003e (列名1,列名2,...) VALUES (值1,值2,...);（每列都有数据插入时，可省略列名。但是为了代码的可读性，不建议如此操作。） 增加列 ALTER TABLE \u003c表名\u003e ADD \u003c列名\u003e \u003c数据类型\u003e \u003c约束条件\u003e AFTER \u003c前一列列名\u003e;（默认插入到最后一列） ","date":"2020-01-16","objectID":"/posts/sql/:2:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"删除（DELETE） 功能 语句 删除数据库 DROP DATABASE \u003c数据库名\u003e; 删除数据表 DROP TABLE \u003c表名\u003e; 清空表数据 DELETE FROM \u003c表名\u003e; 或者 TRUNCATE TABLE \u003c表名\u003e; 删除行数据 DELETE FROM \u003c表名\u003e WHERE \u003c条件\u003e; 删除列数据 ALTER TABLE \u003c表名\u003e DROP \u003c列名\u003e; ","date":"2020-01-16","objectID":"/posts/sql/:3:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"修改（UPDATE） 功能 语句 修改数据库名 RENAME DATABASE \u003c旧名称\u003e TO \u003c新名称\u003e; 修改表名 RENAME TABLE \u003c旧名称\u003e TO \u003c新名称\u003e; 修改数据 UPDATE \u003c表名\u003e SET \u003c列名1\u003e = \u003c新值1\u003e,\u003c列名2\u003e = \u003c新值2\u003e WHERE \u003c条件\u003e; 修改列名 ALTER TABLE \u003c表名\u003e CHANGE \u003c旧列名\u003e \u003c新列名\u003e \u003c数据类型\u003e \u003c约束条件\u003e; 注意：重命名数据库与数据表一般不推荐使用，若想测试，请先备份好自己的数据库~ ","date":"2020-01-16","objectID":"/posts/sql/:4:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"查询（ R E A D ） 功能 语句 查询所有数据库 SHOW DATABASES; 查询指定数据库中所有表名 USE \u003c数据库名\u003e; 然后 SHOW TABLES;或者 SHOW TABLES FROM \u003c数据库名\u003e; 查询表中所有列信息 SHOW COLUMNS FROM \u003c表名\u003e; 查询表中所有数据 SELECT \u003c列名1\u003e,\u003c列名2\u003e,\u003c列名3\u003e,... FROM \u003c表名\u003e; 查询表中某个数据 SELECT \u003c列名\u003e FROM \u003c表名\u003e; 查询表中指定多个数据 SELECT \u003c列名1\u003e,\u003c列名2\u003e,\u003c列名3\u003e,... FROM \u003c表名\u003e WHERE \u003c条件\u003e; 查询表中指定一个数据 SELECT \u003c列名\u003e FROM \u003c表名\u003e WHERE \u003c条件\u003e; 查询指定范围数据 SELECT \u003c列名1\u003e,\u003c列名2\u003e,\u003c列名3\u003e,... FROM \u003c表名\u003e WHERE \u003c某列名\u003e BETWEEN \u003c某列名范围值-小\u003e AND \u003c某列名范围值-大\u003e; 字符串模式匹配查询 SELECT \u003c列名\u003e FROM \u003c表名\u003e WHERE name LIKE 'Y%';（查询以Y开头的，更多匹配方式自行百度哦~。） 指定多个值数据查询 SELECT \u003c列名1\u003e,\u003c列名2\u003e,\u003c列名3\u003e,... FROM \u003c表名\u003e WHERE \u003c某列名\u003e IN ('\u003c某列名值1\u003e','\u003c某列名值2\u003e','\u003c某列名值3\u003e',...); 查询结果排序 SELECT \u003c列名1\u003e,\u003c列名2\u003e,\u003c列名3\u003e,... FROM \u003c表名\u003e ORDER BY \u003c某列名\u003e DESC;（此处为递减排列，默认为递增ASC） 查询指定几笔数据 SELECT \u003c列名1\u003e,\u003c列名2\u003e,\u003c列名3\u003e,... FROM \u003c表名\u003e LIMIT n,m;（从n到m笔数据） 分群查询 SELECT \u003c列名1\u003e,\u003c列名2\u003e,\u003c列名3\u003e,...,\u003c函数\u003e FROM \u003c表名\u003e GROUP BY \u003c列名1\u003e,\u003c列名2\u003e,\u003c列名3\u003e,...;（常搭配函数有：SUM()、AVG()、COUNT()、MAX()、MIN()） ","date":"2020-01-16","objectID":"/posts/sql/:5:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"常用函数 函数名 用途 ABS(数值) ABS函数（求绝对值） MOD(被除数,除数) MOD函数（求余） ROUND(对象数值,保留小数的位数) ROUND函数（四舍五入） 字符串1 ΙΙ 字符串2 ΙΙ 函数（拼接） LENGTH(字符串) LENGTH函数（求字符串长度） LOWER(字符串) LOWER函数（小写转换） UPPER(字符串) UPPER函数（大写转换） REPLACE(对象字符串,替换前的字符串,替换后的字符串) REPLACE函数（字符串的替换） SUBSTRING (对象字符串,截取的起始位置,截取的字符数) SUBSTRING函数（字符串的截取） CURRENT_DATE CURRENT_DATE函数（当前日期） CURRENT_TIME CURRENT_TIME函数（当前时间） CURRENT_TIMESTAMP CURRENT_TIMESTAMP函数（当前日期和时间） EXTRACT(日期元素 FROM 日期) EXTRACT函数（截取日期元素） CAST(转换前的值 AS 想要转换的数据类型) CAST函数（类型转换） COALESCE(数据1,数据2,数据3….) COALESCE函数（将NULL转换为其他值） 补充：CASE表达式。 CASE WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e ...... ELSE \u003c表达式\u003e END ","date":"2020-01-16","objectID":"/posts/sql/:6:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"其他知识 ","date":"2020-01-16","objectID":"/posts/sql/:7:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"常见数据类型 ","date":"2020-01-16","objectID":"/posts/sql/:7:1","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"别名 给表设置别名，让SQL更简洁。例如： SELECT \u003ccol-1\u003e,\u003ccol-2\u003e,\u003ccol-3\u003e,... FROM \u003ctable1\u003e \u003calias-a\u003e,\u003ctable2\u003e \u003calias-b\u003e WHERE \u003calias-a\u003e.\u003cid\u003e = \u003calias-b\u003e.\u003cid\u003e; 列名也可以设置别名。例如： SELECT \u003ccol-1\u003e \u003calias-a\u003e,\u003ccol-2\u003e \u003calias-b\u003e,\u003ccol-3\u003e \u003calias-c\u003e,... FROM \u003ctable\u003e; 或者 SELECT \u003ccol-1\u003e AS \u003calias-a\u003e,\u003ccol-2\u003e AS \u003calias-b\u003e,\u003ccol-3\u003e AS \u003calias-c\u003e,... FROM \u003ctable\u003e; ","date":"2020-01-16","objectID":"/posts/sql/:7:2","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["SQL"],"content":"总结 以上整理的内容均为基础内容，更多进阶知识还需各位自行 Google。 ","date":"2020-01-16","objectID":"/posts/sql/:8:0","tags":["SQL","Backend"],"title":"SQL总结","uri":"/posts/sql/"},{"categories":["Fullstack"],"content":" RESTful 是一種系統開發設計風格、原則。可視情況調整，以下參考來源 RFC5789 https://tools.ietf.org/html/rfc5789 ","date":"2019-11-14","objectID":"/posts/restful/:0:0","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"Noun 一般資源 通用於一律使用複數名詞 例如：/books 或 /books/123。但有部分人認為應該使用單數名詞，因為： /book/123 看似比 /books/123 合理。但想想檔案系統的目錄命名 (例如/Users或/Documents)，其實用複數也沒問題。複數可以保持API endpoint的一致性，所以一般資源建議用複數。 唯一資源：對 client 而言只有一份的資源 通用於單數名詞 例如：user 是指目前驗證的使用者，使用者永遠只能同時登入一個使用者 ","date":"2019-11-14","objectID":"/posts/restful/:1:0","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"Http Method MethodIdempotentSafeCRUDOO生活動詞用途GETYYReadgetget取得資料list列出資料POSTCreateaddcreate建立一個可以完全獨立存在的實體add增加一個必須依賴於某個實體的實體PUTYUpdatesetreplace取代一個關係，已存在時先刪除後建立，不存在時直接建立add附加唯一關係，兩個關係實體可以互相獨立存在，且已經存在PATCHedit編輯某個實體DELETEDeleteremoveremove delete刪除某個實體 Safe：該操作不會改變伺服器端的資源狀態 (而且結果可以被cache)，屬於 Safe 的操作必定屬於 Idempotent Idempotent (冪等性)：該操作不管做1遍或做n遍，都會得到同樣的資源狀態結果 (但不一定得到同樣的回傳值，例如第2次DELETE請求可能回傳404)，因此client端可以放心retry。 ","date":"2019-11-14","objectID":"/posts/restful/:2:0","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"GET SAFE：每次執行操作時，GET 只有讀取 Resource，不會改變到任何的 Resource (資源, 資料) Idempotent：每次執行操作時，GET 只有讀取 Resource，不會改變到任何的 Resource (資源, 資料)，所以任何資源的任何狀態都是一樣的 ","date":"2019-11-14","objectID":"/posts/restful/:2:1","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"POST 每次執行操作時，POST 都會建立一個 Resource (資源, 資料) 範例：建立使用者 執行第一次時：建立一個 name = “帥小慶” 的 user，但其 id = 1執行第二次時：建立一個 name = “帥小慶” 的 user，但其 id = 2，發送同樣的請求，可每次都是不同的 Resource POST /users Data: { \"name\": \"帥小慶\" } Create：建立一個可以完全獨立存在的實體 範例：建立使用者 建立使用者前不需要建立任何的東西，就可以建立使用者了，使用者是可以完全獨立的存在 POST /users Data: { \"name\": \"帥小慶\" } Add：增加一個必須依賴於某個實體的實體 資料結構：1對多的關係 範例：Add a public key on behalf of a user 增加一個代表使用者的公鑰 (Gitea API) 增加這個公鑰之前，使用者必須存在，公鑰必須歸屬於某個使用者之下公鑰跟姓名一樣，使用相同電腦的公鑰就會相同，但不表示是同一個使用者，故公鑰也會有自己的 ID我每次增加公鑰時，都將生成不同的公鑰 ID POST ​/admin​/users​/{username}​/keys ","date":"2019-11-14","objectID":"/posts/restful/:2:2","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"PUT Idempotent：每次執行操作時，PUT 都會取代 Resource，不管操作幾次，使用者獲取得 Resource 結果都是一樣的 Replace：不論資源如何，最終的資源狀態都是一樣的 Resource 已存在時，或許不理會、或許先刪除後建立 (取代)Resource 不存在時，直接建立 Add：添加唯一關係，建立這個唯一關係前，兩個關連實體都必須存在。在沒有建立關係前，兩個關連實體都可以互相獨立存在 資料結構應為：多對多，且兩個關連實體的 PK，同時也是關係實體的 PK、FK 範例：增加使用者與角色的關係 增加使用者跟角色的關係前，使用者跟角色都必須存在；增加使用者跟角色的關係前，使用者跟角色可以獨立存在使用者 23240，跟角色 2，的關係最多只能有一條關係 (使用者 23240 有角色 2 )，最少沒有關係 (使用者 23240 沒有角色 2 )執行第二次操作時，使用者 23240 跟角色 2 的從屬關係仍然存在，也不會跑出第二條使用者 23240 跟角色 2 的從屬關係 PUT user/{account}/roles Data { \"role_id\": \"2\" } 範例：Follow a user 關注一個使用者 (Gitea) 增加關注關係時，關注者與被關注者 (都是使用者) 都必須存在；增加關注關係時，關注者與被關注者 (都是使用者) 都必須存在關注者使用者 23240，跟被關注者使用者 F3860056，的關係最多只能有一條關係 (23240 關注 F3860056)，最少沒有關係 (23240 不關注 F3860056)執行第二次操作時，關注者 23240 跟被關注者 F3860056 的關注關係仍然存在，也不會跑出第二條關注者 23240 跟被關注者 F3860056 的關注關係 PUT ​/user​/following​/{username} ","date":"2019-11-14","objectID":"/posts/restful/:2:3","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"PATCH Edit：編輯可獨立存在、且已經存在的實體，也就是產生新版本的實體，可能會影響其他 Resource 範例：編輯使用者 編輯使用者，使用者已經存在，且我們可能有紀錄編輯時間、編輯人、編輯IP，所以每次的編輯都會造成不一樣的結果 第一次編輯使用者，更新時間變為 08:00，編輯人 23240，IP 10.151.110.165第二次編輯使用者，更新時間變為 09:00，編輯人 23241，IP 10.151.110.144 PATCH /users/{account} ","date":"2019-11-14","objectID":"/posts/restful/:2:4","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"DELETE Idempotent：每次執行操作時，DELETE 都會刪除相同的東西 範例：刪除使用者 第一次刪除使用者23240，刪除使用者23240第二次刪除使用者23240，還是刪除使用者23240，只不過使用者 23240 不存在了。 DELETE /users/{account} ","date":"2019-11-14","objectID":"/posts/restful/:2:5","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"HTTP Status Code HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。所有状态码的第一个数字代表了响应的五种状态之一。 除非另有说明，状态码是HTTP / 1.1标准（RFC 7231）的一部分。 而关于 RESTful API 的请求状态，通常有以下两种设计方案： 方案一：使用 HTTP 状态码来表示请求状态，200 时返回的内容就是数据； 方案二：所有接口都返回 200 ，在响应内容里约定 错误码 或 錯誤信息； 在實際應用中，應據具體情景及需要進行選擇與調整。 方案優劣比較方案一優點對服務端來說較為簡單方便缺點客戶端難以根據狀態碼處理複雜問題方案二優點方便對返回資料進行統一處理和細細微性的控制缺點相當於放棄了HTTP狀態碼的語義 ","date":"2019-11-14","objectID":"/posts/restful/:3:0","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["Fullstack"],"content":"常用HTTP狀態碼 CodeMessage用途1XXInformational response此類狀態碼通常代表的響應都是信息性的，告訴客戶端可以進行下一步操作。100Continue表示服務端已接收到請求頭，客戶端可以繼續發送請求體(如POST請求)。101Switching Protocols表示服務端支持更優協議，讓客戶端在服務端更換協議後重新訪問。2XXSuccessful此類狀態碼通常代表請求已成功被服務端接收、理解并接受。200OK表示請求成功。201Created表示請求已被實現，通常是在成功創建了某個資源。202Accepted表示請求已被服務端接收，但尚未進行處理。204No Content表示請求成功，但不會返回任何內容。205Reset Content表示請求成功，但不會返回任何內容，並且要求客戶端重置表單。3XXRedirect此類狀態碼通常代表本次請求需要客戶端採取進一步操作才能完成。通常用於重定向。300Multiple Choices表示請求的資源有多個供可選擇，客戶端可自行選擇一個進行請求的重定向。301Moved Permanently表示請求的資源已經永久地移動到了新位置，並且將在Location域中攜帶該資源新的URI。304Not Modified表示請求的資源無發生修改，將不會返回任何資源。4XXClient Error此類狀態碼通常代表客戶端可能出現了錯誤。400Bad Request表示客戶端發出的請求有誤(格式、大小、無效的...)，服務端不能/不會處理該請求。401Unauthorized表示客戶端未能提供必要的驗證，服務端拒絕提供資源。403Forbidden表示服務端理解了該請求，但客戶端沒有足夠權限以訪問，遂拒絕提供該資源。404Not Found表示服務端無法找到請求的資源，其可能已經暫時(永久)失效。408Request Timeout表示請求超時。409Conflict表示請求的資源發送了衝突，通常是PUT請求。410Gone表示請求的資源已經永久失效，客戶端不應再次請求。411Length Required表示服務端拒絕在沒有定義Content-Length頭的情況下接收該請求。5XXServer Error此類狀態碼通常代表由於服務端的原因，導致無法完成請求。500Internal Server Error表示由於服務端遇到意料之外的變故，導致無法完成請求。501Not Implemented表示服務端不支持完成請求所需的功能，導致無法完成請求。502Bad Gateway表示作為網関或代理的服務段在執行請求時，從上游服務器獲得了無效的響應。503Service Unavailable表示由於某些原因(服務器超載或系統維護等)，導致暫時無法完成請求。504Gatewy Timeout表示作為網関或代理的服務段在執行請求時，未能及時從上游服務器獲得響應。505HTTP Version Not Supported表示服務端不支持請求的HTTP協議版本，導致無法完成請求。 以上內容參考自https://zh.wikipedia.org/zh-tw/HTTP%E7%8A%B6%E6%80%81%E7%A0%81， 需要查看完整HTTP狀態碼請點擊https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html ","date":"2019-11-14","objectID":"/posts/restful/:3:1","tags":["REST"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["PHP"],"content":" php 主动推送站点链接到百度站长，神马站长进行 SEO。 代码 把需要提交的链接和各站长 api 分别放在两个 txt 文件里面, 然后运行 php 文件进行提交，不同站长提交成功一般返回的都是 200 状态码。 \u003c?php //链接存放路径和站长api文件存放路径 $urls_path = \"H:\\\\lruihao.cn\\\\public\\\\baidu_urls.txt\"; $apis_path = \"G:\\\\Demo\\\\lrh01\\\\zhanzhang_api.txt\"; //将文件每一行读到一个数组里面去 $urls = file($urls_path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); $apis = file($apis_path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); for($x=0;$x\u003ccount($apis);$x++){ $ch = curl_init(); $options = array( CURLOPT_URL =\u003e $apis[$x], CURLOPT_POST =\u003e true, CURLOPT_RETURNTRANSFER =\u003e true, CURLOPT_POSTFIELDS =\u003e implode(\"\\n\", $urls), CURLOPT_HTTPHEADER =\u003e array('Content-Type: text/plain'), ); curl_setopt_array($ch, $options); $result = curl_exec($ch); echo \"API: \u003cbr/\u003e\u0026emsp;\".$apis[$x].\"\u003cbr/\u003e\"; echo \"result: \u003cbr/\u003e\u0026emsp;\".$result.\"\u003chr/\u003e\"; } ?\u003e 提交结果 ","date":"2019-09-28","objectID":"/posts/phppushurl/:0:0","tags":["Backend","PHP"],"title":"php同时主动推送链接到百度，神马等站长平台","uri":"/posts/phppushurl/"},{"categories":["PHP"],"content":"普通方法 首先采用fopen()函数打开文件，得到返回值的就是资源类型。接着采用while循环一行行地读取文件，然后输出每行的文字。feof()判断是否到最后一行,fgets()读取一行文本。 \u003c?php //首先采用“fopen”函数打开文件，得到返回值的就是资源类型。 $file_handle = fopen(\"C:\\\\Users\\\\李瑞豪\\\\Desktop\\\\备忘录.txt\",\"r\"); if ($file_handle){ //接着采用while循环一行行地读取文件，然后输出每行的文字 while (!feof($file_handle)) { //判断是否到最后一行 $line = fgets($file_handle); //读取一行文本 echo $line; //输出一行文本 echo \"\u003cbr /\u003e\"; //换行 } } fclose($file_handle);//关闭文件 ?\u003e readfile（）函数，返回一整个String echo readfile(\"C:\\\\Users\\\\李瑞豪\\\\Desktop\\\\备忘录.txt\"); 快速方法 file()函数把整个文件读入一个数组中。 数组中的每个元素都是文件中相应的一行，包括换行符在内。 语法 file(path,include_path,context) 参数 描述 path 必需。规定要读取的文件。 include_path 可选参数include_path 可以是以下一个或多个常量：**FILE_USE_INCLUDE_PATH在 include_path 中查找文件。FILE_IGNORE_NEW_LINES在数组每个元素的末尾不要添加换行符FILE_SKIP_EMPTY_LINES**跳过空行 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。 \u003c?php $filepath=\"H:\\\\lruihao.cn\\\\public\\\\baidu_urls.txt\"; echo \"\u003chr/\u003e\"; //将文件每一行读到一个数组里面去 $texts = file($filepath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); var_dump($texts); ?\u003e 结果 ","date":"2019-09-28","objectID":"/posts/phpfile/:0:0","tags":["PHP","Backend"],"title":"php按行读取文件信息","uri":"/posts/phpfile/"},{"categories":["JavaScript"],"content":" 使用javascript计算博客等网站的运行时间。 话不多说，直接贴码！ function createTime() { var now = new Date(); var run = new Date(\"05/28/2018 20:01:01\"); //總的秒數 var runTime = (now - run) / 1000, days = Math.floor(runTime / 60 / 60 / 24), hours = Math.floor(runTime / 60 / 60 - (24 * days)), minutes = Math.floor(runTime / 60 - (24 * 60 * days) - (60 * hours)), seconds = Math.floor((now - run) / 1000 - (24 * 60 * 60 * days) - (60 * 60 * hours) - (60 * minutes)); //前置零 if (String(hours).length === 1) { hours = \"0\" + hours; } if (String(minutes).length === 1) { minutes = \"0\" + minutes; } if (String(seconds).length === 1) { seconds = \"0\" + seconds; } /*document.querySelector(\".run-times\").innerHTML = days + \"\u0026thinsp;天\u0026thinsp;\" + hours + \"\u0026thinsp;时\u0026thinsp;\" + minutes + \"\u0026thinsp;分\u0026thinsp;\" + seconds + \"\u0026thinsp;秒\"; */ document.querySelector(\".run-times\").innerHTML = \"RunTime: \" + days + \",\" + hours + \":\" + minutes + \":\" + seconds + \"\"; } //setInterval(\"createTime()\", 500); if (!document.hidden) { var siteTime = setInterval(\"createTime()\", 500); } else { clearInterval(siteTime); } /** * HTML写法 \u003cspan class=\"run-times\" title=\"网站运行时间\"\u003e载入时分秒...\u003c/span\u003e \u003cp class=\"run-times\" title=\"主頁运行时间\"\u003eRunTime Loading...\u003c/p\u003e */ ","date":"2019-09-19","objectID":"/posts/site-time/:0:0","tags":["JavaScript","Frontend"],"title":"设置网站运行时间","uri":"/posts/site-time/"},{"categories":["JavaScript"],"content":"注意 JS的加载分为两个部分：下载和执行。 浏览器在执行HTML的时候如果遇到\u003cscript\u003e时会停止页面的渲染,去下载和执行js的文件直接遇见\u003c/scirpt\u003e会继续渲染页面。故浏览器在执行js文件的时候浏览器表现为一片空白,为了解决这个问题ECMAScript定义了defer和async两个属性用于控制JS的下载和执行。 不带任何属性 同步模式，又称阻塞模式，我们平时使用的最多的一种方式。当浏览器解析到\u003cscript\u003e标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，是个同步阻塞的过程。 一般建议把\u003cscript\u003e标签放在\u003cbody\u003e结尾处，这样尽可能减少页面阻塞。 而如果想要异步执行script，则可以给其加上async或defer属性。 \u003cscript\u003e defer defer属性在HTML解析期间异步下载文件，并且只在HTML解析完成后才执行它。对于defer，我们可以理解是将外链的js放在了页面底部。js的加载不会阻塞页面的渲染和资源的加载。不过defer会按照原本的js的顺序执行，所以如果前后有依赖关系的js可以放心使用。 \u003cscript defer\u003e async async属性会在HTML解析期间异步下载文件，并在完成下载后立即暂停HTML解析器去执行script中的代码。在执行过程中浏览器处于阻塞状态，响应不了任何需求。如果js前后有依赖性，用async，就很有可能出错。 \u003cscript async\u003e 区别 ","date":"2019-09-08","objectID":"/posts/async-defer/:0:0","tags":["JavaScript","defer","async","Frontend"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"相同点 加载文件时不阻塞页面渲染 对于inline的script无效（只适用有src的外部js） 使用这两个属性的脚本中不能调用document.write方法 有脚本的onload的事件回调 ","date":"2019-09-08","objectID":"/posts/async-defer/:1:0","tags":["JavaScript","defer","async","Frontend"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["JavaScript"],"content":"区别点 html4.0中定义了defer；html5.0中定义了async 浏览器支持不同 每一个async属性的脚本都在它下载结束之后立刻执行，同时会在window的load事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行。 那么这三种方式各在什么情况下使用呢？ 通常来说，尽可能使用async，然后是defer，最后不使用属性。 并遵循以下规则： 如果脚本是模块化的，并且不依赖于任何脚本，则使用async。 如果脚本依赖于或依赖于另一个脚本，则使用defer。 如果脚本很小并且有async脚本依赖该脚本，则不加属性。 兼容性 Internet Explorer 10、Firefox、Opera、Chrome 和 Safari 支持 async 属性。 所有主流浏览器都支持defer属性。 参考 https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html https://www.jianshu.com/p/17dc82bf08f1 ","date":"2019-09-08","objectID":"/posts/async-defer/:2:0","tags":["JavaScript","defer","async","Frontend"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["Fullstack"],"content":" 转自--入冬 补充tab转space设置 tab转space 打开Settings,加入几行配置 { \"color_scheme\": \"Packages/Color Scheme - Default/Monokai.sublime-color-scheme\", \"font_size\": 14, \"ignored_packages\": [ \"Vintage\" ], \"theme\": \"Adaptive.sublime-theme\", + \"expand_tabs_on_save\": true, + \"tab_size\": 2, + \"translate_tabs_to_spaces\": true } 选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 ","date":"2019-08-15","objectID":"/posts/sublime-text3/:0:0","tags":["Sublime","总结","他山之石"],"title":"Sublime Text3 快捷键大全","uri":"/posts/sublime-text3/"},{"categories":["Fullstack"],"content":"安裝 官方下載點 擴充功能 ","date":"2019-08-15","objectID":"/posts/netbeans/:0:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"安裝擴充功能 下載擴充套件包 官方套件庫 或者在netbenas IDE裏面下載插件（方便） 開啟 Netbeans→Tools→Plugins→Downloaded→Add Plugins 選擇要安裝的擴充套件包 ","date":"2019-08-15","objectID":"/posts/netbeans/:1:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"啟用已安裝的擴充功能 開啟 Netbeans→Tools→Plugins→Installed 選擇要啟用的套件 (*.npm) 點擊 Activate ","date":"2019-08-15","objectID":"/posts/netbeans/:2:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"匯入設定 開啟 Netbeans→Tools→Options 點擊 Import 匯入設定 選擇要匯入的套件包 (*.zip) 常用設定 ","date":"2019-08-15","objectID":"/posts/netbeans/:3:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"程式碼排版 在程式開發中，程式碼排版很重要。一個好的排版利於開發人員程式閱讀，也便於後期維護人員閱讀。 在NetBeans中設置程式碼排版 打開NetBeans-\u003eTools-\u003eOptions-\u003eEditor-\u003eFormatting； Language選擇 All Languages，勾選\"Expand Tabs to Spaces\",用兩個空格鍵代替Tab鍵，首行留兩個Tab鍵。 點擊Apply或Ok完成設置。具體設置及效果如下圖所示： ","date":"2019-08-15","objectID":"/posts/netbeans/:4:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"程式碼樣板 　程式碼樣板可以幫助你快速書寫程序，不必繁瑣地聲明函數或其他代碼塊，更專注與邏輯的書寫。 在NetBeans中設置程式碼樣板 打開NetBeans→Tools→Options→Editor→Code Templates； 選擇你所用的語言（這裡以JavaScript為例）； 點擊\"New\"新建屬於你的或修改原有的程式碼樣板（例子僅為演示）； 在編程中應用它。 ","date":"2019-08-15","objectID":"/posts/netbeans/:5:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"前端壓縮 下載擴充套件netbeans minify 或者 minifierBeans 開啟 Netbeans→Tools→Plugins→Downloaded→Add Plugins 選擇你下載的擴充套件開啟 開啟Netbeans→Tools→options ","date":"2019-08-15","objectID":"/posts/netbeans/:6:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"快捷鍵 键位 作用 Ctrl+/ 注释一行（或选中部分） Ctrl+X 剪切一行（或选中部分） Ctrl+E 删除一行（或选中部分） Shift+Alt+上下方向键 移动当前行 Ctrl+Shift+上下方向键 复制当前行(该操作并非复制到粘贴板) Shift+Alt+F 整理代码 TAB 代碼自動補全/缩进/選中文字同時缩进 Shift+TAB 選中文字同時取消缩进 Ctrl+F 查找某个字 Ctrl+Shift+F 整个项目中查找某个字 Ctrl+H 替换某个字 Ctrl+Enter 增加空白行，光标不动。 Ctrl+(0~7) 打开各种小窗口 Shift+方向键 選中文字 Ctrl+Alt+Space 代码输入提示,不习惯的可以设置为(Alt+/)，超级好用！！！ Ctrl+Shift+F5 调试当前程序 Shift+F6 运行当前程序 F6 运行主程序 Alt+Enter 显示程式bug建议或者警示等 NetBeans中常用的快捷鍵↑： 三種複製行方法 复制一行: Ctrl + Shift + 上下方向键(该操作并非复制到粘贴板)； 复制一行: 在该行任何地方连续三击选中一样,然后Ctrl + C即可复制一行.； 复制一行(使用宏): 编辑-开始录制宏(Home,Shift + End,Ctrl + C)-停止录制宏-设置宏名称(如select-entire-line)-设置快捷键(如Ctrl + Alt + C)； 也可自己修改快捷鍵(Tools→Options→Keympa),如下圖 {% asset_img quickkey.png quickkey %} ","date":"2019-08-15","objectID":"/posts/netbeans/:7:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"遠程開發 (FTP) 工作为例 新建项目 打开软件，进入新建项目页面（File-New Project），新建php项目，选择第一个（PHP-PHP Application） 项目名和地址自己选择（注意，选择地址后需在地址最后面加上\"/项目名\"） FTP设置 点击下一步，进入FTP设置，Run As选择Remote Web Site(FTP,SFTP) Project URL填写http://127.0.0.1/training/工号 Manage设置 点击Manage,进入页面.名字自取.Host Name填写：127.0.0.1 Encryption选择Pure FTP,User Name和Password（填写工号/课务系统登录密码） Initial Directory填写_training 点击Test Connection测试是否连接成功 其他设置 Upload Directory,上传目录不填，直接上传至个人根目录 Upload File改为保存时上传文件（On Save） ","date":"2019-08-15","objectID":"/posts/netbeans/:8:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"Chrome with NetNeans Connector 打開chrome中的應用程式商店（使用chrome瀏覽器點擊下方鏈接即可） chrome應用程式商店 在搜索框中輸入NetNeans Connector后搜索，然後點擊右邊的加到Chrome即可，安裝成功后右上角會顯示Netbeans圖標。 開啟netbeans 選擇Run→Set Project Browser→選中Chrome with NetBeans Connector 選擇default下的Customize → 選擇Browser → 選擇Browser下 Chrome with NetBeans Connector即可 ","date":"2019-08-15","objectID":"/posts/netbeans/:9:0","tags":["netBeans","PHP"],"title":"netBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Fullstack"],"content":"精神 絕對不寫死程式 不留不要用的、垃圾程式碼 Git Master 的 BUG 必須最少且趨近於零，为最稳定的版本 每次 Commit 訊息應該確實填寫。不可模稜兩可，eg: 修复BUG、增加功能 禁止 Commit IDE 的 project data 禁止上傳垃圾程式碼 Gitea編輯內容類似里程碑和版本描述時要使用Markdown格式 ","date":"2019-08-15","objectID":"/posts/dev-rules/:0:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"分支（Branch） 命名規則：應以此分支主要目的命名（修復什麼BUG，新增特定功能） 不可出現版本號，模組ID 合併後的分支應刪除 ","date":"2019-08-15","objectID":"/posts/dev-rules/:1:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"commit 遵循一個功能一個commit的原則 Restful 資源名詞站在API的角度思考 複數名詞：可以複數筆資料，回傳結果為Array 舉例：GET/users 取得多筆使用者資料 刪除，放在複數名詞內，讓Router保持一致性 增加，放在複數名詞內，讓Router保持一致性 單數名詞：僅取得單筆資料，必須指定PK，兩兩一組，回傳結果為Object 舉例：GET/user/{accont} 取得單筆使用者資料，必須指定PK URL中一律不帶id參數 正確範例： calendar_manager/calendar/29 錯誤範例： calendar_manager/calendar/29?id=29 命名 命名應根據內容做有意義的命名，讓後續維護人員可以顧名思義! 即使不會發生錯誤，程式碼英文大小寫也需明確區分。 ","date":"2019-08-15","objectID":"/posts/dev-rules/:2:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"語意 類型 命名規則 說明 屬性 (Attribute, Property) 名詞user_name、userName 方法 (Method, Function) 動詞+名詞getUserName、get_user_name 常見的動詞有：get、set、update、delete、remove ","date":"2019-08-15","objectID":"/posts/dev-rules/:3:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"字母與分隔 語言變數 (Variable, Parameter, Argument)常數 (Constant)物件導向 - 類名 (Class Name)物件導向 - 成員 (mebmer)HTML、CSS全部小寫，不同單字以「-」分隔 user-idJavaScript駝峰式命名法首字小寫，不同單字「首字以大寫」分隔 userId全部大寫，不同單字以「_」分隔 MAX_COUNT駝峰式命名法首字大寫，不同單字「首字以大寫」分隔 一個檔案放一個 Class 檔名即為 Class Name User駝峰式命名法公有 (public) : 首字小寫，不同單字「首字以大寫」分隔 name, getName 私有 (private): _公有命名規則 _name, _getNamePHP全部小寫，不同單字以「_」分隔 user_idSQL由使用者定義的：表名、欄位名 全部小寫，不同單字以「_」分隔SQL語法、函數 全部大寫 SELECT、INSERT INTO- 通用 程式碼撰寫 每個函數應該註解，註解應包含函數工能說明、引數說明。 不必要的代碼不要寫，也禁止放到註解裡面! if-else 的 {} 嚴禁省略。 {} 起始一律跟在 前一個功能的尾巴，禁止分行 ","date":"2019-08-15","objectID":"/posts/dev-rules/:4:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"正確寫法 public function test(){ //do something if($a === $b){ //do something } } ","date":"2019-08-15","objectID":"/posts/dev-rules/:5:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"錯誤寫法 public function test() { //do something if($a === $b) { //do something } } 程式碼排版 任何程式碼應該以 2 個 space 為一個階層做好排版、不可使用 tab。 函數 (Function, Methd) 函數宣告時需在函數上方加上函數註解，註解應包含函數說明、引數內容 (引數型態、引數英文名稱、引數說明)、 回傳值內容 (回傳值型態、回傳值說明) 類 (Class) 一個類 (Class) 的宣告只能存在一個檔案。 類 (Class) 的宣告檔，檔名必須為類名。 其他 連結本地任何其他資源 (圖片、檔案、網站) 皆使用相對路徑，禁止使用絕對路徑，非本地資源除外。 HTML ","date":"2019-08-15","objectID":"/posts/dev-rules/:6:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"程式碼撰寫 禁止在 HTML 使用 \u003cstyle\u003e、\u003cscript\u003e，一律使用外部檔案引用方式引用 CSS、JavaScript檔案。 HTML 標籤需成雙成對，有頭有尾。 區塊標籤：\u003ctag\u003e\u003c/tag\u003e 單標籤：\u003ctag /\u003e 禁止使用已被 HTML 捨棄的舊標籤、屬性，如： \u003c!-- html tag --\u003e \u003ccenter\u003e \u003cfont\u003e \u003cbasefont\u003e \u003cs\u003e \u003cstrike\u003e \u003cu\u003e \u003clisting\u003e \u003cplaintext\u003e \u003cxmp\u003e \u003c!-- html attribute --\u003e align bgcolor color ","date":"2019-08-15","objectID":"/posts/dev-rules/:7:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"資安禁止： 禁止使用 readonly 做為參數傳遞 ","date":"2019-08-15","objectID":"/posts/dev-rules/:8:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"其他 連結本地任何其他資源 (圖片、檔案、網站) 皆使用相對路徑，禁止使用絕對路徑，非本地資源除外。 CSS ","date":"2019-08-15","objectID":"/posts/dev-rules/:9:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"程式碼撰寫 CSS 的定義應該獨立一個 CSS 檔案，禁止使用 \u003cstyle\u003e 或 style 屬性直接在 HTML 中定義樣式。 JavaScript ","date":"2019-08-15","objectID":"/posts/dev-rules/:10:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"程式碼撰寫 禁止使用 HTML 字串，一律使用 Dom 產生 HTML 禁止省略箭頭函數 (Arrow function) 的括弧 正確 a = (a, b) =\u003e { c; } 錯誤 (這是允許的，但造成程式碼閱讀困難，故禁止) a =\u003e c; ","date":"2019-08-15","objectID":"/posts/dev-rules/:11:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"註解 JavaScript 註解應該遵循 JSDoc 的標準撰寫 ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"全域變數 (Global) /* global $t, Tiger */ ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:1","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"常數 (Constant) /** * 常數說明 * @type {常數型態} */ Example /** * 使用者ID * @type {String} */ var userId = 'Hello'; ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:2","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"函數、方法 (Function, Method) /** * 函數用途說明 * @param {引數型態} 引數名稱 引數說明 * @param {引數型態} [選擇性引數名稱] 引數說明 * @param {引數型態} [選擇性引數名稱=引數預設值] 引數說明 * @returns {回傳值型態} 回傳值說明 */ Example /** * 取得使用者 * @param {Int} userId 使用者ID * @param {Object} [options] 其他選項 * @param {String} [options.query='a'] 查詢關鍵字 預設為 a * @returns {Object} 使用者資料 */ var getUser = function(userId, options){ //do something return user; }; PHP ","date":"2019-08-15","objectID":"/posts/dev-rules/:12:3","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"前端參數取得 參數取得需透過 filter_input 函數取得，不得使用 $_GET、 $_POST ","date":"2019-08-15","objectID":"/posts/dev-rules/:13:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"輸出到前台 參數命名必須為：全部小寫，不同單字以「_」分隔 ","date":"2019-08-15","objectID":"/posts/dev-rules/:14:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"註解 PHP 註解應該遵循 PHPDoc 的標準撰寫 ","date":"2019-08-15","objectID":"/posts/dev-rules/:15:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"成員變數 (Member) 成員變數只的是 Class 內的成員變數，我們都會要求替成員變數增加註解說明。通常 Function 的變數除非太特別否則都不需要特別註解說明。 /** * 成員變數說明 * @type {型態} */ Example /** * 使用者ID * @type {String} */ $userId = 'Hello'; ","date":"2019-08-15","objectID":"/posts/dev-rules/:16:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"函數、方法 (Function, Method) /** * 函數用途說明 * @param 引數型態 引數名稱 引數說明 * @option 引數選項型態 引數選項名稱 引數選項說明 * @uses 全域變數 全域變數說明 * @returns 回傳值型態 回傳值說明 */ Example /** * 取得使用者 * @param int userId 使用者ID * @param object options 其他選項 * @option string options['query'] 查詢關鍵字 * @uses $_POST['role_id'] 從前端以POST取得角色ID * @returns object 使用者資料 */ function getUser($userId, $options){ //do something return $user; }; Database 禁止使用 Table Join。 禁止使用 Oracle Trigger。 禁止將查詢資料庫的 SQL 放在迴圈中查詢 ","date":"2019-08-15","objectID":"/posts/dev-rules/:17:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["Fullstack"],"content":"SQL 撰寫 屬於 SQL 語法使用大寫 (SELECT, WHERE, INSERT etc..) 屬於使用者自己定義的使用小寫 (表名 table name, 欄位名 column name etc..) 表名、欄位名前後需加上 ` Example INSERTINTO`user`VALUES('a','b'); 統一用詞 僅為舉例，不限與此。 用詞 統一 最后 最後 關閉 取消 存儲保存修改 儲存 搜尋 查詢 ","date":"2019-08-15","objectID":"/posts/dev-rules/:18:0","tags":["PHP","JavaScript","Git","总结","Fullstack"],"title":"web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["PHP"],"content":" 简单模仿了一个评论模板，当然肯定是没有博客的valine这么强大的hhhh， PHP表单安全性的重要提示 $_SERVER[\"PHP_SELF\"]变量能够被黑客利用！ 如果页面中使用了PHP_SELF，用户能够输入下划线然后执行跨站点脚本（XSS）。 比如说注入js脚本等，valine以前的版本也有过这样的漏洞。 跨站点脚本（Cross-site scripting，XSS）是一种计算机安全漏洞类型，常见于 Web 应用程序。XSS 能够使攻击者向其他用户浏览的网页中输入客户端脚本。 可以像valine一样在用户输入完后保留输入，还有一些正则控制输入提示等简单功能。UI就丑爆了算了。。。 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cstyle\u003e .error {color: #FF0000;} .main{ width: 20%; height: 100%; border: 1px #000 solid; padding: 20px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c?php // 定义变量并设置为空值 $nameErr = $emailErr = $genderErr = $websiteErr = \"\"; $name = $email = $gender = $comment = $website = \"\"; if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { if (empty($_POST[\"name\"])) { $nameErr = \"Name is required\"; } else { $name = test_input($_POST[\"name\"]); // 检查名字是否包含字母和空格 if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) { $nameErr = \"Only letters and white space allowed\"; } } if (empty($_POST[\"email\"])) { $emailErr = \"Email is required\"; } else { $email = test_input($_POST[\"email\"]); // 检查电邮地址语法是否有效 if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) { $emailErr = \"Invalid email format\"; } } if (empty($_POST[\"website\"])) { $website = \"\"; } else { $website = test_input($_POST[\"website\"]); // 检查 URL 地址语言是否有效（此正则表达式同样允许 URL 中的下划线） if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+\u0026@#\\/%?=~_|!:,.;]*[-a-z0-9+\u0026@#\\/% =~_|]/i\",$website)) { $websiteErr = \"Invalid URL\"; } } if (empty($_POST[\"comment\"])) { $comment = \"\"; } else { $comment = test_input($_POST[\"comment\"]); } if (empty($_POST[\"gender\"])) { $genderErr = \"Gender is required\"; } else { $gender = test_input($_POST[\"gender\"]); } } function test_input($data) { $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data; } ?\u003e \u003cdiv class=\"main\"\u003e \u003ch2\u003ePHP 验证实例\u003c/h2\u003e \u003cform method=\"post\" action=\"\u003c?php echo htmlspecialchars($_SERVER['PHP_SELF']);?\u003e\"\u003e 姓名：\u003cinput type=\"text\" name=\"name\" value=\"\u003c?php echo $name;?\u003e\"\u003e \u003cspan class=\"error\"\u003e* \u003c?php echo $nameErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 性别: \u003cinput type=\"radio\" name=\"gender\" \u003c?php if (isset($gender) \u0026\u0026 $gender==\"女性\") echo \"checked\";?\u003e value=\"女性\"\u003e女性 \u003cinput type=\"radio\" name=\"gender\" \u003c?php if (isset($gender) \u0026\u0026 $gender==\"男性\") echo \"checked\";?\u003e value=\"男性\"\u003e男性 \u003cspan class=\"error\"\u003e* \u003c?php echo $genderErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 电邮：\u003cinput type=\"text\" name=\"email\" value=\"\u003c?php echo $email;?\u003e\"\u003e \u003cspan class=\"error\"\u003e* \u003c?php echo $emailErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 网址：\u003cinput type=\"text\" name=\"website\" value=\"\u003c?php echo $website;?\u003e\"\u003e \u003cspan class=\"error\"\u003e\u003c?php echo $websiteErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 评论：\u003ctextarea name=\"comment\" rows=\"5\" cols=\"40\"\u003e\u003c?php echo $comment;?\u003e\u003c/textarea\u003e \u003cbr\u003e\u003cbr\u003e \u003cinput type=\"submit\" name=\"submit\" value=\"提交\"\u003e \u003ch2\u003e你的输入是：\u003c/h2\u003e \u003c?php echo $name.\"\u003cbr/\u003e\"; echo $gender.\"\u003cbr/\u003e\"; echo $email.\"\u003cbr/\u003e\"; echo $website.\"\u003cbr/\u003e\"; echo $comment.\"\u003cbr/\u003e\"; ?\u003e \u003cbr/\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-07-19","objectID":"/posts/phpform/:0:0","tags":["PHP","Backend"],"title":"简单评论模块--php表单练习","uri":"/posts/phpform/"},{"categories":["PHP"],"content":" 练习php函数的基本使用。 注： 必选参数在可选参数的前面。 可在函数中定义函数，需要先调用外层函数才能调用内层函数。 \u003c?php /* 创建表格 */ function createTable($rows,$cols,$bgcolor='pink',$content='x'){ $table = \"\u003ctable border='1' bgcolor='{$bgcolor}' cellpadding='10' cellspacing='0' width='50%' \u003e\"; for($i=1;$i\u003c=$rows;$i++){ $table.=\"\u003ctr\u003e\"; for($j=1;$j\u003c=$cols;$j++){ $table.=\"\u003ctd\u003e{$content}\u003c/td\u003e\"; } $table .=\"\u003c/tr\u003e\"; } $table.=\"\u003c/table\u003e\"; return $table; } echo createTable(5,5,'pink','hello lruihao'); ?\u003e ","date":"2019-07-15","objectID":"/posts/phpfunc/:0:0","tags":["PHP","Backend"],"title":"php 函数学习","uri":"/posts/phpfunc/"},{"categories":["Fullstack"],"content":" 使用 WAMPServer 时自定义网站根目录。 WAMPServer自定义网站根目录 ","date":"2019-07-12","objectID":"/posts/wamproot/:0:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Fullstack"],"content":"修改apache配置文件 打开httpd.conf文件搜索documentroot后，找到路径修改为自定义的。 再打开httpd-vhost.conf文件修改对应的路径。 修改完配置文件需要重启所有服务！ ","date":"2019-07-12","objectID":"/posts/wamproot/:1:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Fullstack"],"content":"修改wampmanager文件 在wampserver安装路径根目录知道wampmanager.ini和wampmanager.tpl两个文件。搜索menu.left,然后也修改为自定义的路径。 然后退出，重启软件！ ","date":"2019-07-12","objectID":"/posts/wamproot/:2:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Fullstack"],"content":"编写php文件测试 \u003c?php echo \"hello world\"; ?\u003e WAMPServer多站点配置 打开httpd-vhost.conf文件，复制原有的几行配置文件，粘贴修改路径和域名等配置。比如 # Virtual Hosts # \u003cVirtualHost *:80\u003e ServerName localhost ServerAlias localhost DocumentRoot \"g:/Demo\" \u003cDirectory \"g:/Demo\"\u003e Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local \u003c/Directory\u003e \u003c/VirtualHost\u003e \u003cVirtualHost *:80\u003e ServerName test01.com DocumentRoot \"g:/Demo/test01\" \u003c/VirtualHost\u003e \u003cVirtualHost *:80\u003e ServerName test02.com DocumentRoot \"g:/Demo/test02\" \u003c/VirtualHost\u003e 再打开C:\\Windows\\System32\\drivers\\etc\\hosts文件,在文件最后添加类似于云服务器的域名解析，进行本地域名解析，当输入域名时优先从本地申请资源。 ... # For example: # # 102.54.94.97 rhino.acme.com # source server # 38.25.63.10 x.acme.com # x client host # localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 127.0.0.1 steamcommunity.com 192.168.28.1 windows10.microdone.cn 127.0.0.1 localhost ::1 localhost 127.0.0.1 test01.com 127.0.0.1 test02.com WAMPServer自拟定端口 WAMP服务我安装了好几次，每次因为修改配置文件搞崩了。。第一次装的时候发现80端口被占用了，因为以前玩了一下Windows的IIS，暂停IIS的网站，再使用命令或者直接在控制面板关掉就好了。 如果不使用80多为默认端口，比如修改为8080，还是在httpd.conf文件里修改。搜索80都改成8080然后，Ctrl+S保存，重新启动WampServer 在浏览器地址栏输入localhost:8000 #监听端口 Listen 0.0.0.0:8080 Listen [::0]:8080 ServerName localhost:8080 使用Notepad++打开 C:\\wamp 目录下的wampmanager.ini和wampmanager.tpl Ctrl+F查找 localhost 将其全部替换为localhost:8000 然后，Ctrl+S保存，重新启动WampServer ","date":"2019-07-12","objectID":"/posts/wamproot/:3:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Python"],"content":" 后面几天讲的有点杂，简单记录一下知识点。 6.19 这些知识点在课上都只是简单的提到了一下。 比如一些库的使用与安装都不会再课上详细讲解，需要课后再去研究。 ","date":"2019-06-21","objectID":"/posts/pysx2/:0:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"切片操作 列表切片操作 ","date":"2019-06-21","objectID":"/posts/pysx2/:1:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"字符串 ","date":"2019-06-21","objectID":"/posts/pysx2/:2:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"python原始字符串 print(r\"D:\\three\\two\") ","date":"2019-06-21","objectID":"/posts/pysx2/:2:1","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"长字符串 用三个单引号或者双引号包裹，前后呼应，成双成对。 ","date":"2019-06-21","objectID":"/posts/pysx2/:2:2","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"用\\换行字符表示字符未结束 ","date":"2019-06-21","objectID":"/posts/pysx2/:2:3","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"格式化输出format \"=={}==\"，{}表示占位符，其前后字符保持原样输出。 #TempConvert.py TempStr = input(\"请输入带有符号的温度值: \") if TempStr[-1] in ['F','f']: C = (eval(TempStr[0:-1]) - 32)/1.8 print(\"转换后的温度是{:.2f}C\".format(C)) elif TempStr[-1] in ['C','c']: F = 1.8*eval(TempStr[0:-1]) + 32 print(\"转换后的温度是{:.2f}F\".format(F)) else: print(\"输入格式错误\") ","date":"2019-06-21","objectID":"/posts/pysx2/:3:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"多变量赋值与交换（斐波那契数列） python 3.x版本 end=\"\" 可使输出不换行 print(x, end=\"\") #斐波那契数列 a, b = 1,1 while a \u003c 500: # 输出不大于500 的序列 print(a,end=\",\") a,b = b,a + b #交换变量 ","date":"2019-06-21","objectID":"/posts/pysx2/:4:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"笑傲江湖统计字符(dict,文件流) 统计《笑傲江湖》小说中出现的所有中文字符及标点符号的数量，每个字符及数目间用冒号:隔开，例如\"笑:1024\"，将所有字符及数量的对应采用逗号分隔，以CSV文件格式保存到“笑傲江湖--字符统计.txt”文件中。注意，统计字符不包括空格和回车。 csv文件格式： ‘,’逗号连接元素 fi = open(\"data/笑傲江湖-网络版.txt\",\"r\",encoding=\"utf-8\") fo = open(\"data/笑傲江湖-字符统计.txt\",\"w\",encoding=\"utf-8\") txt = fi.read() #打开文件 #txt d = {} for c in txt: d[c] = d.get(c,0)+1 del d[' '] #删除字典中的空格和回车的键值对 del d['\\n'] ls = [] for key in d: ls.append(\"{}:{}\".format(key,d[key])) fo.write(\",\".join(ls)) fi.close() fo.close() ","date":"2019-06-21","objectID":"/posts/pysx2/:5:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"numpy模块 … ","date":"2019-06-21","objectID":"/posts/pysx2/:6:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"pandas模块 … 6.20 ","date":"2019-06-21","objectID":"/posts/pysx2/:7:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"matplotlib绘图 import matplotlib.pyplot as plt import numpy as np x = np.arange(-5,5,0.01) y = 2**x+1 plt.plot(x,y) plt.title(\"y=2^x+1\",fontsize=24) plt.xlabel(\"X\",fontsize=14) plt.ylabel(\"Y\",fontsize=14) plt.tick_params(axis=\"both\",labelsize=14) plt.show() ","date":"2019-06-21","objectID":"/posts/pysx2/:8:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"爬虫 举了一个金融界，炒股，获取数据的爬虫 （今天没仔细听课，这数据爬过什么意思，咱不懂，咱也不敢问！） #! /usr/bin/env python #-*- encoding: utf-8 -*- #author pythontab.com import numpy as np import matplotlib.pyplot as plt import pandas as pd import pandas_datareader.data as web import datetime #import tushare as ts df_stockload = web.DataReader(\"000001.SS\", \"yahoo\", datetime.datetime(2017,1,1), datetime.date.today()) #print(type(datetime.datetime.now().strftime('%Y-%m-%d'))) #df_stockload = ts.get_hist_data('sh',start='2017-01-01',end=datetime.datetime.now().strftime('%Y-%m-%d')) print (df_stockload.columns)#查看列名 print (df_stockload.index)#查看索引 print (df_stockload.describe())#查看各列数据描述性统计 #绘制移动平均线 df_stockload.Close.plot(c='b') df_stockload.Close.rolling(window=30).mean().plot(c='r') #pd.rolling_mean(df_stockload.Close,window=30).plot(c='r') df_stockload.Close.rolling(window=60).mean().plot(c='g') #pd.rolling_mean(df_stockload.Close,window=60).plot(c='g') plt.legend(['Close','30ave','60ave'],loc='best') plt.show() Index(['High', 'Low', 'Open', 'Close', 'Volume', 'Adj Close'], dtype='object') DatetimeIndex(['2017-01-03', '2017-01-04', '2017-01-05', '2017-01-06', '2017-01-09', '2017-01-10', '2017-01-11', '2017-01-12', '2017-01-13', '2017-01-16', ... '2019-06-05', '2019-06-06', '2019-06-10', '2019-06-11', '2019-06-12', '2019-06-13', '2019-06-14', '2019-06-19', '2019-06-20', '2019-06-21'], dtype='datetime64[ns]', name='Date', length=596, freq=None) High Low Open Close Volume \\ count 596.000000 596.000000 596.000000 596.000000 5.960000e+02 mean 3076.147753 3039.201569 3056.960338 3060.169056 5.098201e+06 std 269.276147 273.757358 271.612122 272.072346 1.199107e+08 min 2488.479004 2440.906982 2446.019043 2464.363037 8.820000e+04 25% 2845.308228 2800.168762 2825.239502 2827.754822 1.375250e+05 50% 3153.184937 3118.613525 3134.300537 3139.085449 1.666500e+05 75% 3280.115234 3244.825256 3265.322021 3268.600342 2.091250e+05 max 3587.031982 3534.195068 3563.639893 3559.465088 2.927580e+09 Adj Close count 596.000000 mean 3060.169056 std 272.072346 min 2464.363037 25% 2827.754822 50% 3139.085449 75% 3268.600342 max 3559.465088 6.21 ","date":"2019-06-21","objectID":"/posts/pysx2/:9:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"类 比第一天稍微仔细一点讲了一下类,有点需要注意： self相当于this表示当前对象 python类的所有函数的第一个参数都要写self参数，self也可以是其他的比如lrh等字符替代，但是必须保持一致。 __表示私有的 class的定义可以不加(),()内可写继承的父类 ","date":"2019-06-21","objectID":"/posts/pysx2/:10:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"GUI设计 wxPython pip install wxPython import wx import wx #导入wxPython库 class Panel(wx.Panel): def __init__(self,parent): wx.Panel.__init__(self,parent=parent, id=-1) pass class Frame(wx.Frame): def __init__(self): wx.Frame.__init__(self, parent = None, title = u'量化软件', size=(1000,600), style=wx.DEFAULT_FRAME_STYLE^wx.MAXIMIZE_BOX) self.DispPanel= Panel(self) pass class App(wx.App): def OnInit(self): self.frame = Frame() self.frame.Show() self.SetTopWindow(self.frame) return True if __name__ == '__main__': app = App() app.MainLoop() import wx app = wx.App() window = wx.Frame(None, title=\"wxPython 你好！\", size=(400, 300)) panel = wx.Panel(window) label = wx.StaticText(panel, label=\"Hello World\", pos=(100, 100)) window.Show(True) app.MainLoop() ","date":"2019-06-21","objectID":"/posts/pysx2/:11:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"talib库的安装 下载whl文件 pip install TA_Lib-0.4.17-cp37-cp37m-win_amd64.whl pip install TA-Lib ","date":"2019-06-21","objectID":"/posts/pysx2/:12:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"选择排序递归版 def SelectSort(L): L=L[:] if len(L)\u003c=1: return L min = 0 for i in range(1,len(L)): if L[i]\u003cL[min]: min = i L[min],L[0] = L[0],L[min] return [L[0]]+SelectSort(L[1:]) L = [5,2,3,6,1,9,8,10,0] print(SelectSort(L)) [0, 1, 2, 3, 5, 6, 8, 9, 10] ","date":"2019-06-21","objectID":"/posts/pysx2/:13:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"机房上机系统(自我实践) import time class student(): def __init__(self,stu_no=\"\",stu_name=\"\",stu_xi=\"\",stu_time=\"\"): self.stu_no = stu_no self.stu_name = stu_name self.stu_xi = stu_xi self.stu_time = stu_time def print(self): print(\"学号：\"+self.stu_no+\"\\t姓名：\"+self.stu_name+\"\\t系别：\"+self.stu_xi+\"\\t机时(h)：\"+self.stu_time) def get_stu_name(self): return self.stu_name def get_stu_time(self): return int(self.stu_time) def set_stu_time(self,add_time): self.stu_time = add_time def menu(): print(\"\\t机房上机系统V0.1\") print(\"********************************\") print(\"\\t—\u003e1.录入学生信息\") print(\"\\t—\u003e2.上机\") print(\"\\t—\u003e3.下机\") print(\"\\t—\u003e4.缴费\") print(\"\\t—\u003e5.退出\") print(\"********************************\") select = eval(input(\"请输入序号：\")) while select not in [1,2,3,4,5]: print(\"输入错误，请重新输入！\") select = eval(input(\"请输入序号：\")) return select def get_time(): #获取当前时间 return time.strftime(\"%H:%M:%S\", time.localtime()) def main(): # 全局变量 text = [] # 上机记录列表 start_time = \"\" end_time = \"\" sum = 0 # 本系统按小时计费，不足一小时按一小时算 people = student() online_flag = False down_flag = False input_flag = False while True: select = menu() # 启用菜单 if select == 1: if input_flag: print(\"已录入，无需重复操作，缴费请输入4:\") continue else: input_flag = True stu_no = input(\"请输入学号：\") stu_name = input(\"请输入姓名：\") stu_xi = input(\"请输入系别：\") stu_time = input(\"请输入机时：\") people = student(stu_no,stu_name,stu_xi,stu_time) people.print() continue elif select == 2: if not input_flag: print(\"未录入学生信息，请录入！\") continue if not online_flag: online_flag = True start_time = get_time() start_num = int(start_time[0:2]) #print(start_num) text.append(\"上机时间：\"+start_time) print(\"已上机！上机时间为：\"+start_time) continue else: print(\"已上机！上机时间为：\"+start_time) continue elif select == 3: if not online_flag: print(\"还未上机，请上机！\") continue else: end_time = get_time() end_num = int(end_time[0:2]) sum = end_num - start_num sum = sum if(sum\u003e=0) else sum+24 sum = sum+1 if(sum==0) else sum print(\"已下机！下机时间为：\"+end_time+\"\\n上机时长(h)：\"+str(sum)+\"\\t剩余机时(h)：\"+str(people.get_stu_time()-sum)) text.append(\"下机时间：\"+end_time+\"\\n上机时长(h)：\"+str(sum)+\"\\t\"+people.get_stu_name()+\"剩余机时(h)：\"+str(people.get_stu_time()-sum)) people.set_stu_time(str(people.get_stu_time()-sum)) down_flag = True continue elif select == 4: if not input_flag: print(\"未录入学生信息，请录入！\") continue else: people.print() add_time = eval(input(\"请输入机时：\")) people.set_stu_time(str(add_time+people.get_stu_time())) people.print() else: if down_flag: print(\"3s后退出系统，感谢使用！\") time.sleep(3) # 延迟3s，显示提示文字 break # 退出系统 写入文件 else: print(\"请下机！\") continue #写入computer.txt文件 fo = open(\"D:\\\\computer.txt\",\"w\",encoding=\"utf-8\") fo.write(\"\\n\".join(text)) fo.close() if __name__==\"__main__\": main() ","date":"2019-06-21","objectID":"/posts/pysx2/:14:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":"量化交易代码分析与调试 由于python的版本问题和一些库的导入问题所以还未调试成功，先挂上代码。以后改篇再论。 #! /usr/bin/env python #-*- encoding: utf-8 -*- #author pythontab.com import wx import wx.adv import numpy as np import pandas as pd import pandas_datareader.data as web import matplotlib import matplotlib.pyplot as plt from matplotlib.figure import Figure import matplotlib.dates as mdates import mpl_finance as mpf from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg as FigureCanvas import matplotlib.gridspec as gridspec#分割子图 import datetime import talib import csv,os import codecs from RedefPanelMod import MPL_Panel_Base,Loop_Panel_Base from StockDataMod import GetStockDatPro from IndicatStrateMod import Excave_Indic_Base, QuantPickTimeSys,FactorPickStockAng plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签 plt.rcParams['axes.unicode_minus']=False #用来正常显示负号 class UserDialog(wx.Dialog):# user-defined def __init__(self,parent,text): wx.Dialog.__init__(self,parent,-1,u\"选股提示\",size=(400,500),style=wx.CAPTION|wx.CLOSE_BOX|wx.MAXIMIZE_BOX|wx.MINIMIZE_BOX) sizer = wx.BoxSizer(wx.VERTICAL) pstock_Text = wx.StaticText(self, -1, u'选股策略筛选结果') pstock_Text.SetFont(wx.Font(18,wx.DEFAULT,wx.NORMAL,wx.BOLD)) pstock_sure = wx.TextCtrl(self, -1, \"角度值:\\n\",size=(350,300),style = wx.TE_MULTILINE|wx.TE_READONLY)#多行|只读 pstock_sure.SetFont(wx.Font(10,wx.DEFAULT,wx.NORMAL,wx.BOLD)) okbtn = wx.Button(self,wx.ID_OK,u\"确认\") okbtn.SetDefault() sizer.Add(pstock_Text,flag=wx.ALIGN_CENTER) sizer.Add(pstock_sure,flag=wx.ALIGN_CENTER) sizer.Add(okbtn,flag=wx.ALIGN_CENTER) self.SetSizer(sizer) for i in text:pstock_sure.AppendText(i) class Frame(wx.Frame): def __init__(self): wx.Frame.__init__(self, parent = None, title = u'量化软件', size=(1500,800), style=wx.DEFAULT_FRAME_STYLE^wx.MAXIMIZE_BOX) #创建显示区面板 self.DispPanel = MPL_Panel_Base(self) self.BackPanel = Loop_Panel_Base(self) self.am = self.DispPanel.am self.vol = self.DispPanel.vol self.devol = self.DispPanel.devol self.macd = self.DispPanel.macd #创建参数区面板 self.ParaPanel = wx.Panel(self,-1) paraInput_Box = wx.StaticBox(self.ParaPanel, -1, u'参数输入') paraInput_Sizer = wx.StaticBoxSizer(paraInput_Box, wx.VERTICAL) self.StNameCodedict = {u\"开山股份\":\"300257.SZ\",u\"浙大网新\":\"600797.SS\",u\"水晶光电\":\"002273.SZ\", u\"高鸿股份\":\"000851.SZ\"} #初始化股票代码变量 self.stockName_Val = u\"开山股份\" self.stockCode_Val = self.StNameCodedict[self.stockName_Val] self.stockName_CMBO = wx.ComboBox(self.ParaPanel, -1,self.stockName_Val, choices = list(self.StNameCodedict.keys()), style = wx.CB_READONLY|wx.CB_DROPDOWN) #股票名称 stockCode_Text = wx.StaticText(self.ParaPanel, -1, u'股票名称') #策略选取 strate_Text = wx.StaticText(self.ParaPanel, -1, u'策略名称') strate_Combo_Val = [u\"双趋势融合\", u\"阿尔法\", u\"布林带\"] self.pickstrate_Val = u\"双趋势融合\" self.pickstrate_CMBO = wx.ComboBox(self.ParaPanel, -1, self.pickstrate_Val, choices = strate_Combo_Val, style = wx.CB_READONLY|wx.CB_DROPDOWN) #策略名称 #日历控件选择数据周期 self.dpcEndTime = wx.adv.DatePickerCtrl(self.ParaPanel, -1,style = wx.adv.DP_DROPDOWN|wx.adv.DP_SHOWCENTURY|wx.adv.DP_ALLOWNONE)#结束时间 self.dpcStartTime = wx.adv.DatePickerCtrl(self.ParaPanel, -1,style = wx.adv.DP_DROPDOWN|wx.adv.DP_SHOWCENTURY|wx.adv.DP_ALLOWNONE)#起始时间 DateTimeNow = wx.DateTime.Now()#wx.DateTime格式\"03/03/18 00:00:00\" #DateTimeNow = datetime.datetime.fromtimestamp(wx.DateTime.Now().GetTicks()) #DateTimeNow = datetime.datetime.fromtimestamp(DateTimeNow) self.dpcEndTime.SetValue(DateTimeNow) DateTimeNow.SetYear(DateTimeNow.year-1) self.dpcStartTime.SetValue(DateTimeNow) stockData_Text = wx.StaticText(self.ParaPanel, -1, u'日期(Start-End)') #初始化时间变量 dateVal = self.dpcStartTime.GetValue() self.stockSdate_Val = datetime.datetime(dateVal.year,dateVal.month+1,dateVal.day) dateVal = self.dpcEndTime.GetValue() self.stockEdate_Val = datetime.datetime(dateVal.year,dateVal.month+1,dateVal.day) paraInput_Sizer.Add(stockCode_Text,proportion=0,flag=wx.EXPAND|wx.ALL,border=2) paraInput_Sizer.Add(self.stockName_CMBO, 0, wx.EXPAND|wx.ALL|wx.CENTER, 2) paraInput_Sizer.Add(stockData_Text,proportion=0,flag=wx.EXPAND|wx.ALL,bord","date":"2019-06-21","objectID":"/posts/pysx2/:15:0","tags":["Python","Backend"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":" 以前和前一段时间自己也学习了一下python，也写了几个小爬虫； 这次正好又课程安排了为期两周的综合实训，主要是**“用python做量化交易”** 进行了两天，讲的都是一些基本的东西，以前也接触过，所以很容易理解。还讲了一些软件，pycharm，anaconda,sublime等大都也都用过。anaconda倒是第一次接触。 ","date":"2019-06-18","objectID":"/posts/pysx1/:0:0","tags":["turtle","Python","Backend"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"6.17 print(\"Hello World!\") 讲了一下变量和python的特色什么的。 还讲了模块定义def和类定义 class zxm(): def __init__(self): self.x=0 self.y=0 def move_up(self): self.y +=1 my_zxm=zxm() print(my_zxm) \u003c__main__.zxm object at 0x000001D99CFEF668\u003e ","date":"2019-06-18","objectID":"/posts/pysx1/:1:0","tags":["turtle","Python","Backend"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"6.18 ","date":"2019-06-18","objectID":"/posts/pysx1/:2:0","tags":["turtle","Python","Backend"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"输入输出 print 输出 input 输入 eval 执行一个字符串表达式，并返回表达式的值 x=eval(input(\"请输入x的值：\")) y=eval(input(\"请输入y的值：\")) z=(x**2+y**2)**0.5 print(z) # 导入复数数学模块 import cmath num = int(input(\"请输入一个数字: \")) num_sqrt = cmath.sqrt(num) print('{0}的平方根为 {1:0.3f}+{2:0.3f}j'.format(num ,num_sqrt.real,num_sqrt.imag)) ","date":"2019-06-18","objectID":"/posts/pysx1/:2:1","tags":["turtle","Python","Backend"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"数据类型 今天还讲了一下数据类型 字符串： \"\" '' 元组tuple(2,3) 列表list[2,3] 字典dict{Key:Value} 集合{} x=[1,10] type(x)#判断元素类型 list ","date":"2019-06-18","objectID":"/posts/pysx1/:2:2","tags":["turtle","Python","Backend"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"循环判断 for x in range(1,10,2): # (start,stop,step) pass # pass不做任何事情，一般用做占位语句 for letter in 'Python': if letter == 'h': pass print('这是 pass 块') print('当前字母 :'+ letter) print(\"Good bye!\") 当前字母 :P 当前字母 :y 当前字母 :t 这是 pass 块 当前字母 :h 当前字母 :o 当前字母 :n Good bye! ","date":"2019-06-18","objectID":"/posts/pysx1/:2:3","tags":["turtle","Python","Backend"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"str() 、 import导库 x=10 print(\"整数转字符串\"+str(x)) import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Google翻译意思是: 美丽胜过丑陋。显式优于隐式。简单比复杂更好。复杂比复杂更好。Flat优于嵌套。稀疏优于密集。可读性很重要。特殊情况不足以打破规则。虽然实用性胜过纯洁。错误不应该默默地传递。除非明确沉默。面对模棱两可，拒绝猜测的诱惑。应该有一个最好只有一个明显的方法来做到这一点。虽然这种方式起初可能并不明显，除非你是荷兰人。现在比永远好。虽然现在永远不会比正确好。如果实施很难解释，这是一个坏主意。如果实现很容易解释，那可能是个好主意。命名空间是一个很棒的主意，让我们做更多的事情吧！ ","date":"2019-06-18","objectID":"/posts/pysx1/:2:4","tags":["turtle","Python","Backend"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Python"],"content":"turtle绘图库（内置模块）","date":"2019-06-18","objectID":"/posts/pysx1/:2:5","tags":["turtle","Python","Backend"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["others"],"content":" 黑盒测试着重测试软件功能，它并不涉及程序的内部结构和内容特性，主要根据规格说明，只依靠被测试程序的输入和输出之间关系或程序的功能来设计测试用例。 白盒测试则清楚程序内部的结构以及是如何运作的，因此白盒测试需要对系统内部的结构和工作原理有一个清楚的了解。 程序 #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#define N 2\u003c\u003c25 int a=N,b=N,c=N,d=N; void shuru(); void panduan(int a1,int b1,int c1); int main() { char se; shuru(); panduan(a,b,c); while(1) { printf(\"是否要继续y or n :\"); scanf(\"%c\",\u0026se); if(se=='\\n') scanf(\"%c\",\u0026se); switch(se) { case 'y': shuru(); panduan(a,b,c); break; case 'n': return 0; } } } void shuru() { printf(\"Please enter 三角形三边 (a,b,c)\\n\"); while(!scanf(\"%d,%d,%d,%d\",\u0026a,\u0026b,\u0026c,\u0026d)){//判断非数字字符 fflush(stdin);//清理缓存 a=N;b=N;c=N;d=N; printf(\"输入错误\\n\"); } fflush(stdin); while((a\u003c1||a\u003e100)||(b\u003c1||b\u003e100)||(c\u003c1||c\u003e100)||d!=N) { if(b==N||c==N||d!=N) printf(\"输入错误\\n\");//边数为1、2、4条 else if(a==0||b==0||c==0) printf(\"边长不能为0\\n\"); else if(a\u003c0||b\u003c0||c\u003c0) printf(\"边长不能为负\\n\"); else printf(\"Please enter 1-100之间的整数\\n\"); a=N;b=N;c=N;d=N; while(!scanf(\"%d,%d,%d,%d\",\u0026a,\u0026b,\u0026c,\u0026d)){//判断非数字字符 fflush(stdin);//清理缓存 a=N;b=N;c=N;d=N; printf(\"输入错误\\n\"); } fflush(stdin); } } void panduan(int a1,int b1,int c1) { if(a1+b1\u003ec1\u0026\u0026b1+c1\u003ea1\u0026\u0026a1+c1\u003eb1) { if(a1==b1\u0026\u0026a1==c1) printf(\"等边三角形\\n\"); else if(a1==b1||a1==c1||b1==c1) printf(\"等腰三角形\\n\"); else printf(\"一般三角形\\n\"); } else printf(\"非三角形\\n\"); } 测试 ","date":"2019-05-26","objectID":"/posts/judgetriangle/:0:0","tags":["黑盒测试","C"],"title":"判断三角形的黑盒测试","uri":"/posts/judgetriangle/"},{"categories":["linux"],"content":" 目前 HustOj 在 GitHUb 地址是：https://github.com/zhblue/hustoj 安装时注意ubuntu版本，没条件的可以在自己ubuntu上尝试，或者虚拟机上（关注公众号回复ubuntu16.04获取iso镜像文件），也可以在云实验室的云服务器上做做实验。 更多说明及ACM/NOIP题库下载见官网博客代码的那些事|程序员回忆录 快速安装 OJ 下载 wget https://raw.githubusercontent.com/zhblue/hustoj/master/trunk/install/install-ubuntu16+.sh 安装 sudo bash install-ubuntu16+.sh 等待中一路回车，当提示 done！ 则表示安装成功： 使用 HustOJ 打开网页/IP地址 注册admin 用 admin 作为用户名注册一个用户，将会自动成为管理员。 注册成功，会提示： 登录后台 登录账号，并点击右上角的管理： 添加测试题目 在后台选择添加题目，添加成功： 然后再提交代码测试判题机。 说明 安装后几个重要配置文件的位置 /home/judge/etc/judge.conf /home/judge/src/web/include/db_info.inc.php /etc/php5/fpm/php.ini 或 /etc/php7.0/fpm/php.ini /etc/nginx/sites-enabled/default ","date":"2019-05-17","objectID":"/posts/hustoj/:0:0","tags":["hustoj","ACM","ubuntu","linux"],"title":"HustOJ 基础搭建教程","uri":"/posts/hustoj/"},{"categories":["ACM"],"content":" 二进制最大公约数算法避免了欧几里得算法（辗转相除法）的大量取模操作，有效减少了时间消耗，且更为方便。 原理 本算法基于以下事实： 对于两个数的最大公约数gcd(m, n)，有 m\u003cn时，gcd(m, n)=gcd(n, m) m偶n偶时，gcd(m, n)=2*gcd(m/2, n/2) m偶n奇时，gcd(m, n)=gcd(m/2, n) m奇n偶时，gcd(m, n)=gcd(m, n/2) m奇n奇时，gcd(m, n)=gcd(n, m-n) 采用递归即可。 实现 inline int GCD(int x,int y) { int i,j; if(x==0) return y; if(y==0) return x; for(i=0;0==(x\u00261);++i)x\u003e\u003e=1; // 去掉所有的2 for(j=0;0==(y\u00261);++j)y\u003e\u003e=1; // 去掉所有的2 if(j\u003ci) i=j; while(1){ if(x\u003cy)x^=y,y^=x,x^=y; // 若 x \u003c y 交换 x, y if(0==(x-=y)) return y\u003c\u003ci; // 若x == y， gcd == x == y (就是在辗转减，while(1)控制) while(0==(x\u00261))x\u003e\u003e=1; // 去掉所有的2 } } int get_lcm(int a,int b)///获得最小公倍数 { int x=a; int y=b; while(b) { int t=a; a=b; b=t%b; } return x/a*y; } ","date":"2019-05-17","objectID":"/posts/gcd-bit/:0:0","tags":["欧几里得","数学","数论","C"],"title":"最大公约数(二进制算法)","uri":"/posts/gcd-bit/"},{"categories":["PHP"],"content":" ImgURL是一个开源、免费的图床程序，ImgURL 2.x之后对环境要求更高，尤其是ImageMagick组件的支持，很多朋友不清楚怎样安装这个组件，这篇文章分享宝塔面板安装ImgURL 2.x图床的过程（包括ImgURL 2.x需要的各种组件） 阅读原文 准备工作 已经安装宝塔面板 在宝塔后台创建一个站点 下载ImgURL 2.x上传到站点根目录并解压 设置伪静态 如果您宝塔面板安装的Apache则不需要再设置伪静态，直接跳过这个步骤，如果使用的Nginx环境，请继续往下看。 找到对应的站点 - 点击后面设置按钮 - 伪静态 - 添加下面的伪静态规则 location / { try_files $uri $uri/ /index.php?$query_string; } location ~* \\.(db3|json)$ { deny all; } location ~* ^/(temp|upload|imgs|data|application|static|system)/.*.(php|php5)$ { return 403; } 安装fileinfo \u0026 imagemagick 在宝塔后台 - 软件管理 - 找到您站点对应的PHP版本 - 设置PHP - 安装扩展 - 勾选fileinfo和imagemagick，如下截图。 安装ImgURL 2.x 其它所需扩展宝塔默认已经支持，重点是安装fileinfo和imagemagick，扩展安装完毕后就可以访问您自己的域名安装ImgURL了，如果正常会看到ImgURL安装界面。 其它说明 如果安装遇到任何问题，请留言反馈或到3T官方社区进行反馈 ImgURL更多使用说明请参考帮助文档：https://dwz.ovh/imgurldoc ","date":"2019-05-16","objectID":"/posts/imgurl/:0:0","tags":["ImgURL","宝塔面板","Backend"],"title":"宝塔面板安装ImgURL图床","uri":"/posts/imgurl/"},{"categories":["Python"],"content":" 用python模拟post请求获取“麻小科技”示例酒店后台的数据，再打包发送至指定的微信群或者好友。 要求每天早上8点定时把每个酒店的数据发送至每个酒店的微信工作群。 背景 麻小科技： 麻小科技全名深圳市麻小科技有限公司，成立于2017年1月。是我高一的时候参加Peer夏令营带我们一个玩的“老师”和他的朋友的创业公司，说老师有点奇怪，我们都是直接叫名字的，比如大家都叫我瑞豪，我也就叫他文捷哥，简称捷哥吧。他们公司主要的开发模式是，小程序前端+php后端，然后做的是酒店小程序，为每个酒店定制小程序。这些小程序可以贴在客房中给访客提供一些服务，大大节省了成本也提高了效率。 然后每个酒店小程序都有独立的后台，后台会记录一些点击需求的数据。现在他们有一个需求需要把每个酒店小程序后台的数据在每天早上9点发送至对应酒店的微信群。 实现代码 缓存登录信息，短时间类无需重复登录，仅第一次需要扫码登录（相当于微信网页版），后面的登录只需在手机上确认登录信息。 #!/usr/bin/python import requests import json import time from wxpy import * # 基本信息填写： # 酒店id，酒店名称及群名列表数据，格式：[\"xxx\",\"xxx\",\"xxx\"] # 使用时请将以下三个列表一一对应 hotel=[\"xxxx\",\"xxxx\"] # 酒店后台数据接口二级域名，已匿名 hotel_name=[\"增城宾馆\",\"百丽酒店\"] grouplist = [\"麻小\",\"富强民主文明和谐自由平等公正法治\"] # post请求发送的数据 postData = { # 'username':'test', # 'password':'123456', } def get_data(): result = [] #结果列表 i = 0 #计数器 for each in hotel: url=\"http://\"+each+\".maxiaokeji.com/xxx/xxxxxxx/xxx\" # 为保护隐私及权益，这里不提供接口 r = requests.post(url,data=postData) # print(r.text) # 把结果转化为json字符串 response=json.dumps(r.json(),indent=4,ensure_ascii=False) #sort_keys=True # 把json转换为dict字典作为中间结果，再取出昨日数据 midresult=json.loads(response) result.append(\"早上好！\"+hotel_name[i]+\"小程序昨日数据如下：\\n访问数：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type1\"])+\"\\n房间数：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type2\"])+\"\\n需求量：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type3\"])+\"\\n商品点击量：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type4\"])) i+=1 # print(result) return result def wechat_send(bot,result): # my_friend = bot.friends().search('lrh')[0] # my_friend.send(result) i = 0 # 计数器 for group in grouplist: my_group = bot.groups().search(group)[0] #依次搜索每一个群名称，每次一个 my_group.send(result[i]) print(result[i]) print(\"已发送至群：\"+group) i+=1 def main(bot): # 设置最大休眠时间，防止程序长时间占用系统资源 while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) # 设置每天8点发送 if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"软件明天开始将在每天8点发送数据！\") result=get_data() # 获取数据 wechat_send(bot,result) # 发送数据 time.sleep(86400-int(now_min)*60) if __name__==\"__main__\": bot = Bot(cache_path=True) # 初始化机器人，扫码登陆 main(bot); 测试结果 程序打包 使用pyinstaller工具打包成可执行文件即可。（可执行文件不可跨平台运行，分平台打包） 目前该程序已经上线测试中…暂未反馈问题 收获 第一次参与实际公司的项目开发，虽然只是一个小的需求设计，但是我在这个过程中也学到了很多，比如通过实际一两周的编程对Python的熟悉度远远好过以前在实验室看的一个月视频。 还有就是在此次开发中，也感受到了实际项目开发的团队合作重要性，刚开始拿到这个需求，由于我对python和后台，以及数据接口这些基本的操作都不懂，就拿数据获取来说，我一开始一位要自己模拟登陆后台（已知密码），一顿操作、百度等等失败告终，后来涛哥给了一个数据接口，加上涛哥耐心指点，我才终于拿到了数据。 还有在多人合作的项目中，为保持代码的可读性，要尽量的多些注释，还有函数方法的命名尽量具备可读性。比如我代码中的wechat_send()，一开始的命名是wxfs()，经捷哥指正我才改过来的。 ","date":"2019-05-11","objectID":"/posts/mx2wx/:0:0","tags":["Python","wxpy","pyinstaller","HTTP","JSON","Cron"],"title":"python实战：模拟post请求定时获取后台数据并打包发送至微信","uri":"/posts/mx2wx/"},{"categories":["HTML"],"content":" \u003c!--[if !IE]\u003e\u003c!--\u003e 除IE外都可识别 \u003c!--\u003c![endif]--\u003e \u003c!--[if IE]\u003e 所有的IE可识别 \u003c![endif]--\u003e \u003c!--[if IE 6]\u003e 仅IE6可识别 \u003c![endif]--\u003e \u003c!--[if lt IE 6]\u003e IE6以及IE6以下版本可识别 \u003c![endif]--\u003e \u003c!--[if gte IE 6]\u003e IE6以及IE6以上版本可识别 \u003c![endif]--\u003e \u003c!--[if IE 7]\u003e 仅IE7可识别 \u003c![endif]--\u003e \u003c!--[if lt IE 7]\u003e IE7以及IE7以下版本可识别 \u003c![endif]--\u003e \u003c!--[if gte IE 7]\u003e IE7以及IE7以上版本可识别 \u003c![endif]--\u003e \u003c!--[if IE 8]\u003e 仅IE8可识别 \u003c![endif]--\u003e \u003c!--[if IE 9]\u003e 仅IE9可识别 \u003c![endif]--\u003e 项目范例说明 ![if !IE]The NOT operator. This is placed immediately in front of the feature, operator, or subexpression to reverse the Boolean meaning of the expression. NOT运算符。这是摆立即在前面的功能，操作员，或子表达式扭转布尔表达式的意义。lt [if lt IE 5.5] The less-than operator. Returns true if the first argument is less than the second argument. 小于运算符。如果第一个参数小于第二个参数，则返回true。 lte[if lte IE 6]The less-than or equal operator. Returns true if the first argument is less than or equal to the second argument. 小于或等于运算。如果第一个参数是小于或等于第二个参数，则返回true。 gt[if gt IE 5]The greater-than operator. Returns true if the first argument is greater than the second argument. 大于运算符。如果第一个参数大于第二个参数，则返回true。 gte [if gte IE 7]The greater-than or equal operator. Returns true if the first argument is greater than or equal to the second argument. 大于或等于运算。如果第一个参数是大于或等于第二个参数，则返回true。 ( )[if !(IE 7)]Subexpression operators. Used in conjunction with boolean operators to create more complex expressions. 子表达式运营商。在与布尔运算符用于创建更复杂的表达式。\u0026[if (gt IE 5)\u0026(lt IE 7)]The AND operator. Returns true if all subexpressions evaluate to true AND运算符。如果所有的子表达式计算结果为true，返回true|[if (IE 6)|(IE 7)]The OR operator. Returns true if any of the subexpressions evaluates to true. OR运算符。返回true，如果子表达式计算结果为true。 \u003c!--[if lt IE 9]\u003e 加载CSS1 \u003c!--[else]\u003e 加载CSS2 \u003c![endif]--\u003e 这样有效是有效,但是用HTML VALIDATOR里,报错,因为这个不符合XHTML 1.1的规范, 如果把ELSE语句去掉,则正确. 加载CSS2 \u003c!--[if lt IE 9]\u003e 加载CSS1(可以把要重写的写在这里). \u003c![endif]--\u003e ","date":"2019-05-10","objectID":"/posts/ifzhushi/:0:0","tags":["HTML","Frontend","他山之石"],"title":"条件注释判断浏览器版本\u003c!--[if lt IE 9]\u003e;","uri":"/posts/ifzhushi/"},{"categories":["Python"],"content":" 第一次运行根据程序执行时间，判断程序休眠的时间，尽最大可能休眠，节省系统资源。 第二次运行后直接休眠一天，到每天早上8点执行任务。 （该程序需要一直挂着，保持网络不断） import time while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"启动时北京时间为：\" + time.strftime(\"%H:%M\", time.localtime()), \"\\t软件将在每天8点发送数据！\") # 以下为定时任务 print(\"数据\") time.sleep(86400-int(now_min)*60) ","date":"2019-05-09","objectID":"/posts/pysettime/:0:0","tags":["Python","Cron","Backend"],"title":"python 设置程序每天 8 点定时执行任务","uri":"/posts/pysettime/"},{"categories":["Python"],"content":" 用过命令pip install pyinstaller安装失败，此包依赖于pywin32，安装前需要先pip install pywin32,我安装了还是出错，稍微百度了一下也没有看到解决办法。 这里通过手动下载安装解决的，记录一下。 下载 去官网下载pyinstaller安装包：https://pypi.org/project/PyInstaller/#files 解压 我这里解压到E:\\应用\\Python37\\Lib\\site-packages\\PyInstaller-3.4 安装 cmd也进入到上面的路径下，然后执行Python setup.py install，等待安装完毕 pyinstaller简介 pyinstaller将Python脚本打包成可执行程序，使在没有Python环境的机器上运行。 最新版是pyinstaller 3.4，可运行在Windows，Mac和Linux操作系统下。 但它不是跨编译的，也就是说在Windows下用PyInstaller生成的exe只能运行在Windows下，在Linux下生成的只能运行在Linux下。 打包 打包的app里并不包含任何源码，但将脚本的.pyc文件打包了。 基本语法： pyinstaller options myscript.py 常用的可选参数如下： --onefile 将结果打包成一个可执行文件 --onedir 将所有结果打包到一个文件夹中，该文件夹包括一个可执行文件和可执行文件执行时需要的依赖文件（默认） --paths=DIR 设置导入路径 --distpath=DIR 设置将打包的结果文件放置的路径 --specpath=DIR 设置将spec文件放置的路径 --windowed 使用windows子系统执行，不会打开命令行（只对windows有效） --nowindowed 使用控制台子系统执行（默认）（只对windows有效） --icon=\u003cFILE.ICO\u003e 将file.ico添加为可执行文件的资源(只对windows有效） 如pyinstaller --paths=\"D:\\\" test.py CSDN访问量脚本实例 比如，拿以前写的一个刷csdn访问量工具csdn.py（放在桌面上），代码详见 在cmd进入桌面路径，输入如下命令 pyinstaller --onefile --nowindowed csdn.py 另外推广一下自己的微信公众号，欢迎关注公众号👇👇👇，后台回复关键词csdn_visiter获取源码及exe可执行文件。 ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:0:0","tags":["Python","pyinstaller","脚本","Backend"],"title":"安装pyinstaller出错的解决办法及csdn工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Java"],"content":" 实现一个简单的基于单线程的资源下载器，如图所示，用户可以任意指定下载资源的链接地址，系统根据该地址判断资源是否存在，如果存在，则将该资源下载到本地。 GUI设计基本流程 先记录一下GUI设计的基本流程： 根据需要从相应的顶层容器继承（如果创建窗体就继承JFrame，对话框就继承JDialog），新建一个子类。 然后设置顶层容器的属性，包括大小、位置、标题和关闭事件等。 设置界面上GUI组件的事件响应。 public void actionPerformed(ActionEvent e) {} 向顶层容器上添加GUI组件，并设置布局。（通常利用JPanel组件先作为微型容器） 创建新建子类的实例，调用setVisible(true)方法显示页面。（也可以直接在子类中设置setVisible(true)） 实现代码 package cn.lruihao.base; import java.awt.FlowLayout; import java.awt.Font; import java.awt.HeadlessException; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.FileOutputStream; import java.io.InputStream; import java.net.URL; import java.net.URLConnection; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JTextField; public class SingleThreadDown extends JFrame implements ActionListener { private final JPanel panel=new JPanel(); private final JLabel label1=new JLabel(\"网络资源的单线程下载：\"); private final JLabel label2=new JLabel(\"网络资源的网址：\"); JButton StartButton = new JButton(\"单击开始下载\"); JButton resetButton = new JButton(\"清空\"); JButton exitButton = new JButton(\"退出\"); JTextField urlField = new JTextField(20); public SingleThreadDown() { panel.setLayout(new FlowLayout()); //布局管理器 label1.setFont(new Font(\"雅黑\",Font.BOLD,15)); panel.add(label1); panel.add(label2); panel.add(urlField); panel.add(StartButton); panel.add(resetButton); panel.add(exitButton); setContentPane(panel); setSize(400,200); setLocation(400,400); setVisible(true); //面板可视化，也可以在main中通过JFrame子类对象调用方法设置 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //默认关闭事件 StartButton.addActionListener(this);//添加点击事件，传入ActionListener对象，由于子类继承了ActionListener接口，所以this resetButton.addActionListener(this); exitButton.addActionListener(this); } public void download(String address) throws Exception { URL url = new URL(address); URLConnection urlcon = url.openConnection(); urlcon.connect(); InputStream in=urlcon.getInputStream();//获取的字节流对象 String filePath = url.getFile(); int pos=filePath.lastIndexOf(\"/\"); //\"/\"分割的最后一个串的下标 String fileName = filePath.substring(pos+1); FileOutputStream out = new FileOutputStream(\"C:\\\\Users\\\\李瑞豪\\\\Desktop\\\\\"+fileName); byte[] b = new byte[1024]; int len=0; while((len=in.read(b,0,1024))!=-1) { out.write(b,0,len); } out.close(); in.close(); JOptionPane.showMessageDialog(this, \"下载完毕\"); } @Override public void actionPerformed(ActionEvent e) { if(e.getSource()==StartButton) { if(\"\".equals(urlField.getText())){ JOptionPane.showMessageDialog(this, \"请输入资源地址\"); } String url = urlField.getText(); try { download(url); } catch (Exception e1) { JOptionPane.showMessageDialog(this, \"资源地址有误，请检查~\"); e1.printStackTrace(); } }else if(e.getSource()==resetButton) { urlField.setText(\"\"); }else { System.exit(0); } } public static void main(String[] args) { new SingleThreadDown(); } } 运行结果测试 通过https://github.com/Lruihao/Grocery/raw/master/fonts/MMT_last.ttf下载沐目体ttf字体文件，稍微等待一下弹出对话框“下载完毕”，经检查下载内容正常。 ","date":"2019-05-08","objectID":"/posts/singlethreaddown/:0:0","tags":["GUI","URLConnection","HTTP","Java","Backend"],"title":"java 实现一个单线程的资源下载器","uri":"/posts/singlethreaddown/"},{"categories":["Python"],"content":" Json（JavaScript Object Notation）它是一种轻量级的数据交换格式，具有数据格式简单，读写方便易懂等很多优点。许多主流的编程语言都在用它来进行前后端的数据传输，大大的简化了服务器和客户端的开发工作量。相对于XML来说，更加的轻量级，更方便解析，因此许多开发者都遵循Json格式来进行数据的传输和交换。今天我们详细介绍一下Python在Json的编解码方面的知识。阅读原文 json的数据格式 在json中，遵循“键值对”的这样一种方式，比如：“{“name”:“tom”}”,就是一个json格式的数据，json的格式归纳下来，一般有以下几点： 对象通过键值对表现； 键通过双引号包裹，后面跟冒号“:”，然后跟该键的值； 值可以是字符串、数字、数组等数据类型； 对象与对象之间用逗号隔开； “{}”用来表达对象； “[]”用来表达数组； 我们看一个略为复杂一点的例子： 上例则是一个典型的json格式的数据，强大的Python提供了一个“json”模块，可以方便的将各种零散的数据通过模块的内置函数编码形成一个json格式的数据，也可以将一个json格式的数据解码形成自己需要的数据，非常好用，下面我们就来介绍一下。 json.dumps() json模块里的dumps函数是对数据进行编码，形成json格式的数据，我们看一下下面的例子： 通过输出的结果很容易看出，通过dumps方法使字典转换成为了json格式，虽然它们非常相似。其中，在dumps里的参数“sort_keys=True”，使得输出json后对key和value进行0~9、a~ z的顺序排序，如果不填，则按照无序排列。有时候，通过排序可以方便地比较json中的数据，因此，适当的排序是很有必要的。 此外，“Indent”参数表示缩进的意思，它可以使得输出的Json看起来更加整齐好看，可读性更强，例如： 下面列举一下dumps（）的可填参数： skipkey：默认为False，当dict对象里的数据不是Python的基本数据类型；（str,unicode,int,long,float,bool,None）时，当skipkey为False，就会报错，如果skipkey为True，则可以跳过这类key； indent：如果填0或者不填，则按照一行进行打印，否则按照indent的数值显示前面的空格（正整数形式）； separators：分隔符，默认为“(',',':')”，它表示key之间用“,”隔开，key和value之间用“:”隔开； encoding：编码格式，默认值是UTF-8； sort_keys：对key、value进行排序，默认值是False，即不排序； ensure_ascii：默认为True，如果dict对象里含有none-ASCII的字符，则显示\\uXX的格式，如果为False，则能正常显示出来； json.loads() 和dumps相反，loads函数则是将json格式的数据解码，转换为Python字典，我们看一下下面的例子： 有时候，输出结果遇到中文的时候，会出现编码格式不一样的情况，显示出为Unicode的编码格式，使得不易读懂，解决办法是添加参数“encoding”参数，即上面的改写成这样：d1 = json.loads(data1,encoding=‘utf-8’)即可。 json.dump() 和 json.load() 相对于上面所讲的dumps和loads来说，dump和load函数的功能类似，只不过前者是用来处理字符串类型的，而后者是用于处理文件类型的，如下所示： 上例列举出了json的四个方法：dumps（）和dump（）、loads（）和load（）的简单使用方法，可见，Python对于json的处理相当方便，不像c++那样（谁用谁知道）。 ","date":"2019-05-07","objectID":"/posts/jsoninfo/:0:0","tags":["Python","JSON","他山之石","Backend"],"title":"Python 如何操作 Json？","uri":"/posts/jsoninfo/"},{"categories":["Python"],"content":" 通过requests可以向某个地址发送请求，可以用来做一些接口的测试；主要有两个方法： requests.get() requests.post() 最近帮朋友的项目做一个小需求，需要把后台数据定期打包发送到微信群，麻小科技涛哥给了我一个接口，post 访问。 #!/usr/bin/python import requests \"\"\" 通过requests可以向某个地址发送请求requests.post(url,json date) post方法还有其他参数，如header等 \"\"\" # post发送的数据 postData = { # 'username':'test', # 'password':'123456', # 'salary':2000, } # 接口这里不便公开 r = requests.post('http://demo.maxiaokeji.com/xx/xxxxx/xxxx',data=postData) # print(r.text) response=r.json() print(response) 运行后会在屏幕打印出返回的json数据 ","date":"2019-05-07","objectID":"/posts/posttest/:0:0","tags":["Python","HTTP","Backend"],"title":"python 发送 post 请求进行简单的接口测试","uri":"/posts/posttest/"},{"categories":["Java"],"content":" 该例中首先生成一个URL对象lrh，指向RUI豪小栈，然后再调用lrh.openStream()方法生成该URL的一个输入流，这是一个字节流，在此基础上进一步通过InputStreamReader和BufferedReader构造一个带缓冲功能的字符流，并通过这个字符流对象读取该URL的html内容，进而输出到桌面文件和控制台屏幕。URLConnection类也可以用来对由URL引用的资源进行读写操作，前提是先通过connect()方法建立连接，然后再去获取响应头信息或响应内容。 package cn.lruihao.base; import java.io.BufferedReader; import java.io.File; import java.io.FileWriter; import java.io.InputStreamReader; import java.net.URL; import java.net.URLConnection; public class URLReader { public static void main(String[] args) throws Exception{ try { URL lrh=new URL(\"https://www.lruihao.cn\"); File file=new File(\"C:\\\\Users\\\\李瑞豪\\\\Desktop\\\\lrh.html\"); FileWriter fout=new FileWriter(file); BufferedReader in =new BufferedReader(new InputStreamReader(lrh.openStream()));//字节流转化成字符流，再构建缓冲字符流 String inputLine; while((inputLine=in.readLine())!=null) { System.out.println(inputLine); fout.write(inputLine); } in.close(); fout.close(); //获取响应header信息 URLConnection conn=lrh.openConnection(); conn.connect(); System.out.println(\"获取到的响应长度：\"+conn.getContentLength()); System.out.println(\"响应类型：\"+conn.getContentType()); //用BufferedReader读取URL的响应 in =new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; String result=null; while((line=in.readLine())!=null) { result+=line; } System.out.println(result); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2019-05-06","objectID":"/posts/urlreader/:0:0","tags":["URLConnection","Java","Backend"],"title":"java 通过 URL 和 URLConnection 访问网页资源","uri":"/posts/urlreader/"},{"categories":["Java"],"content":" 基本功能： 给定一个密钥，读取文件内容，加密后，输出到另外一个文件。 这里使用文件输入流读取文件内容，然后每个字节和密码进行异或简单加密。加密完成，使用文件输出流写入另一个文件中。解密和加密方法一样。利用的是对同一个数异或两遍其值不变的性质。因此一个程序可以完成加密和解密功能。只需修改文件名即可。 文件加密解密 package cn.lruihao.base; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class EncryptFile { public static void main(String[] args) throws IOException { byte pwd=123;//加密/解密密码 FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/EncryptFile.java\");//待加密文件 FileOutputStream fout=new FileOutputStream(\"encrypted.txt\");//已加密文件 System.out.println(\"开始加密。。。\"); int n=f.available()/5; byte[] b=new byte[n];//以一个字节数组的长度读取和复制 int count=0; while((count=f.read(b,0,n))!=-1) { //写入之前先加密/解密 for(int i=0;i\u003ccount;i++) { b[i]=(byte)(b[i]^pwd);// } fout.write(b,0,count); } System.out.println(\"完成加密\"); f.close(); fout.close(); // f=new FileInputStream(\"encrypted.txt\"); // fout=new FileOutputStream(\"unencrypted.txt\"); // System.out.println(\"开始解密。。。\"); // n=f.available()/5; // b=new byte[n];//以一个字节数组的长度读取和复制 // count=0; // while((count=f.read(b,0,n))!=-1) { // //写入之前先加密/解密 // for(int i=0;i\u003ccount;i++) { // b[i]=(byte)(b[i]^pwd); // } // fout.write(b,0,count); // } // System.out.println(\"完成解密\"); // f.close(); // fout.close(); } } 文件复制 package cn.lruihao.base; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileStreamCopy { public static void main(String[] args) throws IOException { int size; FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/FileStreamCopy.java\"); FileOutputStream fout=new FileOutputStream(\"copy-of-file.txt\"); System.out.println(\"总长度：\"+(size=f.available())); int n=size/10; System.out.print(\"使用单字节方法读取后：\"); for(int i=0;i\u003cn;i++) { fout.write(f.read()); } System.out.println(\"剩余长度：\"+f.available()); System.out.println(\"读取一个字节数组后：\"); byte b[]=new byte[n]; f.read(b); fout.write(b); System.out.println(\"剩余长度：\"+f.available()); System.out.println(\"读取余下数据：\"); int count=0; while((count=f.read(b,0,n))!=-1) { //System.out.println(count); fout.write(b,0,count); } System.out.println(\"剩余长度：\"+f.available()); f.close(); fout.flush(); fout.close(); } } package cn.lruihao.base; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class BufferedStreamCopy { public static void main(String[] args) throws IOException { FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/BufferedStreamCopy.java\"); FileOutputStream fout=new FileOutputStream(\"copy-of-file.txt\"); BufferedInputStream bis=new BufferedInputStream(f); BufferedOutputStream bos=new BufferedOutputStream(fout); System.out.println(\"开始复制。。。\"); int n=f.available()/5; byte[] b=new byte[n]; int count=0; while((count=bis.read(b,0,n))!=-1) { bos.write(b,0,count); } System.out.println(\"复制完成\"); bis.close(); bos.flush(); bos.close(); f.close(); fout.flush(); fout.close(); } } ","date":"2019-05-02","objectID":"/posts/byteio/:0:0","tags":["Java","Backend"],"title":"文件加密解密（字节流）","uri":"/posts/byteio/"},{"categories":["Java"],"content":"实现代码 这里的异常主要是InputMismatchException,可以直接捕获该异常，我直接捕获了父类异常。。。 package cn.lruihao.Exception; import java.util.Scanner; /** * @author 李瑞豪 * 借书系统(异常练习) */ public class ExceptionDemo { private final Book[] books = { new Book(\"数据结构\"), new Book(\"Java\"), new Book(\"php\"), new Book(\"c\") }; public static void main(String[] args) { System.out.println(\"欢迎来到借书系统！\"); ExceptionDemo jieshu= new ExceptionDemo(); jieshu.menu(); } public void menu() { System.out.println(\"输入命令：1.书名查找；\\t2.序号查找；\"); //初始化并捕获用户输入 Scanner sc = new Scanner(System.in); // 捕获异常 try { int id =sc.nextInt(); if(id==1||id==2) { inquire(id); }else { System.out.println(\"输入错误！请根据提示输入~~\");//输入非1，2的数字情况 menu(); } }catch (Exception e) {//输入字符为非数字 e.printStackTrace(); System.out.println(\"输入错误，请输入数字命令~~\"); menu(); }finally{ sc.close(); } } private void inquire(int id) { Scanner sc = new Scanner(System.in); if(id==1) { System.out.println(\"请输入要查找的书名！\"); String name=sc.nextLine(); int num=FindName(name); if(num==0?false:true) {//验证书名是否存在 存在则打印 System.out.println(\"book：\"+name+\"\\t序号：\"+num); //menu();//回到访问起点 也可以去掉终止程序 }else{ System.out.println(\"图书不存在\"); menu(); } sc.close(); }else if(id == 2) { System.out.println(\"请输入您要查找的序号：\"); int id2=sc.nextInt(); FindNum(id2); sc.close(); } } private void FindNum(int num) { try { if(num\u003e=0\u0026\u0026num\u003cbooks.length) { System.out.println(books[num].getName()); //menu();//回到访问起点 也可以去掉终止程序 }else{ System.out.println(\"图书不存在\"); menu(); } }catch (Exception e) { e.printStackTrace(); System.out.println(\"输入有误！~~\"); } } private int FindName(String name) { int num=0; for(Book i:books) { String name1=i.getName(); if(name1.equals(name)) { return num; } num++; } return 0; } } package cn.lruihao.Exception; public class Book { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public Book(String name) { this.name = name; } } 大致运行效果 ","date":"2019-05-01","objectID":"/posts/javaexception/:0:0","tags":["Java","Backend"],"title":"模拟借书系统（java异常练习）","uri":"/posts/javaexception/"},{"categories":["Python"],"content":" Python 二维码生成器是github上@sylnsfar开源的一个python生成二维码工具。有python,网页及exe版本，详见sylnsfar/qrcode，本文主要介绍记录一下python版本使用。exe可以去项目开源地址下载，公众号文章后台回复关键词“qrcode”获取链接。 可生成普通二维码、带图片的艺术二维码（黑白与彩色）、动态二维码（黑白与彩色）。 ","date":"2019-04-27","objectID":"/posts/qrcode/:0:0","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"示例 from MyQR import myqr import os version, level, qr_name = myqr.run( words='https://lruihao.cn', version=1, level='H', picture='2.jpg', colorized=True, contrast=1.0, brightness=1.0, save_name=None, save_dir=os.getcwd() ) # help(myqr) # https://github.com/sylnsfar/qrcode/ ''' Positional parameter words: str # 链接或者文字 Optional parameters version: int, from 1 to 40 # 控制边长 level: str, just one of ('L','M','Q','H') # 控制纠错水平，从左到右依次升高。 picutre: str, a filename of a image # 图片，需在同路径,默认None colorized: bool # 是否彩色 默认False constrast: float # 对比度 默认1.0 brightness: float # 亮度 默认1.0 save_name: str, the output filename like 'example.png' #控制文件名，默认None,'qrcode.png' save_dir: str, the output directory # 储存路径 ''' ","date":"2019-04-27","objectID":"/posts/qrcode/:1:0","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"安装 # 通过 pip pip(3) install myqr(or MyQR) ","date":"2019-04-27","objectID":"/posts/qrcode/:2:0","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"使用方法 ","date":"2019-04-27","objectID":"/posts/qrcode/:3:0","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"命令行方式 （提示：如果你尚未安装 MyQR ，以下内容请使用python(3) myqr.py 而非myqr 。） # 概括 myqr Words [-v {1,2,3,...,40}] [-l {L,M,Q,H}] [-n output-filename] [-d output-directory] [-p picture_file] [-c] [-con contrast] [-bri brightness] 普通二维码 介绍了 Words, -v, -l, -n, -d 艺术二维码 介绍了 -p, -c, -con, -bri 动态GIF二维码 介绍了动态的生成方法和注意点 普通二维码 #1 Words myqr https://github.com 在命令后输入链接或者句子作为参数，然后在程序的当前目录中产生相应的二维码图片文件，默认命名为 “qrcode.png”。 #2 -v, -l myqr https://github.com -v 10 -l Q 默认边长是取决于你输入的信息的长度和使用的纠错等级； 而默认纠错等级是最高级的H。 自定义：如果想要控制边长和纠错水平就使用 -v 和 -l 参数。 -v 控制边长，范围是1至40，数字越大边长越大； -l 控制纠错水平，范围是L、M、Q、H，从左到右依次升高。 #3 -n, -d myqr https://github.com -n github_qr.jpg -d .../paths/ 默认输出文件名是“ qrcode.png “，而默认存储位置是当前目录。 自定义：可以自己定义输出名称和位置。注意同名文件会覆盖旧的。 -n 控制文件名，格式可以是 .jpg， .png ，.bmp ，.gif ； -d 控制位置。 艺术二维码 #1 -p myqr https://github.com -p github.jpg 参数-p 用来将QR二维码图像与一张同目录下的图片相结合，产生一张黑白图片。 #2 -c myqr https://github.com -p github.jpg -c 加上参数 -c 可以使产生的图片由黑白变为彩色的。 #3 -con, -bri myqr https://github.com -p github.jpg [-c] -con 1.5 -bri 1.6 参数-con 用以调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0。 参数 -bri 用来调节图片的亮度，其余用法和取值与 -con 相同。 动态GIF二维码 动态二维码与上述的带图片的二维码的生成方法没什么区别，你只要采用 .gif 格式的图片即可生成黑白或者彩色的动态二维码。但注意如果使用了 -n 参数自定义输出的文件名，切记其格式也必须是 .gif 格式。 ","date":"2019-04-27","objectID":"/posts/qrcode/:3:1","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"作为导入文件 # 安装模块后 from MyQR import myqr version, level, qr_name = myqr.run( words, version=1, level='H', picture=None, colorized=False, contrast=1.0, brightness=1.0, save_name=None, save_dir=os.getcwd() ) 以下各个参数已经在上文命令行方式有所介绍 # help(myqr) Positional parameter words: str Optional parameters version: int, from 1 to 40 level: str, just one of ('L','M','Q','H') picutre: str, a filename of a image colorized: bool constrast: float brightness: float save_name: str, the output filename like 'example.png' save_dir: str, the output directory ","date":"2019-04-27","objectID":"/posts/qrcode/:3:2","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"使用提示 请采用正方形或近似正方形的图片 建议在图片尺寸大的时候使用 -v 的值也应该适当变大。 ","date":"2019-04-27","objectID":"/posts/qrcode/:4:0","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"可用字符 数字 0 到 9 大小写的英文字母 常用英文标点符号和空格 · , . : ; + - * / \\ ~ ! @ # $ % ^ \u0026 ` ' = \u003c \u003e [ ] ( ) ? _ { } | and (space) ","date":"2019-04-27","objectID":"/posts/qrcode/:5:0","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"依赖库 pillow numpy imageio ","date":"2019-04-27","objectID":"/posts/qrcode/:6:0","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["Python"],"content":"运行环境 Linux, Python 3 Windows, Python 3 Mac, Python 3 ","date":"2019-04-27","objectID":"/posts/qrcode/:7:0","tags":["pillow","numpy","imageio","Python","Backend"],"title":"用 MyQR 制作专属动态二维码(py和exe版本)","uri":"/posts/qrcode/"},{"categories":["生活随笔"],"content":" 时间过得真快，一下从大一到了大三，马上就要实习毕业等等了。 Success 富士康在学校有一个春招的机会，我和朋友抱着侥幸的心理去试了试。 虽然深知自己还身有很多缺点，但是不面试不知道，一面试都暴露出来了，以下记录一下自己的不足之处： php和sql的经典组合虽然有所接触了解，但是确实什么都会，得花时间学 html/css等虽然平时折腾博客这些应用的比较多，但是今天竟然紧张地忘记了margin和padding都不会写了 如上一条，公众表现能力有待加强。正如当今“酒香也怕巷子深”，何况“不香”。 惊喜的事说来就来，本来知道自己这么多缺点，这么菜后，觉得这个实习的offer是没戏了，没想到下午技术主管微信发来消息，说录用了。当场懵逼，受宠若惊的感觉！非常谢谢面试官老师！ 无论生活还是学习，希望以后的自己一定要保持一颗谦逊爱学的心，早日实现全栈工程师的梦想，还有早点存钱把大学学费的贷款还掉！ ","date":"2019-04-24","objectID":"/posts/1thintervivew/:0:0","tags":["面试"],"title":"第一次面试经历","uri":"/posts/1thintervivew/"},{"categories":["Python"],"content":" 以下程序对该网址内的手写体图片进行爬取！这个手写体是我在手机上通过《手迹造字》app书写的，大概6886个字符，历时两年多，目前仍在修改中。字体效果查看 思路设计 通过观察目标网页中字符图片的链接，很容易发现每个字符图片的直链是由两部分组成。 固定链接 图片文件编号 其中固定连接为https://image.xiezixiansheng.com/users/2010/700/unzip/579767/,图片文件为xxxxx.png@50q，如果去掉@50q，获取到的图片就是透明背景的不然就是白色背景。然后发现编号大多是5位数的形式，但是还有一些是4位的，甚至还有2-3位的数字。仔细看看127前的编号都是一些国际符号诸如英文和数字等。比对一下发现正是ASCII码对应的命名方式。可想而知中文自然也是通过编码来命名的。一个标准的字库文件至少包含6763个汉字，也就是我书写的这个GB2312-80,范围： 0xA1A1 - 0xFEFE，其中汉字范围： 0xB0A1 - 0xF7FE。两个16进制位对应一个字节，一个汉字至少由两个字节组成，这样理解，范围自然是4个16进制位。所以转换成10进制，范围大致在65278以下。要了解更加具体一点的范围还需要去查一下汉字编码的分区等。这里暂时不必了解，因为本来就打算暴力下载。 说了这么多，既然图片链接这么简单，所以我是想暴力遍历，搜索图片，判断链接状态码，然后下载图片。 源码设计 大致分为三个范围吧 英文字符 中文符号 汉字范围 我主要分这几个区间查找 33 ~ 126 8212 ~ 8243 12289 ~ 12305 19968 ~ 40864 65281 ~ 65509 磨刀不误砍柴工，分析观察了这么久，终于可以运行程序了，F5 后就静静等待吧，可以去看看 java，或者打一把王者hhhhh! import os import requests path=\"C:\\\\Users\\\\李瑞豪\\\\Desktop\\\\MMT_images\\\\\" #下载路径： 绝对或者相对路径比如./image/ os.makedirs(path+\"0\\\\\", exist_ok=True) # 创建文件夹 os.makedirs(path+\"1\\\\\", exist_ok=True) # 下载图片 def urllib_download(url,num): # (下载链接,图片编号) from urllib.request import urlretrieve urlretrieve(url,path+num+\".png\") # 判断状态码 def get_status(url): r = requests.get(url, allow_redirects = False) return r.status_code def main(): BASE_URL = \"https://image.xiezixiansheng.com/users/2010/700/unzip/579767/\" n=33 total=0 print(\"正在爬取第1张图片!\") while n \u003c 65510: #分段爬取，不然会超时！！！# 33 ~ 126 # 8212 ~ 8243 # 12289 ~ 12305 # 19968 ~ 40864 # 65281 ~ 65509 if n == 127: n = 8212 continue elif n == 8244: n = 12289 continue elif n ==12306: n = 19968 continue elif n == 40865: n = 65281 continue # for n in range(37341,40865): num = str(n) IMAGE_URL = BASE_URL+num+\".png\" # xxx.png是透明背景，xxx.png@50q是白色背景，分别存放在0，1文件夹 p是中小 w是小图 if(get_status(IMAGE_URL)==200): # 同时下载透明和白色背景的图片 total+=1 urllib_download(IMAGE_URL,\"0\\\\\"+num) IMAGE_URL += \"@50q\" urllib_download(IMAGE_URL,\"1\\\\\"+num) print(\"Downloaded \"+num+\".png\") print(\"正在爬取第\",total+1,\"张图片!\") n+=1 print(\"\\n爬取完毕！共爬取\",total,\"张图片!\") print(\"图片存放路径：\"+path) print(\"作者博客：lruihao.cn\") if __name__==\"__main__\": main(); 爬取过程及结果 文件夹左下角数目变化 危險 说实话看着控制台不停地输出提示信息有没有很爽，对于强迫症来说真的是很治愈了！但是爬取第6042张图片的时候，我打开了一下目标网页发现无法加载图片了，就想这应该也算是一次Dos攻击了吧！打开控制台果然停了，相当于访问了近两万次！唉，还是太暴力了！！还差800多张，只好又重新接着写上次的位置爬!不慎造成目标网站服务器压力，实在对不起！ 一个半小时左右后终于下载完了，一共是6886张；程序是同时下载了透明和白色背景的图片的！分别在0,1子文件夹！ 其他思路 模拟浏览器载入 html 文件，获取源码，查找到所有\u003cimg\u003e标签内链接，必要时配合正则表达式，然后下载图片。 ","date":"2019-04-22","objectID":"/posts/mmtimgpy/:0:0","tags":["Python","脚本","Backend"],"title":"python 爬取网站图片（图片链接相似）","uri":"/posts/mmtimgpy/"},{"categories":["Python"],"content":" 文中涉及的图片涉及个人隐私，仅做举例，请勿传播 查看微信好友男女比例 查看好友地区分布 群性别统计 前期准备 wxpy pyecharts（百度echarts） 查看微信好友男女比例 from wxpy import * from pyecharts import Pie bot = Bot(cache_path = True) #定义一个微信机器人 friends = bot.friends(update=False) #获取更新好友列表 male = female = other = 0 for i in friends[1:]: #[1:]自己是第一个，排除掉 sex = i.sex if sex == 1: male += 1 elif sex == 2: female += 1 else: other += 1 total = len(friends[1:]) #计算总数 #下面为分析 attr = [\"男性\",\"女性\",\"其他\"] v1 = [float(male),float(female),float(other)] pie = Pie(\"饼图-圆环图示例\", title_pos='center') pie.add(\"\", attr, v1, radius=[40, 75], label_text_color=None, is_label_show=True, legend_orient='vertical', legend_pos='left') pie.render(\"sex.html\") 查看好友地区分布 from wxpy import * from pyecharts import Map #因为获取的列表城市都没有带市字，而pyecharts需要带个市字 b = '市' def s(x): return x+b #只提取湖南的 bot = Bot(cache_path = True) friends = bot.friends(update=False).search(province = '湖南') citys = [] for f in friends : city = f.city citys.append(city) r = map(s,citys) cityss = list(r) #为城市计数 a = {} for i in cityss: a[i] = cityss.count(i) a.pop('市') #把字典进行有序拆分为2个列表 attrs = [] values = [] for value, attr in a.items(): values.append(attr) attrs.append(value) #开始绘图 map = Map(\"湖南地图示例\", width=1200, height=600) map.add(\"\", attrs, values, maptype='湖南', is_visualmap=True, visual_text_color='#000') map.render(\"city.html\") 以上参考简书陈思煜 统计所有群男女数目 统计结果会自动发送到所有群聊 男女人数和不一定等于总数（有些人不显示性别） #encoding=utf-8 from wxpy import * import numpy def removeAll(the_list, val): return [value for value in the_list if value != val] def stats_text(target_group, group_name): print(group_name + \"群共有：\" + str(len(target_group)) + \"人，其中：\") all_stats_text = [] all_dict = {} # 乱序先整理一份省份 + 地点的列表 for user in target_group.members: trimed_data = user.province.replace(' ', '') + user.city.replace(' ', '') if trimed_data != '': all_stats_text.append(trimed_data) # 计数 for data in all_stats_text: if all_stats_text.count(data) != 0: all_dict[data] = all_stats_text.count(data) all_stats_text = removeAll(all_stats_text, data) final_dict = {} for i in sorted(all_dict.keys()): final_dict[i] = all_dict[i] return final_dict def stats_sex(target_group): male = 0 female = 0 other = 0 for user in target_group.members: if user.sex == 1: male = male + 1 if user.sex == 2: female = female + 1 else: other = other + 1 print(\"男的有：\" + str(male) + \"人\") print(\"女的有：\" + str(female) + \"人\") msg = \"男的有：\" + str(male) + \"人\\n\" + \"女的有：\" + str(female) + \"人\\n\" return msg bot = Bot() target_group = bot.groups(update=True, contact_only=False) for curr_group in target_group: # 小于 10 人的群过滤掉 if len(curr_group) \u003c 10: continue curr_group.update_group(members_details=True) print(curr_group.name + \"一共有：\" + str(len(curr_group)) + \"人\\n\") msg = stats_sex(curr_group) curr_group.send(curr_group.name + \"群，一共有：\" + str(len(curr_group)) + \"人\\n\" + msg) ","date":"2019-04-20","objectID":"/posts/wxpy1/:0:0","tags":["Python","wxpy","pyecharts","jieba","他山之石"],"title":"python玩微信：初探wxpy","uri":"/posts/wxpy1/"},{"categories":["Python"],"content":" Python通过wxpy登录微信网页版，爬取好友所有头像并拼接成一张大图。然后删除所有子图。(注释相关代码可以不删除) 文中涉及的图片涉及个人隐私，仅做举例，请勿传播 文中编码由Sunbelife提供，来自他的同名微信公众号，本博仅用于学习，侵删 预览 依赖 wxpy（Pythone登录微信） pillow（拼接头像） os（文件夹操作） math（数学计算） wxpy: wxpy 在 itchat 的基础上，通过大量接口优化提升了模块的易用性，并进行丰富的功能扩展。 PIL： Python Imaging Library，已经是Python平台事实上的图像处理标准库了。PIL功能非常强大，但API却非常简单易用。由于PIL仅支持到Python 2.7，加上年久失修，于是一群志愿者在PIL的基础上创建了兼容的版本，名字叫Pillow，支持最新Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用Pillow。 安装 pip install -U wxpy -i \"https://pypi.doubanio.com/simple/\" pip install pillow 运行 如果在Python IDE 运行出错，可能是因为微信好友的id是特殊字符，在IDE打印出错，注释掉代码36行即可。 from wxpy import * import math import PIL.Image as Image import os import sys import shutil # ## 获取文件所在的绝对路径 def get_dir(sys_arg): sys_arg = sys_arg.split(\"/\") dir_str = \"\" count = 0 for cur_dir in sys_arg: if count == 0: count = count + 1 if count == len(sys_arg): break dir_str = dir_str + cur_dir + \"/\" count = count + 1 return dir_str curr_dir = get_dir(sys.argv[0]) bot = Bot() # 机器人账号自身 myself = bot.self my_friends = bot.friends(update=True) if not os.path.exists(curr_dir + \"group-images/\"): os.mkdir(curr_dir + \"group-images/\") count = 0 for friend in my_friends: print(friend.nick_name) friend.get_avatar(curr_dir + \"group-images/\" + str(count) + \".jpg\") count = count + 1 # 获取下载的头像文件 ls = os.listdir(curr_dir + 'group-images') # 去除非 .jpg 文件 for filter_ls in ls: if \".jpg\" in filter_ls: continue else: ls.remove(filter_ls) # 排序 ls.sort(key=lambda x:int(x[:-4])) # 头像墙尺寸 image_size = 2560 each_size = math.floor(image_size/math.floor(math.sqrt(len(ls)))) x_lines = math.ceil(math.sqrt(len(ls))) y_lines = math.ceil(math.sqrt(len(ls))) image = Image.new('RGB', (each_size * x_lines, each_size * y_lines)) x = 0 y = 0 for file_names in ls: try: img = Image.open(curr_dir + \"group-images/\" + file_names) print(\"正在处理\" + file_names.split('.jpg')[0] + \"/\" + str(len(ls))) except IOError: continue else: img = img.resize((each_size, each_size)) image.paste(img, (x * each_size, y * each_size)) x += 1 if x == x_lines: x = 0 y += 1 img = image.save(curr_dir + \"all.jpg\") try: shutil.rmtree(curr_dir + \"group-images/\") print(\"收尾，清理临时文件\") except FileNotFoundError: print(\"没什么好删的\") print(\"！！！\\n生成完毕了，放在了目录\" + curr_dir + \"，去看看吧。\") print(\"工具作者：@Sunbelife（新浪微博）\") print(\"公众号：Sunbelife\") print(\"感谢使用\") print(\"v1.2\") print(\"2019.4.18\") 群友全家福 修改11行群名称 import itchat import math import PIL.Image as Image import os import shutil # 变量 itchat.auto_login(hotReload=True,enableCmdQR=False) roomslist = itchat.get_chatrooms(update=True)[0:] itchat.dump_login_status() # 显示所有的群聊信息，默认是返回保存到通讯录中的群聊 myroom=itchat.search_chatrooms(name=u'绥宁一中高396班') #群聊名称 gsq=itchat.update_chatroom(myroom[0]['UserName'], detailedMember=True) num = 0 if not os.path.exists(\"./group-images/\"): os.mkdir(\"./group-images/\") for i in gsq['MemberList']: print(i[\"UserName\"]) img = itchat.get_head_img(userName=i[\"UserName\"],chatroomUserName=myroom[0]['UserName']) fileImage = open(\"./group-images/\" + str(num) + \".jpg\",'wb') fileImage.write(img) fileImage.close() num += 1 ls = os.listdir('./group-images') each_size = int(math.sqrt(float(640*640)/len(ls))) lines = int(640/each_size) image = Image.new('RGBA', (640, 640)) x = 0 y = 0 for i in range(0,len(ls)+1): try: img = Image.open(\"./group-images/\" + str(i) + \".jpg\") except IOError: print(\"Error\") else: img = img.resize((each_size, each_size), Image.ANTIALIAS) image.paste(img, (x * each_size, y * each_size)) x += 1 if x == lines: x = 0 y += 1 image.save(\"all.png\") shutil.rmtree(\"./group-images\") 加个列表，加个循环实现自动爬取所有群聊头像并发送 import itchat import math import PIL.Image as Image import os import shutil # 变量 itchat.auto_login(hotReload=True,enableCmdQR=False) roomslist = itchat.get_chatrooms(update=True)[0:] itchat.dump_login_status() # 显示所有的群聊信息，默认是返回保存到通讯录中的群聊 for room in roomslist: print(room['UserName']) gsq=itchat.update_chatroom(room['UserName'], detailedMember=True) num = 0 if not os.path.exists(\"./group-images/\"): os.mkdir(\"./group-images/\") for i in gsq['MemberList']: print(i[\"UserName\"]) img = itchat.get_he","date":"2019-04-20","objectID":"/posts/wximgpy/:0:0","tags":["wxpy","pillow","Python","Backend"],"title":"基本python实现的爬取微信好友头像，并拼接成大图","uri":"/posts/wximgpy/"},{"categories":["Java"],"content":" 之所以用记事本来写不是为了装X或者什么的。反而恰恰是返璞归真，因为在用java语言进行程序开发时，首先是以纯文本的方式编写所有的java源程序，并保存成以.java为后缀的文件；然后将这些源程序用javac编译成.class后缀名的字节代码文件；字节代码不是被本地处理器执行的代码，而是能够被java虚拟机（JVM）执行的代码。最后用java运行工具在JVM执行java应用程序。 由于JVM可以运行在不同的操作系统上，因此同一个字节代码文件可以跨平台运行。 javac java 编写java 用记事本编辑java文件，并且把后缀改成.java，文件名和类名要一样。 public class HelloWorld{ public static void main(String[] args){ System.out.println(\"Hello World!\"); } } 打开cmd ","date":"2019-04-19","objectID":"/posts/hellojava/:0:0","tags":["Java","Backend"],"title":"用记事本编写第一个java程序","uri":"/posts/hellojava/"},{"categories":["Java"],"content":"邮箱 import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexDemo { public static void main(String[] args) { // Pattern类 正则表达式的编译表示。 Pattern pattern = Pattern.compile(\"^[a-zA-Z0-9_!#$%\u0026'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$\"); String[] emails = {\"admin@lruihao.cn\", \"lruihao.cn\"}; for (String email : emails) { //Matcher 通过解释Pattern对字符序列执行匹配操作的引擎 Matcher matcher = pattern.matcher(email); System.out.println(email + \"匹配结果：\" + matcher.matches()); } } } admin@lruihao.cn匹配结果：true lruihao.cn匹配结果：false 电话 package base; import java.util.Scanner; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexTest { public static void main(String[] args) { Pattern patter=Pattern.compile(\"^[1][3,4,5,7,8][0-9]{9}$\"); Scanner sc=new Scanner(System.in); String telnum=sc.nextLine(); sc.close(); Matcher matcher=patter.matcher(telnum); System.out.println(telnum+\"匹配结果： \"+matcher.matches()); } } /** * 获取当前的httpSession * @return */ public static HttpSession getSession() { return getRequest().getSession(); } /** * 手机号验证 * @param str * @return 验证通过返回true */ public static boolean isMobile(final String str) { Pattern p = null; Matcher m = null; boolean b = false; p = Pattern.compile(\"^[1][3,4,5,7,8][0-9]{9}$\"); // 验证手机号 m = p.matcher(str); b = m.matches(); return b; } /** * 电话号码验证 * @param str * @return 验证通过返回true */ public static boolean isPhone(final String str) { Pattern p1 = null, p2 = null; Matcher m = null; boolean b = false; p1 = Pattern.compile(\"^[0][1-9]{2,3}-[0-9]{5,10}$\"); // 验证带区号的 p2 = Pattern.compile(\"^[1-9]{1}[0-9]{5,8}$\"); // 验证没有区号的 if (str.length() \u003e 9) { m = p1.matcher(str); b = m.matches(); } else { m = p2.matcher(str); b = m.matches(); } return b; } 身份证 /* 身份证正则表达式16或18 */ public static final String IDCARD=\"((11|12|13|14|15|21|22|23|31|32|33|34|35|36|37|41|42|43|44|45|46|50|51|52|53|54|61|62|63|64|65)[0-9]{4})\" + \"(([1|2][0-9]{3}[0|1][0-9][0-3][0-9][0-9]{3}\" + \"[Xx0-9])|([0-9]{2}[0|1][0-9][0-3][0-9][0-9]{3}))\"; ","date":"2019-04-18","objectID":"/posts/regexdemo/:0:0","tags":["regex","Java"],"title":"java正则表达式练习","uri":"/posts/regexdemo/"},{"categories":["Java"],"content":"StringBuffer/StringBuilder(掌握) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:0:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"StringBuffer是线程安全的可变字符串。 StringBuilder是线程不安全的可变字符串。 和StringBuffer的功能一样。就是效率高一些，但是不安全。 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:1:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"构造方法： StringBuffer sb = new StringBuffer(); StringBuffer sb = new StringBuffer(50); StringBuffer sb = new StringBuffer(“hello”); ","date":"2019-04-14","objectID":"/posts/stringbuffer/:2:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"成员方法：(自己补齐方法和意思) 添加功能 public StringBuffer append(String str):追加字符串 public StringBuffer insert(int offset,String str):在指定位置插入字符串 删除功能 public StringBuffer deleteCharAt(int index):删除指定位置字符 public StringBuffer delete(int start,int end):删除从指定开始到结束的字符，左闭右开 替换功能 public StringBuffer replace(int start,int end,String str):以字符串替代从指定开始到结束的字符 反转功能 public StringBuffer reverse():反转 截取功能 public String substring(int start):从指定索引到末尾的字符串 public String substring(int start,int end):从指定索引开始到指定索引结束的字符串 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:3:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"案例： String和StringBuffer的相互转换,通过构造即可。 把数组转成指定的字符串格式 把字符串反转 判断一个字符串是否是对称字符串 数组高级部分(理解) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:4:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"排序 冒泡排序 相邻元素，两两比较，大的往后放。 public static void bubbleSort(int[] arr) { for(int x=0; x\u003carr.length-1; x++) { for(int y=0; y\u003carr.length-1-x; y++) { if(arr[y]\u003earr[y+1]) { int temp = arr[y]; arr[y] = arr[y+1]; arr[y+1] = temp; } } } } 选择排序 从0开始，依次和后面的比较，小的往前放。 public static void selectSort(int[] arr) { for(int x=0; x\u003carr.length-1; x++) { for(int y=x+1; y\u003carr.length; y++) { if(arr[y] \u003c arr[x]) { int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; } } } } public static void selectSort(int[] a) { int min=0; int temp=0; if((a==null)||(a.length==0)) return; for(int i=0;i\u003ca.length-1;i++) { min=i;//无序区的最小数据数组下标 for(int j=i+1;j\u003ca.length;j++) { //在无序区中找到最小数据并保存其数组下标 if(a[j]\u003ca[min]) { min=j; } } //将最小元素放到本次循环的前端 temp=a[i]; a[i]=a[min]; a[min]=temp; } } ","date":"2019-04-14","objectID":"/posts/stringbuffer/:5:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"查找 基本查找 数组无序 二分查找 数组有序 public static int getIndex(int[] arr,int value) { int max = arr.length-1; int min = 0; int mid = (max+min)/2; while(arr[mid] != value) { if(arr[mid] \u003e value) { max = mid - 1; }else if(arr[mid] \u003c value) { min = mid + 1; } if(max \u003c min) { return -1; } mid = (max+min)/2; } return mid; } Arrays工具类(掌握) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:6:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"Arrays是针对数组进行操作的工具类，提供了排序和查找等功能 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:7:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"成员方法：(自己补齐方法和意思) 把数组转成字符串 public static String toString():将任意类型数据转换成字符串 排序 public static void sort()： 二分查找 public static int binarySearch(int[] arr,int key) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:8:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"案例： 把字符串中的字符进行排序 基本类型包装类(掌握) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:9:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"为了让我们对基本类型进行更多的操作，java针对每种基本类型提供了对应的包装类类型。 ","date":"2019-04-14","objectID":"/posts/stringbuffer/:10:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"分别是哪些呢? byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 特殊： void Void ","date":"2019-04-14","objectID":"/posts/stringbuffer/:11:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"Integer 构造方法 Integer i = new Integer(100); Integer i = new Integer(“100”); 成员方法(自己补齐方法和意思) 把字符串转成int类型 String-\u003eint: Integer.parseInt() int-\u003eString: String.valueOf()或Integer.toString() JDK5的新特性 自动装箱： int --\u003e Integer //Integer.valueOf() 自动拆箱： Integer --\u003e int //Integer.intValue() 请解释： Integer i = 100; i+=200; System.out.println(i); byte缓存池面试题 byte,short,char—\u003e小于127，否则报-6的错误(查看JDK) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:12:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["Java"],"content":"Character 构造方法 Character ch = new Character(‘a’); 成员方法(自己补齐方法和意思) 判断字符是否是大写字母 public boolean isUpperCase(char ch) 判断字符是否是小写字母 public boolean isLowerCase(Char ch) 判断字符是否是数字字符 public boolean isDigit(Char ch) 把字符转成大写 public Char toUpperCase(Char ch) 把字符转成小写 public Char toLowerCase(Char ch) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:13:0","tags":["StringBuffer","sort","Java","Backend"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["others"],"content":" win10或者win8系统在使用起步科技WeX5这款IDE工具，在新建w文件或者新建本地应用等时候，会出现不能显示完全的问题，下面是解决办法： 确认是否把操作系统的字体调整为非100%了 把studio\\dropins\\studio-app2\\plugins\\plugin\\lib\\cef1\\chromium.jar这个jar包复制到studio\\dropins\\studio-app2\\plugins\\plugin\\lib下，重启studio ","date":"2019-04-13","objectID":"/posts/wex5/:0:0","tags":["Wex5","Frontend"],"title":"WeX5在win8或者win10操作系统studio中新建.w向导或其他的编辑窗口显示不全问题","uri":"/posts/wex5/"},{"categories":["ACM"],"content":"题目大意： 题目链接 老鼠有M磅猫食 ,有N个房间 ,每个房间前有一只猫 ,房间里有老鼠最喜欢的食品 J[i] ,若要得到房间的食物 ,必须付出相应的猫食F[i] ,当然这只老鼠没必要每次都付出所有的F[i]，若它付出F[i]的a%， 则得到J[i]的a%，求老鼠能吃到的最多的食物。 ","date":"2019-04-12","objectID":"/posts/hdu1009/:0:0","tags":["ACM","贪心","HDU"],"title":"HDU 1009 FatMouse' Trade(贪心)","uri":"/posts/hdu1009/"},{"categories":["ACM"],"content":"Sample Input 5 3 7 2 4 3 5 2 20 3 25 18 24 15 15 10 -1 -1 ","date":"2019-04-12","objectID":"/posts/hdu1009/:1:0","tags":["ACM","贪心","HDU"],"title":"HDU 1009 FatMouse' Trade(贪心)","uri":"/posts/hdu1009/"},{"categories":["ACM"],"content":"Sample Output 13.333 31.500 分析 老鼠要用最少的猫粮来换取最多的食物 ,也就是J[i]/F[i]越大越好 ,所以按照J[i]/F[i]进行降序排列 ,然后依次用猫粮来换取食物 ,当所剩下的猫粮不足以完全换取食物 ,能换多少是多少。 #include\u003cstdio.h\u003e#include\u003calgorithm\u003eusing namespace std; struct node{ double j; double f; double s; }a[1005]; int cmp(node x,node y){ return x.s\u003ey.s; } int main(){ int m,n,i; while(scanf(\"%d%d\",\u0026m,\u0026n)\u0026\u0026(m!=-1\u0026\u0026n!=-1)){ memset(a,0,sizeof(a)); for(i=0;i\u003cn;i++){ scanf(\"%lf%lf\",\u0026a[i].j,\u0026a[i].f); a[i].s=a[i].j/a[i].f; } sort(a,a+n,cmp); double sum=0; for(i=0;i\u003cn;i++){ if(m\u003e=a[i].f){ sum+=a[i].j; m-=a[i].f; }else{ sum+=a[i].s*m; m=0; } if(m\u003c=0) break; } printf(\"%.3lf\\n\",sum); } return 0; } ","date":"2019-04-12","objectID":"/posts/hdu1009/:2:0","tags":["ACM","贪心","HDU"],"title":"HDU 1009 FatMouse' Trade(贪心)","uri":"/posts/hdu1009/"},{"categories":["Nodejs"],"content":" 想趴几本金庸小说的做成电子书自己阅读，在博客上尝试了一下整理了6本中短篇小说就开始感觉博客臃肿，于是找到gitbook前来一试。 写完这篇文章开始实际操作，我发现还不如用hexo来写小说，遂放弃！Gitbook用来写相关文档介绍还差不多。 GitBook简介 GitBook官网 GitBook文档 Gitbook的作用和Hexo有点像，也是把md渲染成html,也见到有人用这个来写博客的。 GitBook是一个基于 Node.js 的命令行工具，可使用 Github/Git 和 Markdown 来制作精美的电子书，GitBook 并非关于 Git 的教程。 GitBook支持输出多种文档格式： 静态站点：GitBook默认输出该种格式，生成的静态站点可直接托管搭载Github Pages服务上； PDF：需要安装gitbook-pdf依赖； eBook：需要安装ebook-convert； 单HTML网页：支持将内容输出为单页的HTML，不过一般用在将电子书格式转换为PDF或eBook的中间过程； JSON：一般用于电子书的调试或元数据提取。 使用GitBook制作电子书，必备两个文件：README.md和SUMMARY.md GitBook安装步骤 ","date":"2019-04-04","objectID":"/posts/gitbookuse/:0:0","tags":["gitbook","Nodejs","Backend"],"title":"GitBook 使用教程","uri":"/posts/gitbookuse/"},{"categories":["Nodejs"],"content":"安装node.js GitBook是一个基于Node.js的命令行工具，下载安装Node.js(我以前搭建hexo的文章里也有介绍)，安装完成之后，你可以使用下面的命令来检验是否安装成功。 node -v ","date":"2019-04-04","objectID":"/posts/gitbookuse/:1:0","tags":["gitbook","Nodejs","Backend"],"title":"GitBook 使用教程","uri":"/posts/gitbookuse/"},{"categories":["Nodejs"],"content":"安装GitBook npm install gitbook-cli -g 检验是否安装成功 gitbook -V 参照GitBook安装文档 ","date":"2019-04-04","objectID":"/posts/gitbookuse/:2:0","tags":["gitbook","Nodejs","Backend"],"title":"GitBook 使用教程","uri":"/posts/gitbookuse/"},{"categories":["Nodejs"],"content":"gitbook初始化 和hexo init类似，GitBook准备工作做好之后，我们进入一个你要写书的目录（比如新建mybook文件夹），输入如下命令初始化 gitbook init 初始化后可以看到他会创建README.md和SUMMARY.md 这两个文件，README.md应该不陌生，就是说明文档，而SUMMARY.md其实就是书的章节目录，其默认内容如下所示： # Summary * [Introduction](README.md) ","date":"2019-04-04","objectID":"/posts/gitbookuse/:3:0","tags":["gitbook","Nodejs","Backend"],"title":"GitBook 使用教程","uri":"/posts/gitbookuse/"},{"categories":["Nodejs"],"content":"启动服务器 和hexo serve类似，我们使用gitbook serve命令，然后在浏览器地址栏中输入侧http://localhost:4000便可预览书籍。 运行该命令后会在书籍的文件夹中生成一个_book文件夹，里面的内容即为生成的html文件。 也可以修改端口 gitbook serve --port 5000 我们可以使用gitbook build命令来生成网页而不开启服务器。这个类似于 hexo 的hexo g命令。 当然，build 命令可以指定路径： gitbook build [书籍路径] [输出路径] 你还可以生成 PDF,epub,mobi 格式的电子书： gitbook pdf ./ ./mybook.pdf gitbook epub ./ ./mybook.epub gitbook mobi ./ ./mybook.mobi 如果生成不了，你可能还需要安装一些工具，比如 ebook-convert。或者在 Typora 中安装 Pandoc 进行导出。 目录结构 . ├── book.json ├── README.md ├── SUMMARY.md ├── chapter-1/ | ├── README.md | └── something.md └── chapter-2/ ├── README.md └── something.md ","date":"2019-04-04","objectID":"/posts/gitbookuse/:4:0","tags":["gitbook","Nodejs","Backend"],"title":"GitBook 使用教程","uri":"/posts/gitbookuse/"},{"categories":["Nodejs"],"content":"book.json 该文件主要用来存放配置信息。 ","date":"2019-04-04","objectID":"/posts/gitbookuse/:5:0","tags":["gitbook","Nodejs","Backend"],"title":"GitBook 使用教程","uri":"/posts/gitbookuse/"},{"categories":["Nodejs"],"content":"SUMMARY.md 这个文件主要决定GitBook的章节目录，它通过Markdown中的列表语法来表示文件的父子关系。 ","date":"2019-04-04","objectID":"/posts/gitbookuse/:6:0","tags":["gitbook","Nodejs","Backend"],"title":"GitBook 使用教程","uri":"/posts/gitbookuse/"},{"categories":["Nodejs"],"content":"更多 更多详情介绍 ","date":"2019-04-04","objectID":"/posts/gitbookuse/:7:0","tags":["gitbook","Nodejs","Backend"],"title":"GitBook 使用教程","uri":"/posts/gitbookuse/"},{"categories":["linux"],"content":" 一直都想在自己电脑上搭建一个网站或者把自己的电脑做成服务器，今天终于简单实现了。还有很多知识需要学习，简单记录一下。 搭建环境 我的电脑是ubuntu+windows双系统的，所以我先在ubuntu上面装了一个宝塔面板，方便通过web管理电脑，宝塔安装好后安装相关的环境mysql,php,nginx等。我们现在只能通过本地ip127.0.0.1:8888访问面板。 ngrok穿透 去ngrok注册登录，购买隧道（有免费的），然后绑定端口，绑定域名，这里我们拿端口8888和域名test.lruihao.cn做实验，也就是宝塔面板的端口，这样我们就可以透过域名远程访问本地服务器，这样是不是开始有云服务器的感觉了。然后宝塔面板设置也绑定好域名test.lruihao.cn,dns服务商那里做好相应的解析。 然后在ngrok那里下载sunny客户端文件，我们是ubuntu选择linux-64bits版本。解压后在ubuntu打开终端进入sunny文件目录，权限给到755，运行命令./sunny clientid xxxxxxx 后面的你的隧道订单的id。 现在就可以通过互联网访问我的ubuntu服务器了。 搭建网站 前面两步搞定，搭建网站就没问题了。 我们只要把网站的端口按第二步的在ngrok设置好就可以穿透了。 注意 访问本地网站的必要条件是你的电脑得是开机状态而且有网络。 ","date":"2019-04-03","objectID":"/posts/ngrok/:0:0","tags":["ngrok","linux","总结","宝塔面板","server","ubuntu"],"title":"本地搭建网站服务器并穿透内网","uri":"/posts/ngrok/"},{"categories":["HTML","CSS"],"content":" 原文链接 “卓越班”到了大三突然掀起一股毕业慌，一部分人投身于考研的热潮中，一部分人选择了培训机构学习技术。而我出于种种原因既不考研也不培训，选择自学java和web相关的知识，也希望因此能在以后谋得一份心仪的工作。 如果文章中有出现纰漏、错误之处，还请看到的小伙伴多多指教，先行谢过 HTML ","date":"2019-03-30","objectID":"/posts/ms-html-css/:0:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"1. Doctype作用，HTML5 为什么只需要写 doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档.\u003c!DOCTYPE\u003e声明必须是HTML文档的第一行，位于html标签之前 HTML5不基于SGML，所以不需要引用DTD。在HTML5中\u003c!DOCTYPE\u003e只有一种 SGML: 标准通用标记语言,是现时常用的超文本格式的最高层次标准 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:1:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"2. 行内元素有哪些，块级元素有哪些，空(void)元素有那些 行内元素：a span i img input select b 等 块级元素：div ul ol li h1~h6 p table 等 空元素：br hr link 等 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:2:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"3. 简述一下你对HTML语义化的理解 简单来说，就是合适的标签做合适的事情，这样具有以下好处： 有助于构架良好的HTML结构，有利于搜索引擎的建立索引、抓取，利于SEO 有利于不同设备的解析 有利于构建清晰的机构，有利于团队的开发、维护 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:3:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"4. 常见的浏览器内核有哪些，介绍一下你对浏览器内核的理解 Trident内核：IE Gecko内核：NETSCAPE6及以上版本，火狐 Presto内核：Opera7及以上。[Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari，Chrome等。[Chrome的：Blink（WebKit的分支）] 浏览器内核又可以分成两部分：渲染引擎和JS引擎。 渲染引擎主要负责取得网页的内容、整理讯息、计算网页的显示方式等，JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:4:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"5. html5有哪些新特性 语义化标签: header footer nav section article aside 等 增强型表单：date(从一个日期选择器选择一个日期) email(包含 e-mail 地址的输入域) number(数值的输入域) range(一定范围内数字值的输入域) search(用于搜索域) tel(定义输入电话号码字段) 等 视频和音频：audio video Canvas绘图 SVG绘图 地理定位：Geolocation 拖放API：drag web worker：是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能 web storage: localStorage sessionStorage WebSocket: HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:5:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"6. 描述一下 cookie，sessionStorage 和 localStorage 的区别 特性 Cookie localStorage sessionStorage 生命周期 可设置失效时间，没有设置的话，默认是关闭浏览器后失效 除非被手动清除，否则将会永久保存 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 存放数据大小 4KB左右 可以保存5MB的信息 可以保存5MB的信息 http请求 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:6:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"7. 如何实现浏览器内多个标签页之间的通信 使用localStorage: localStorage.setItem(key,value)、localStorage.getItem(key) websocket协议 webworker 多个标签页之间的通信 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:7:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"8. HTML5的离线存储怎么使用，解释一下工作原理 HTML5的离线存储 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:8:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"9. src与href的区别 区别：src用于替代这个元素，而href用于建立这个标签与外部资源之间的关系 \u003clink href=\"style.css\" rel=\"stylesheet\" /\u003e浏览器加载到这里的时候，html的渲染和解析不会暂停，css文件的加载是同时进行的 \u003cscript src=\"script.js\"\u003e\u003c/script\u003e当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个js文件 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:9:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"10. 表单提交中Get和Post方式的区别 Get一般用于从服务器上获取数据，Post向服务器传送数据 Get传输的数据是拼接在Url之后的，对用户是可见的；Post的传输数据对用户是不可见的 Get传送的数据量较小，不能大于2KB。Post传送的数据量较大，一般被默认为不受限制 Get安全性非常低，Post安全性较高 在FORM提交的时候，如果不指定Method，则默认为Get请求 CSS ","date":"2019-03-30","objectID":"/posts/ms-html-css/:10:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"1. css盒子模型，box-sizing属性的理解 css的盒模型由content(内容)、padding(内边距)、border(边框)、margin(外边距)组成。但盒子的大小由content+padding+border这几部分决定 box-sizing是一个CSS3属性，与盒子模型有着密切联系。即决定元素的宽高如何计算，box-sizing有三个属性： box-sizing: content-box|border-box|inherit: content-box 使得元素的宽高即为内容区的宽高(默认模式) border-box: 计算方式content + padding + border = 本身元素大小，即缩小了content大小 inherit 指定box-sizing属性的值，应该从父元素继承 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:11:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法 浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方式： 为父元素设置高度 为父元素添加overflow:hidden 伪元素 .fix::after { content:\"\"; display:block; clear:both; } 使用伪元素的好处：不增加冗余的DOM节点，符合语义化 overflow:hidden可以触发BFC机制。BFC：块级格式化上下文，创建了 BFC的元素就是一个独立的盒子，它规定了内部如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素，计算BFC的高度时，浮动元素也参与计算 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:12:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"3. 如何让一个不定宽高的盒子水平垂直居中 定位的方式 .father { position: relative; } .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; } css3属性 .father { position: relative; } .son { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex布局 .father { display: flex; justify-content: center; align-items: center; } ","date":"2019-03-30","objectID":"/posts/ms-html-css/:13:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"4. px和em和rem的区别 px: 像素，相对长度单位。像素px是相对于显示器屏幕分辨率而言的 em的值并不是固定的，会继承父级元素的字体大小，代表倍数 rem的值并不是固定的，始终是基于根元素 \u003chtml\u003e 的，也代表倍数 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:14:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"5. position的值有哪些 static： 默认值。没有定位，元素出现在正常的流中 relative（相对定位）：生成相对定位的元素,相对于其正常（原先本身）位置进行定位 absolute（绝对定位）：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位 fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:15:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"6. display:none与visibility：hidden的区别 区别 display:none visibility：hidden的 是否占据空间 不占据任何空间，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中） 该元素空间依旧存在 是否渲染 会触发reflow（回流），进行渲染 只会触发repaint（重绘），因为没有发现位置变化，不进行渲染 是否是继承属性 不是继承属性，元素及其子元素都会消失 是继承属性，若子元素使用了visibility:visible，则不继承，这个子孙元素又会显现出 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:16:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"7. CSS中link 和@import的区别 link属于XHTML标签，@import完全是CSS提供的一种方式,只能加载CSS 加载顺序的差别，当一个页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS 会等到页面全部被下载完再被加载 兼容性的差别。由于@import是CSS2.1提出的所以老的浏览器不支持，而link标签无此问题 当使用javascript控制dom去改变样式的时候，只能使用link标签，因为@import不是dom可以控制的 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:17:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"8. 什么是响应式设计，响应式设计的基本原理是什么 响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:18:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"9. 为什么要初始化CSS样式 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异 初始化样式会对 SEO 有一定的影响 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:19:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"10. CSS3有哪些新特性 实现圆角border-radius，阴影box-shadow，边框图片border-image 对文字加特效text-shadow，强制文本换行word-wrap，线性渐变linear-gradient 实现旋转transform:rotate(90deg),缩放scale(0.85,0.90),translate(0px,-30px)定位,倾斜skew(-9deg,0deg); 增加了更多的CSS选择器、多背景、rgba() 唯一引入的伪元素是::selection； 实现媒体查询@media，多栏布局flex 过渡transition 动画animation ","date":"2019-03-30","objectID":"/posts/ms-html-css/:20:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）,双冒号是在当前规范中引入的，用于区分伪类和伪元素 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:21:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"12. CSS优化、提高性能的方法有哪些 移除空的css规则（Remove empty rules） 正确使用display的属性 不滥用浮动、web字体 不声明过多的font-size 不在选择符中使用ID标识符 遵守盒模型规则 尽量减少页面重排、重绘 抽象提取公共样式，减少代码量 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:22:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"13. 重绘和回流 重绘和回流 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:23:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"14. flex布局 flex布局教程–阮一峰 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:24:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["HTML","CSS"],"content":"15. css预处理器 提供了一种css的书写方式，常见的就是 SAAS文档 和 LESS文档 ","date":"2019-03-30","objectID":"/posts/ms-html-css/:25:0","tags":["HTML","CSS","Frontend","总结"],"title":"前端面试题-HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["ACM"],"content":" 我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ 设公鸡，母鸡，小鸡数目分别为x,y,z(x\u003c=20,y\u003c=33,z\u003c=100) 约束条件 x+y+z=100 5x+3y+z/3=100 算法分析 若依次枚举x,y,x,则至少尝试21*34*100=71400次，显然效率太低。 在x,y的数目确定后，z的数目也就确定下来了100-x-y，无须再进行枚举，此时约束条件只有一个5x+3y+z/3=100.只需枚举x,y，共21*34=714次。 算法设计 #include\u003cstdio.h\u003e int main(){ int x,y,z; for(x=0;x\u003c=20;x++) //21*34=714 for(y=0;y\u003c=33;y++){ z=100-y-x; if(z%3==0 \u0026\u0026 (5*x+3*y+z/3)==100){//限定z能被3整除，进一步提高效率 printf(\"cock number:%d\\t\",x); printf(\"hen number:%d\\t\",y); printf(\"chick number:%d\\n\",z); } } return 0; } 运行解 cock number:0 hen number:25 chick number:75 cock number:4 hen number:18 chick number:78 cock number:8 hen number:11 chick number:81 cock number:12 hen number:4 chick number:84 ","date":"2019-03-30","objectID":"/posts/bqbj/:0:0","tags":["ACM"],"title":"百钱百鸡（枚举法）","uri":"/posts/bqbj/"},{"categories":["ACM"],"content":" 大数乘法c版(基础写法) #include\u003cstdio.h\u003e#include\u003cstring.h\u003e#define N 202 int main() { int a[N] = {0}, b[N] = {0}, c[404] = {0}, la, lb, i, j,k, d = 0, n1, n2;//202位数相乘，最长404位数 int get(int *p); void change(int *a, int *b, int n); la = get(a); lb = get(b); n1 = la \u003e lb ? la : lb;//较长的数长 n2 = la \u003c lb ? la : lb;//较短的数长 if (la \u003c lb) change(a, b, lb); //模拟乘法运算过程（进位等考虑） for (i = 0; i \u003c n2; i++) { for (j = 0; j \u003c n1; j++) { c[j + i] += (b[i] * a[j] + d)%10; d = (b[i] * a[j] + d) / 10; if (c[j+i]\u003e9){ d++; c[j+i]%=10; } if (a[j+1]==0\u0026\u0026d!=0){ k=j+i+1; c[k]=d; } } d=0; } k=k\u003e(j+i-2)?k:j+i-2; for (i = k; i \u003e= 0; i--)//将倒序装入的结果打印 printf(\"%d\", c[i]); return 0; } //输入字符串作为数字，并返回数字去除前导0后的长度 int get(int *p) { char x[N]; int l, i, ex = 0; scanf(\"%s\", x); l = strlen(x); while (x[ex] == '0') ex++; for (i = ex; i \u003c l; i++) //提取字符串数字到int数组，倒序排列 *(p + l - i - 1) = x[i] - '0'; return l - ex; } void change(int *a, int *b, int n) { int i, t; for (i = 0; i \u003c n; i++) { t = a[i]; a[i] = b[i]; b[i] = t; } } 程序运行结果 1234567890123456789 98765432109876543210 121932631124517831023715309991126352690 ","date":"2019-03-28","objectID":"/posts/dacheng/:0:0","tags":["数学","大数运算","ACM","C"],"title":"大数乘法","uri":"/posts/dacheng/"},{"categories":["JavaScript"],"content":" 记录自己在配置vps及博客SSL证书时遇到的问题。 强制重定向https 有一种情况相信很多人都遇到过，就是虽然我们配置了ssl证书，但是https和http地址都是各自都可以单独访问。我们应该也见过类似于github的代码托管网站有强制https的开关。如果是这种情况我们还可以通过js进行301定向。 \u003cscript\u003e var targetProtocol = \"https:\"; var host = \"lruihao.cn\"; if (window.location.host == host \u0026\u0026 window.location.protocol != targetProtocol){ window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); } \u003c/script\u003e 腾讯云CDN配置 这个博客后来是转到了腾讯云的cos桶存储。当时在桶内静态网站设置的时候，设置强制https发现会出错。而且还接入了CDN，所以今天在CDN设置那里也看到了https的设置，打开强制https就OK了。这天在三丰云撸了一个免费的主机，搭了一个WordPress（想试试wp的感觉），然后vps的SSL问题现在也很简单了，第一步，到腾讯云申请免费证书；第二步，配置CDN，按步骤来，其中接入方式选择自有源站；第三步，强制https(可选)。 ","date":"2019-03-28","objectID":"/posts/http2https/:0:0","tags":["SSL","301重定向","CDN","JavaScript","server","Frontend"],"title":"vps配置ssl及https重定向","uri":"/posts/http2https/"},{"categories":["hexo"],"content":"基于hexo-theme-next 6.0+的Pisces模板做的DIY扩展性设计","date":"2019-03-21","objectID":"/posts/hexo-theme-next/","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"危險 如无必要，不再更新！（2019.09.13） 今晚我做出了一个慎重的决定，由于博主时间精力有限，需要更多的时间来工作和学习。所以我将放弃对next的主题的自定义修改，next主题官方已经更新到了7.0+的版本，喜欢next主题风格的朋友可以在github更新。 我这也算是上古版本了，版本差距实在过大，所以我也将放弃博客使用主题的更新。 以下仍为当前博客使用主题，lib资源已打包github。 next 基于hexo-theme-next 6.0+的Pisces模板做的DIY扩展性设计（部分兼容next其他几种模板）。主要是一些custom style还有一些第三方的js。修改的地方太多也有点小乱就不提PR了。 modified 官方Demo =\u003e https://theme-next.org 记录一下折腾过程，以后备份恢复博客也好方便自己。本文之前的美化修改请见hexo分类。 主题中若有遗漏第三方插件或应用的key及id值等请修改为自己对应的值 主要的几个自定义文件 _config.swig #主题配置文件 相关账户信息自己注册替换 \\layout\\custom\\head.swig #在头部自定义加入标签 \\layout\\custom\\google_adsense.swig #谷歌广告模块，内有注释暂时弃用 \\layout\\_layout.swig #主布局 \\layout\\_macro\\post.swig #文章布局 \\layout\\_macro\\post-copyright.swig #文章版权 \\layout\\_macro\\siderbar.swig #侧栏模板 \\layout\\_third-party\\copy-code.swig #复制按钮 \\layout\\_partials\\comments.swig #评论主模板 \\layout\\_partials\\footer.swig #底部模板#该模块在layout.swig引入，用于在body自定义标签 \\layout\\_partials\\footer_custom.swig #footer自定义文件 \\layout\\_third-party\\custom.swig #该模块在layout.swig引入用于在body自定义标签 \\source\\css\\_custom\\customs.styl #主要用户自定义样式表 \\source\\fonts\\ #引入了一些我的手写体及外部字体 \\scripts\\qcloudcdn.js #腾讯云cos桶刷新缓存的脚本，不需要可删掉[^1] ^1 初步安装 安装整个改过的主题,然后下载相应的lib资源解压放入source文件夹 cd hexo git clone https://github.com/Lruihao/hexo-theme-next themes/next 主题配置文件_config.yml,选择主题 theme: next lib下载 http://github.com/Lruihao/hexo-theme-next/releases/tag/v6.9.1 更新内容 更多自定义详见源码 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:0:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"links模板 自定义友链模板，打开hexo\\themes\\next\\layout\\新建links.swig文件，写下以下内容后保存。 {% extends '_layout.swig' %} {% import '_macro/sidebar.swig' as sidebar_template %} {% block title %}{# #}{% set page_title_suffix = ' | ' + title %}{# #}{% if page.type === \"categories\" and not page.title %}{# #}{{ __('title.category') + page_title_suffix }}{# #}{% elif page.type === \"tags\" and not page.title %}{# #}{{ __('title.tag') + page_title_suffix }}{# #}{% elif page.type === \"photos\" and not page.title %}{# #}{{ __('title.photos') + page_title_suffix }}{# #}{% else %}{# #}{{ page.title + page_title_suffix }}{# #}{% endif %}{# #}{% endblock %} {% block page_class %}page-post-detail{% endblock %} {% block content %} \u003cdiv id=\"posts\" class=\"posts-expand\"\u003e {##################} {### PAGE BLOCK ###} {##################} \u003cdiv class=\"post-block page\"\u003e {% include '_partials/page-header.swig' %} {#################} {### PAGE BODY ###} {#################} \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003cdiv class=\"post-body{% if theme.han %} han-init-context{% endif %}{% if page.direction \u0026\u0026 page.direction.toLowerCase() === 'rtl' %} rtl{% endif %}\"\u003e \u003cdiv class=\"links-list\"\u003e {% for svg,link in site.data.links %} \u003cdiv class=\"card-box\" title=\"{{ link.info }}\"\u003e \u003ca href=\"{{ link.site }}\" target=\"_blank\"\u003e {% if link.avatar %} \u003cimg class=\"card-avatar\" data-original=\"{{ link.avatar }}\" alt=\"{{ link.nickname }}\"/\u003e {% else %} \u003csvg class=\"card-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{svg+1}}\"\u003e\u003c/use\u003e \u003c/svg\u003e {% endif %} \u003cspan title=\"{{ link.nickname }}\"\u003e@{{ link.nickname }}\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e {% endfor %} \u003c/div\u003e {{ page.content }} \u003c/div\u003e \u003cstyle\u003e /* @Author: lruihao.cn */ .links-list { margin-top: 1rem; display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; } .card-box { width: 150px; height: 200px; font-size: 1rem; text-align: center; background: rgba(255,255,255,0.3); box-sizing: border-box; box-shadow: 3px 3px 5px #aaa; border-radius: 5px; transition-duration: 0.3s; margin-bottom: 1rem; display: flex; flex-direction: column; } .card-box:hover { background: #fff; transform: scale(1.03); box-shadow: 0 0 3px #aaa; } .card-box a { border:none; } .card-avatar { width: 100%!important; height: 150px!important; border-radius: 5px; margin: 0; padding: 0; } .card-box span{ display: block; position: relative; bottom: 1rem; align-self: flex-end; color: #2bbc8a; font-weight: bold; max-width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; margin-top: 15px; } .card-box span:hover { color: #d480aa; } \u003c/style\u003e {#####################} {### END PAGE BODY ###} {#####################} \u003c/div\u003e {% include '_partials/breadcrumb.swig' %} {######################} {### END PAGE BLOCK ###} {######################} \u003c/div\u003e {% endblock %} {% block sidebar %} {{ sidebar_template.render(false) }} {% endblock %} {% block script_extra %} {% include '_scripts/pages/post-details.swig' %} {% endblock %} 若未使用懒加载请将模板中的data-original属性改为src 若懒加载无法加载预览图请手动添加src=\"/images/loading.gif\" 若fancybox显示alt内容请更换fancybox2或者将alt属值删除 \u003cimg class=\"card-avatar\" data-original=\"{{ link.avatar }}\" alt=\"{{ link.nickname }}\"/\u003e 然后hexo n page links新建一个页面文章配置写下如下内容： --- title: 友情链接 layout: links --- 然后在links页面文件夹下面新建文件夹_data，再在里面新建links.yml，内容如下 - nickname: 博採眾長 avatar: http://lruihao.cn/images/avatar.png site: http://lruihao.cn info: 一个菜鸟的博客 - nickname: #友链名称 avatar: #友链头像 site: #友链地址 info: #友链说明 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:1:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"备案信息自定义 # ------------------------------------------------------------- # footer_custom Settings # ------------------------------------------------------------- beian: enable: true gov: 湘公网安备 43030402000254号 recordcode: 43030402000254 icp: 湘ICP备18020535号 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:2:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"文字抖动特效 \u003cdiv class=\"shaky\"\u003e(づ●'◡'●)づ ❥内容区\u003c/div\u003e ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:3:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"左下角微信公众号 \\source\\css\\_custom\\customs.styl ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:4:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"相关文章收纳 加入H5标签，实现可收纳功能，点击查看详情。 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:5:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"Chat Services 共chatra,tidio,daovoice三个选项，三选一 # Chatra Support # See: https://chatra.io # Dashboard: https://app.chatra.io/settings/general chatra: enable: false async: true id: # visit Dashboard to get your ChatraID #embed: # unfinished experimental feature for developers, See: https://chatra.io/help/api/#injectto # Tidio Support # See: https://www.tidiochat.com # Dashboard: https://www.tidiochat.com/panel/dashboard tidio: enable: false key: # Public Key, get it from Dashboard, See: https://www.tidiochat.com/panel/settings/developer #在线客服 daovoice: true daovoice_app_id: xxxx # http://www.daovoice.io/ ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:6:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"pdf和Mermaid解析模块 pdf传送门 pdf: enable: false # Default height height: 500px pdfobject: cdn: //cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js # Mermaid tag mermaid: enable: false # Available themes: default | dark | forest | neutral theme: forest cdn: //cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:7:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"模仿csdn转发样式 ... \u003ca class=\"post-title-link\" href=\"{{ url_for(post.path) }}\" itemprop=\"url\"\u003e + {% if post.repost %} + \u003cspan class=\"repost\"\u003e转\u003c/span\u003e + {% endif %} {{ post.title | default(__('post.untitled'))}} \u003c/a\u003e {% else -%} + {% if post.repost %} + \u003cspan class=\"repost\"\u003e转\u003c/span\u003e + {% endif %} {{- post.title -}} ... .repost { color: #5acc79; border: 1px solid #e7f4df; border-radius: 20px; padding: 2px 5px; font-size: 15px; font-weight: 500; } --- title: xxxx repost: true --- 预览 ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:8:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"热度页面 打开hexo\\themes\\next\\layout新建top.swig文件，写下如下内容保存： {% extends '_layout.swig' %} {% import '_macro/sidebar.swig' as sidebar_template %} {% block title %}{# #}{% set page_title_suffix = ' | ' + title %}{# #}{% if page.type === \"categories\" and not page.title %}{# #}{{ __('title.category') + page_title_suffix }}{# #}{% elif page.type === \"tags\" and not page.title %}{# #}{{ __('title.tag') + page_title_suffix }}{# #}{% elif page.type === \"photos\" and not page.title %}{# #}{{ __('title.photos') + page_title_suffix }}{# #}{% else %}{# #}{{ page.title + page_title_suffix }}{# #}{% endif %}{# #}{% endblock %} {% block page_class %}page-post-detail{% endblock %} {% block content %} \u003cdiv id=\"posts\" class=\"posts-expand\"\u003e {##################} {### PAGE BLOCK ###} {##################} \u003cdiv class=\"post-block page\"\u003e {% include '_partials/page-header.swig' %} {#################} {### PAGE BODY ###} {#################} \u003cdiv class=\"post-body{% if theme.han %} han-init-context{% endif %}{% if page.direction \u0026\u0026 page.direction.toLowerCase() === 'rtl' %} rtl{% endif %}\"\u003e {{ page.content }} \u003cdiv id=\"top\"\u003e\u003c/div\u003e \u003c/div\u003e \u003cstyle\u003e #top{ display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; width: 100%; min-height: calc({{ page.limit }} * 20px); } #top div{ width: 400px; height: 40px; max-width: 400px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } #top a{ color: #555; text-decoration: none; outline: 0; border-bottom: 1px solid #999; word-wrap: break-word; } \u003c/style\u003e \u003cscript src=\"https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js\"\u003e\u003c/script\u003e \u003cscript\u003eAV.initialize(\"{{ theme.valine.appid }}\", \"{{ theme.valine.appkey }}\");\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e setTimeout(function(){ var time=0 var title=\"\" var url=\"\" var query = new AV.Query('Counter'); query.notEqualTo('id',0); query.descending('time'); query.limit({{ page.limit }}); //设置篇数 query.find().then(function (todo) { for (var i=0;i\u003c{{ page.limit }};i++){ var result=todo[i].attributes; time=result.time; title=result.title; category=result.categories url=result.url; var content=\"\u003cdiv\u003e\"+\"【文章热度:\"+time+\"℃】\"+\"\u003ca href='\"+\"{{ config.url }}\"+\"\"+url+\"'\u003e\"+title+\"\u003c/a\u003e\"+\"\u003c/div\u003e\"; document.getElementById(\"top\").innerHTML+=content; } }, function (error) { console.log(\"error\"); }); },1000) \u003c/script\u003e {#####################} {### END PAGE BODY ###} {#####################} \u003c/div\u003e {% include '_partials/breadcrumb.swig' %} {######################} {### END PAGE BLOCK ###} {######################} \u003c/div\u003e {% endblock %} {% block sidebar %} {{ sidebar_template.render(false) }} {% endblock %} {% block script_extra %} {% include '_scripts/pages/post-details.swig' %} {% endblock %} 其中第36行改成你自己的leancloud的appid和appkey,比如我的是在主题配置文件里面的valine配置下，所以我就写成theme.valine.appid。和我一样就不需要修改，其他自行配置。 然后hexo n page top新建一个页面文章配置写下如下内容，limit表示显示篇数： --- title: 热度 layout: top limit: 20 --- ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:9:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["hexo"],"content":"复制按钮样式 本来只想简单美化一下变成night样式的，后来写完发现3dbtn也挺喜欢的。 codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: 5 # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true # Style: 'light,night,flat,3dbtn' is currently available, leave it empty or light is default theme style: night ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:10:0","tags":["hexo","Frontend"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Java"],"content":" 摘要: Java基本的对象初始化过程，子类的初始化，以及涉及到父类和子类的转化时可能引起混乱的情况。 基本初始化过程 对于一个简单类的初始化过程是： static 修饰的模块（static变量和static 块） =\u003e 按照代码顺序依次执行。 ↓ 实例变量 及非static模块 =\u003e 按照代码顺序依次执行。 ↓ 构造函数 =\u003e 执行对应的构造函数。 子类的初始化过程 父类static修饰的模块 ↓ 子类static修饰模块 ↓ 父类实例变量和非static块 ↓ 父类对应构造函数。当子类对应构造函数中没有显示调用时调用的是父类默认的构造函数。 ↓ 子类实例变量和非static块 ↓ 子类构造函数 package code0507; public class Demo { public static void main(String[] args) { Sub sub = new Sub(); System.out.println(sub); } } class Super { int a = 6; public Super() { test(); //被子类同名函数覆盖，优先访问子类test } int b=9; public void test() { System.out.println(a); } } class Sub extends Super { int a = 8; public Sub() { test(); } public void test() { System.out.println(a); } } 运行结果 0 8 ","date":"2019-03-21","objectID":"/posts/substatus/:0:0","tags":["Java","Backend"],"title":"Java父类子类的对象初始化过程","uri":"/posts/substatus/"},{"categories":["linux"],"content":" 双系统默认启动项是Ubuntu，而日常使用最多的还是Windows，所以说很不方便，一不小心就开机到Ubuntu去了。今天来设置一下。 修改/etc/default/grub文件 同时按住键盘上的“Ctrl Alt T”三个键（即快捷键“Ctrl+Alt+T”），打开终端窗口。在终端内输入 sudo gedit /etc/default/grub 按 Enter 键确认，提示输入用户密码，输入的用户密码是看不见的，不要管它，输入完成确认即可打开grub文件。 把grub文件中的 GRUB_DEFAULT=0 中的 0 改为 saved,把 GRUB_TIMEOUT=10 中的 10 改为 5。（这里的5表示开机时等待选择操作系统是时间是5秒） 在文件末尾添加 GRUB_SAVEDEFAULT=true后保存文件并退出。 更新启动配置文件 在终端输入 sudo update-grub 按 Enter 键确认 重启 sudo reboot或者点击重启，重启到启动菜单时，选择你要更改为默认启动项的系统，按 Enter 键确认启动即可，下次启动时刚刚选择的系统即为默认启动系统，直到你手动选择启动其他的系统为止。以后可以轻松的来回切换默认系统了。 ","date":"2019-03-21","objectID":"/posts/windefault/:0:0","tags":["linux","windows","ubuntu"],"title":"ubuntu + windows双系统默认启动项设置","uri":"/posts/windefault/"},{"categories":["PHP"],"content":" 宅音乐播放器，HTML5网页播放器，集成后台管理及API调用，目前正在开发中，敬请关注~ 原项目由IT技术宅开源，使用thinkPHP开发后台。 fork地址是我个人学习模仿的库，也是相当于备份源码。 注： 插件修改于明月浩空免费版，仅用于学习交流，无商业价值，如发现商业传播，将禁止软件的免费使用。 ","date":"2019-03-19","objectID":"/posts/player/:0:0","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"技术栈 后端：thinkphp 5.1 前端：layui 数据库：mysql ","date":"2019-03-19","objectID":"/posts/player/:1:0","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"演示站 已兼容移动端，测试账号仅供测试请勿修改密码！ test test123 https://player.ilt.me/ https://player.lruihao.cn/ ","date":"2019-03-19","objectID":"/posts/player/:2:0","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"安装 ","date":"2019-03-19","objectID":"/posts/player/:3:0","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"视频安装教程 https://www.bilibili.com/video/av46476706 ","date":"2019-03-19","objectID":"/posts/player/:3:1","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"依赖 composer php 5.6+ mysql 5.5+ ","date":"2019-03-19","objectID":"/posts/player/:3:2","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"步骤 安装php依赖包 composer install 配置数据库，配置链接数据库名以及用户名密码 /config/database.php 创建数据库 字符编码：utf8 -- UTF-8 Unicode 导入数据库脚本，脚本位置extend/database ","date":"2019-03-19","objectID":"/posts/player/:3:3","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"伪静态配置 nginx location / { index index.htm index.html index.php; #访问路径的文件不存在则重写URL转交给ThinkPHP处理 if (!-e $request_filename) { rewrite ^/(.*)$ /index.php?s=$1 last; break; } } apache 项目自带apache静态化无需配置 ","date":"2019-03-19","objectID":"/posts/player/:3:4","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"启动项目 添加public为web根目录 若为apache服务器则默认伪静态，nginx可自行配置伪静态 ","date":"2019-03-19","objectID":"/posts/player/:3:5","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"预览 ","date":"2019-03-19","objectID":"/posts/player/:4:0","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"首页 ","date":"2019-03-19","objectID":"/posts/player/:4:1","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"登陆页面 ","date":"2019-03-19","objectID":"/posts/player/:4:2","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"后台首页 ","date":"2019-03-19","objectID":"/posts/player/:4:3","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"后台播放器管理页面 ","date":"2019-03-19","objectID":"/posts/player/:4:4","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["PHP"],"content":"后台歌单管理页面 ","date":"2019-03-19","objectID":"/posts/player/:4:5","tags":["Backend","PHP","宝塔面板"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["linux"],"content":"极速方便的一键配置与管理，免除繁琐的命令行操作，通过Web面板一键即可操作实现。可选择安装lamp或者lnmp环境，可创建及管理网站，可创建及管理数据库，可创建及管理FTP等等。宝塔官网介绍 系统要求 操作系统：全新系统(支持CentOS、Ubuntu、Debian、Fedora、Deepin)， 确保是干净的操作系统，没有安装过其它环境带的Apache/Nginx/php/MySQL 宝塔Linux6.0版本是基于centos7开发的，强烈建议使用centos7.x 系统 内存要求：内存要求最低512MB，推荐768MB以上，纯面板约占系统60MB内存 安装方法 官方号称2分钟装好面板，一键管理服务器。 使用 SSH 连接工具，如宝塔远程桌面助手连接到您的 Linux 服务器后，挂载磁盘，根据系统执行相应命令开始安装（大约2分钟完成面板安装）： yum install -y wget \u0026\u0026 wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026\u0026 sh install.sh wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 sudo bash install.sh wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 bash install.sh wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026\u0026 bash install.sh 搭建ftp和云盘服务器 可以很傻瓜式的搭建自己的云盘，和平时用的比较多的ftp服务器。搭建静态网站也可以用ftp来上传文件。 ","date":"2019-03-18","objectID":"/posts/bt/:0:0","tags":["linux","server","宝塔面板"],"title":"宝塔面板安装","uri":"/posts/bt/"},{"categories":["Fullstack"],"content":" 下面一些web开发的一些总结，还有一些常用到的代码，脚本等！ front-end ","date":"2019-03-18","objectID":"/posts/webbiji/:0:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"html HTML+CSS ","date":"2019-03-18","objectID":"/posts/webbiji/:1:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"oblique和intalic的区别 这两个都是font-style属性的值，这两个值都能实现倾斜的效果，但是有区别的。 intalic: 这个是字体的倾斜，相当于斜体，字体必须有倾斜属性。 oblique: 这个准确地说是让文字倾斜。相当于斜字，字体不一定要有倾斜属性。 ","date":"2019-03-18","objectID":"/posts/webbiji/:1:1","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"title显示换行 使用\u0026#10;或使用\u0026#13; \u003ca href=\"#\" title=\"第一行\u0026#10;第二行\u0026#10;第三行\"\u003e使用`\u0026#10;`\u003c/a\u003e \u003ca href=\"#\" title=\"第一排\u0026#13;第二排\u0026#13;第三排\"\u003e使用`\u0026#13;`\u003c/a\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:1:2","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"图片类型选择 ","date":"2019-03-18","objectID":"/posts/webbiji/:1:3","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"css ","date":"2019-03-18","objectID":"/posts/webbiji/:2:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"flexbox Flex布局将成为未来布局的首选方案，比如说常见的bootstrap4的版本就用flex替代了float来进行排版。 我在网上看到几个很好的教程,图文并茂，一目了然。 A Complete Guide to Flexbox Flex 布局教程：语法篇 实在懒癌发作，笔记本上手抄了笔记我就不写学习总结了，还有网友Demo也写了。 ","date":"2019-03-18","objectID":"/posts/webbiji/:2:1","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"javascript ","date":"2019-03-18","objectID":"/posts/webbiji/:3:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"keydown和keypress keydown：按下键盘键 keypress：紧接着keydown事件触发（只有按下字符键时触发） 如果用户按下了一个字符键不放，就会重复触发keydown和keypress事件，直到用户松开该键为止。 如果用户按下了一个非字符键不放，就会重复触发keydown事件，直到用户松开该键为止。 详解键盘事件(keydown，keypress，keyup) ","date":"2019-03-18","objectID":"/posts/webbiji/:3:1","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"textContent、innerText和innerHTML的区别 设置标签中的文本内容,应该使用textContent或innerText（更老）属性,区别在于浏览器支援程度 innerHTML能够获得元素内的所有标签内容，也可以设置标签使之生效。（注意防止XSS注入） 如果某个属性在浏览器中不支持,那么这个属性的类型是undefined，判断这个属性的类型是不是undefined，就知道浏览器是否支持。 \u003cscript\u003e // 设置任意的标签中间的任意文本内容 function setInnerText(element, text) { //判断浏览器是否支持这个属性 if (typeof element.textContent == \"undefined\") {//不支持 element.innerText = text; } else {//支持这个属性 element.textContent = text; } }; \u003c/script\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:3:2","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"图床方案 自行搭建 比如使用开源图床ImgURL搭建的img.lruihao.cn（需要服务器） 使用上传工具加第三方免费空间，比如PicGo + 腾讯云COS（无需服务器） 使用各大图床 诸如sm.ms，腾讯云COS，阿里云OSS，七牛云，又拍云，Github，微博图床，ImgURL图床等等 ","date":"2019-03-18","objectID":"/posts/webbiji/:4:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"font-awesome 现在使用5的版本，可以使用webfont+css或svg+js \u003clink rel=\"stylesheet\" href=\"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css\"\u003e 其他的图标js \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003csvg class=\"card-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{n+1}}\"\u003e\u003c/use\u003e \u003c!--n为一个数字--\u003e \u003c/svg\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:5:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"响应式（自适应） \u003clink rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css\"\u003e \u003cscript src=\"https://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=0\"\u003e .col-xs- 超小屏幕 手机 \u003c768px .col-sm- 小屏幕 平板 \u003e=768px .col-md- 中等屏幕 \u003e=992px .col-lg- 大屏幕 \u003e1200px css3 写法 @media (宽度具体调整) /* 手机等小屏幕手持设备 */ @media screen and (min-width: 320px) and (max-width: 480px) { /*手机端css样式表*/ } /* 平板之类的宽度 1024 以下设备 */ @media only screen and (min-width: 321px) and (max-width: 1024px) { /*电脑端css样式表*/ } link引入不同css \u003c!--手机端--\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"style_phone.css\" media=\"screen and (max-width: 960px)\"/\u003e \u003c!--电脑端--\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"style_PC.css\" media=\"screen and (min-width: 960px)\"/\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:6:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"jquery \u003cscript src=\"https://code.jquery.com/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"http://cdn.bootcss.com/jquery/1.11.0/jquery.min.js\"\u003e\u003c/script\u003e //还有其他的源... ","date":"2019-03-18","objectID":"/posts/webbiji/:7:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"QQ推广链接 QQ推广 QQ群 \u003ca target=\"_blank\" href=\"https://wpa.qq.com/msgrd?v=3\u0026uin=1074627678\u0026site=qq\u0026menu=yes\"\u003e\u003cimg border=\"0\" src=\"http://wpa.qq.com/pa?p=2:1074627678:51\" alt=\"点击这里给我发消息\" title=\"点击这里给我发消息\"/\u003e\u003c/a\u003e ","date":"2019-03-18","objectID":"/posts/webbiji/:8:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"Google fonts https://fonts.google.com/ 一般选用国内源镜像替代（待补充...） + https://fonts.loli.net + //fonts.lug.ustc.edu.cn ","date":"2019-03-18","objectID":"/posts/webbiji/:9:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Fullstack"],"content":"fancybox github介绍 fancybox源 \u003clink href=\"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css\" rel=\"stylesheet\"\u003e \u003cscript src=\"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js\"\u003e\u003c/script\u003e back-end 更多学习内容见学习课件 练习作业源码+Demo ","date":"2019-03-18","objectID":"/posts/webbiji/:10:0","tags":["Fullstack","Frontend","JavaScript","Backend"],"title":"web汇总","uri":"/posts/webbiji/"},{"categories":["Java"],"content":" 泛型方法，它在修饰符后，返回值类型前增加了类型参数(\u003c\u003e) 类型通配符一般使用问号?代替具体的类型实参，注意不是类型形参。 代码 package code0507; public class WildCardTest { public static void main(String[] args) { Box\u003cString\u003ename=new Box\u003cString\u003e(\"hello\"); Box\u003cInteger\u003eage=new Box\u003cInteger\u003e(12); Box\u003cDouble\u003enumber=new Box\u003cDouble\u003e(210.50); Box\u003cInteger\u003epoint=new Box\u003cInteger\u003e(); getData(name); getData(age); getData(number); point.printpoint(520, 1314); point.printpoint(\"me\", \"too\"); } public static void getData(Box\u003c?\u003edata){//类型通配符 System.out.println(\"data:\"+data.getData()); } } class Box\u003cT\u003e{ private T data; public Box() {}//构造方法重载 public Box(T data) { setData(data); } public T getData() { return data; } public void setData(T data) { this.data = data; } //定义泛型方法 public\u003cT1,T2\u003evoid printpoint(T1 x,T2 y){ T1 m=x; T2 n=y; System.out.println(\"This point is:\"+m+\",\"+n); } } 运行结果 data:hello data:12 data:210.5 This point is:520,1314 This point is:me,too ","date":"2019-03-16","objectID":"/posts/fanxing/:0:0","tags":["泛型","Java","Backend"],"title":"java 泛型 test","uri":"/posts/fanxing/"},{"categories":["Fullstack"],"content":"基本使用 A:选择一个工作空间 D:\\develop\\eclipse-SDK-3.7.2-win64\\workspace B:如何写一个HelloWorld案例(代码以项目为基本单位) a:创建项目(工程) *File -- New -- Java Project *在左边空白处，直接右键 -- New -- Java Project 键入项目名称后直接Finish。 b:所有的java文件必须写到src下面才有效 c:创建一个包 cn.lruihao d:在包下创建一个类 HelloWorld 同时让它帮我们写好了main方法。 e:在main方法中写内容即可 f:编译程序 自动编译，在保存的那一刻帮你做好了 g:运行程序 选择要运行的文件或者在要运行的文件内容中 右键 -- Run as - Java Application即可 h:内容显示 在Console控制台显示内容 Eclipse的基本设置 A:程序的编译和运行的环境配置(如果你的Eclipse启动没有问题，就不要配置了) B:去掉默认注释(可以不用改) C:行号的显示和隐藏 显示：在代码区域的最左边的空白区域，右键 -- Show Line Numbers即可。 隐藏：把上面的动作再做一次。 D:字体大小及颜色 a:Java代码区域的字体大小和颜色： window -- Preferences -- General -- Appearance -- Colors And Fonts -- Java修改 -- Java Edit Text Font b:控制台 window -- Preferences -- General -- Appearance -- Colors And Fonts -- Debug -- Console font c:其他文件 window -- Preferences -- General -- Appearance -- Colors And Fonts -- Basic -- Text Font E:窗体给弄乱了，怎么办 window -- Reset Perspective F:控制台找不到了 Window--Show View—Console 快捷键的使用 A:内容辅助键 Alt+/ 起提示作用 main+alt+/,syso+alt+/,给出其他提示 B:快捷键 格式化 ctrl+shift+f 导入包 ctrl+shift+o 注释 ctrl+/ ctrl+shift+/,ctrl+shift+\\ 代码上下移动 选中代码alt+上/下箭头 查看源码 选中类名(F3或者Ctrl+鼠标点击) Eclipse中如何提高开发效率 A:自动生成构造方法 a:无参构造方法 在代码区域右键--source--Generate Constructors from Superclass b:带参构造方法 在代码区域右键--source--Generate Constructors using fields.. -- finish B:自动生成get/set方法 在代码区域右键--source--Generate Getters and Setters... ","date":"2019-03-15","objectID":"/posts/eclipseuse/:0:0","tags":["eclipse","Java"],"title":"eclipse的基本使用","uri":"/posts/eclipseuse/"},{"categories":["Java"],"content":" java中匿名类用的最多的地方就是可视化界面设计中，特别是将事件监听器注册到某个组件上的时候。 ","date":"2019-03-15","objectID":"/posts/qframe/:0:0","tags":["GUI","Java","Backend"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["Java"],"content":"代码 package cn.lruihao; import java.awt.event.*; import javax.swing.*; public class QFrame extends JFrame { public QFrame() { JButton jbtnew=new JButton(\"New\");//新建按钮 JPanel panel=new JPanel();//面板容器 panel.add(jbtnew);//添加组件 add(panel); jbtnew.addActionListener(new ActionListener() { //新建一匿名类，并将该对应的事件监听器注册到“新建”按钮 就jbtnew上 @Override public void actionPerformed(ActionEvent e) { JOptionPane.showMessageDialog(null, \"单击了新建按钮\"); System.out.println(\"lruihao.cn\"); } }); } public static void main(String[] args) { JFrame frame=new QFrame(); frame.setTitle(\"QFrame\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); frame.pack(); frame.setVisible(true); } } 创建一个可视化界面，界面中有一个按钮，单击按钮显示“单击了新建按钮”。 ","date":"2019-03-15","objectID":"/posts/qframe/:1:0","tags":["GUI","Java","Backend"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["Java"],"content":"结果 ","date":"2019-03-15","objectID":"/posts/qframe/:2:0","tags":["GUI","Java","Backend"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["Java"],"content":"参考 JOptionPane的使用 ","date":"2019-03-15","objectID":"/posts/qframe/:3:0","tags":["GUI","Java","Backend"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["JavaScript"],"content":" 模仿知乎的卡片式链接，idea 来自[兰州小红鸡] ","date":"2019-03-15","objectID":"/posts/linkcard/:0:0","tags":["JavaScript","hexo","Frontend"],"title":"模仿知乎卡片式链接","uri":"/posts/linkcard/"},{"categories":["JavaScript"],"content":"源码 2021/10/2 1:29 更新 这是一种后加载，创建linkcard.js放到source/js/src/，然后在next\\layout\\_macro\\post.swig中引用 function cardLink(){ let $cardLinks = document.querySelectorAll('.card-link'); if($cardLinks.length === 0){ return; } //插入样式 let $linkStyle = document.createElement('style') $linkStyle.innerHTML = \".card-link,.card-link:hover{text-decoration:none;border:none!important;color:inherit!important}.card-link{position:relative;display:block;margin:1em auto;width:390px;box-sizing:border-box;border-radius:12px;max-width:100%;overflow:hidden;color:inherit;text-decoration:none}.ztext{word-break:break-word;line-height:1.6}.card-link-backdrop{position:absolute;top:0;left:0;right:0;bottom:0;background-image:url(/images/card-link-bg.jpg);background-repeat:no-repeat;-webkit-filter:blur(20px);filter:blur(20px);background-size:cover;background-position:center}.card-link,.card-link:hover{text-decoration:none;border:none!important;color:inherit!important}.card-link-content{position:relative;display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:inherit;background-color:rgba(246,246,246,0.88)}.card-link-text{overflow:hidden}.card-link-title{display:-webkit-box;-webkit-line-clamp:2;overflow:hidden;text-overflow:ellipsis;max-height:calc(16px * 1.25 * 2);font-size:16px;font-weight:500;line-height:1.25;color:#1a1a1a}.card-link-meta{display:flex;margin-top:4px;font-size:14px;line-height:20px;color:#999;white-space:nowrap}.card-link-url{display: inline-flex;align-items: center;}.card-link-imageCell{margin-left:8px;border-radius:6px}.card-link-image{display:block;width:60px;height:60px;border-radius:inherit}\"; document.querySelector('body').appendChild($linkStyle); //渲染 DOM for(let $cardLink of $cardLinks) { $cardLink.innerHTML = `\u003cspan class='card-link-backdrop'\u003e\u003c/span\u003e\u003cspan class='card-link-content'\u003e\u003cspan class='card-link-text'\u003e\u003cspan class='card-link-title'\u003e${$cardLink.innerText}\u003c/span\u003e\u003cspan class='card-link-meta'\u003e\u003cspan class='card-link-url'\u003e\u003csvg class='Zi Zi--InsertLink' fill='currentColor' viewBox='0 0 24 24' width='17' height='17'\u003e\u003cpath d='M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z' fill-rule='evenodd'\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/span\u003e${$cardLink.href}\u003c/span\u003e\u003c/span\u003e\u003cspan class='card-link-imageCell'\u003e\u003cimg class='card-link-image' alt='card-link icon' src='/images/linkicon.png'\u003e\u003c/span\u003e\u003c/span\u003e`; } } window.onload = () =\u003e{ cardLink(); }; ","date":"2019-03-15","objectID":"/posts/linkcard/:1:0","tags":["JavaScript","hexo","Frontend"],"title":"模仿知乎卡片式链接","uri":"/posts/linkcard/"},{"categories":["JavaScript"],"content":"使用 \u003c!--知乎卡片链接--\u003e \u003cscript type=\"text/javascript\" src=\"/js/src/card-link.js\"\u003e\u003c/script\u003e html链接写法,a标签加上class=\"card-link\" \u003ca href=\"https://github.com/Lruihao/lruihao.github.io\" target=\"_blank\" class=\"card-link\"\u003eLruihao博客\u003c/a\u003e Lruihao 博客 https://github.com/Lruihao/lruihao.github.io ","date":"2019-03-15","objectID":"/posts/linkcard/:2:0","tags":["JavaScript","hexo","Frontend"],"title":"模仿知乎卡片式链接","uri":"/posts/linkcard/"},{"categories":["linux"],"content":" 我的 Ubuntu 和 Windows 双系统是 Ubuntu 是第一启动项，所以总是开机忘记点下键，一进 Ubuntu 系统时间就不对了（总是少了8小时），回到 Windows 时间也是错的。知道是错的调整一下还好。忘记调了有时候真的会误事。比如说 git 版本控制提交会遇到问题种种等。 ","date":"2019-03-15","objectID":"/posts/ubuntutime/:0:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["linux"],"content":"原因 在安装 Ubuntu 和 Windows 双系统的情况下，Ubuntu 的时间总会和 Windows 的时间相差 8 小时，原因在于 widows 认为 BIOS 时间是本地时间，Ubuntu 认为 BIOS 时间是 UTC 时间，即协调世界时，(Universal Time Coordinated)英文缩写，是由国际无线电咨询委员会规定和推荐,并由国际时间局(BIH)负责保持的以秒为基础的时间标度。UTC 相当于本初子午线(即经度0度)上的平均太阳时，过去曾用格林威治平均时(GMT)来表示。北京时间比 UTC 时间早 8 小时，以 1999 年 1 月 1 日 00:00 UTC 为例，UTC 时间是零点，北京时间为 1999 年 1 月 1 日早上 8 点整。)，所以我们在时间上面相隔了 8 个小时。这个时候 bios 的时间和系统的时间当然是不一致，一个代表 utc 时间，一个代表 cst（＋8 时区），即我们常用的时间。 ","date":"2019-03-15","objectID":"/posts/ubuntutime/:1:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["linux"],"content":"方法一 在 Windows下 进行如下修改：（博主win10,win7自测） 以管理员身份运行CMD（win+x后选择Windows Powershell(管理员) Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 重启看看时间发现ok了。 ","date":"2019-03-15","objectID":"/posts/ubuntutime/:2:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["linux"],"content":"方法二 老版 Ubuntu（Ubuntu10 左右）： 修改 /etc/default/rcS 文件 编辑 /etc/default/rcS 将 UTC=yes改成 UTC=no 。 新版 Ubuntu（Ubuntu16.04）： 新版本的 Ubuntu 使用 systemd 启动之后，时间也改成了由 timedatectl 来管理，此方法就不适用了。 $sudo timedatectl set-local-rtc 1 先在 ubuntu 下更新一下时间，确保时间无误： $sudo apt-get install ntpdate $sudo ntpdate time.windows.com 然后将时间更新到硬件上： $sudo hwclock --localtime --systohc 重新进入windows10，发现时间恢复正常了！ ","date":"2019-03-15","objectID":"/posts/ubuntutime/:3:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["JavaScript"],"content":" 以前在QQ里面聊天的时候发现，有些链接是卡片式的链接，像知乎里那些一样，就好奇为啥我的域名没有生成卡片。 查了一下百度知道了大概就是qq没有抓取到你的网站的xml。并在其他教程中得到了一个强制提交抓取的url https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url= 于是就有了脚本刷新的想法。简陋的写了一下。 ","date":"2019-03-08","objectID":"/posts/qqxml/:0:0","tags":["JavaScript","Frontend","脚本"],"title":"QQ强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["JavaScript"],"content":"批量式刷新 //设置刷新前缀url=首页地址（最好使用https） var base_src = \"https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url=https://lruihao.cn\"; //用户地址 //var custom_src = \"https://lruihao.cn\"; //初始化工作地址 var new_src = \"\"; function createArrayAndOpenWindow(){ //alert(\"number function\"); //定义数组存储后缀 var numberArray = new Array(4); //存储后缀 numberArray[0] = \"/about/\"; numberArray[1] = \"/categories/\"; numberArray[2] = \"/tags/\"; numberArray[3] = \"/archives/\"; //numberArray[4] = \"/guestbook/\"; //遍历 for(var i = 0; i \u003cnumberArray.length;i++){ new_src = base_src + numberArray[i]; //打开该地址 open_new(); //清空后缀 new_src = \"\"; } } //负责打开窗口,并关闭 function open_new(){ var new_window = window.open(new_src,'','width=400,height=200'); setTimeout(function(){ //开启后200ms（单页）关闭，速度自行把握数组越大时间越多 new_window.close(); }, 2000); } window.onload =function(){ createArrayAndOpenWindow(); //设置定时函数，疯狂刷新直到xml出现内容 var timer = setInterval(\"createArrayAndOpenWindow()\", 2000); } ","date":"2019-03-08","objectID":"/posts/qqxml/:1:0","tags":["JavaScript","Frontend","脚本"],"title":"QQ强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["JavaScript"],"content":"单链接刷新 \u003cdiv style=\"text-align: center;\"\u003e \u003cinput type = \"text\" id = \"input\" value=\"\" /\u003e \u003cinput type = \"button\" value = \"疯狂刷新\" onclick = \"yanzheng()\" /\u003e \u003c/div\u003e //设置刷新前缀url=首页地址（最好使用https）https://lruihao.cn var base_src = \"https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url=\"; //用户地址 var custom_src = \"\"; //初始化工作地址 var new_src = \"\"; //负责打开窗口,并关闭 function open_new(){ var new_window = window.open(new_src,'','width=400,height=200'); setTimeout(function(){ //开启后200ms关闭 new_window.close(); }, 200); } // 获取验证用户输入 function yanzheng(){ var Input = document.getElementById('input'); var oValue = Input.value; custom_src = oValue; new_src = base_src + custom_src if(oValue ==0){ alert('请输入地址'); }else{ var timer = setInterval(\"open_new()\", 200); } } ","date":"2019-03-08","objectID":"/posts/qqxml/:2:0","tags":["JavaScript","Frontend","脚本"],"title":"QQ强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["JavaScript"],"content":"demo ","date":"2019-03-08","objectID":"/posts/qqxml/:3:0","tags":["JavaScript","Frontend","脚本"],"title":"QQ强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["others"],"content":"外存的组织方式 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"连续组织方式 连续组织方式的优点 顺序访问容易 顺序访问速度快 连续组织方式的缺点 分配连续的存储空间 必须知道文件长度 删除与插入数据不灵活 动态增长的文件分配空间问题 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"链接组织方式 隐式链接 显式链接 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"FAT技术 FAT12 早期的FAT12文件系统 以簇为单位的FAT12文件系统 FAT16 FAT32 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"NTFS的文件组织方式 NTFS新特征 磁盘组织 文件的组织 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:4","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"索引组织方式 单级索引组织方式 多级索引组织方式 增量式索引组织方式 增量式索引组织方式的基本思想 UNIX System V的组织方式 直接地址 一次间接地址 多次间接地址 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:1:5","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"文件存储空间的管理 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:2:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"空闲表法和空闲链表法 空闲表法 空闲表 存储空间的分配与回收 空闲链表法 空闲盘块链 空闲盘区链 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:2:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"位示图法 位示图 盘块的分配（步骤） 1.顺序扫描示图 2.转换盘块号 3.修改位示图 盘块的回收（步骤） 1.盘块号转换成行列号 2.修改位示图 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:2:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"成组链接法 空闲盘块的组织 空闲盘块的分配与回收 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:2:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"提高磁盘I/O速度的途径 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:3:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"磁盘高速缓存 数据交付方式 数据交付 指针交付 置换算法 周期性地写回磁盘 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:3:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"提高磁盘I/O速度的其他方法 提前读 延迟写 优化物理块的分布 虚拟盘 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:3:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"廉价磁盘冗余阵列(RAID) 并行交叉存取 RAID的分级 RAID 0级 RAID 1级 RAID 2级 RAID 3级 RAID 4级 RAID 5级 RAID 6级和RAID 7级 RAID的优点 可靠性高 磁盘I/O速度高 性价比高 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:3:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"提高磁盘可靠性的技术 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"第一级容错技术SFT-Ⅰ 双份目录和双份文件分配表 热修复重定向和写后读校验 热修复重定向 写后读校验方式 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"第二级容错技术SFT-Ⅱ 磁盘镜像 磁盘双工 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"基于集群技术的容错功能 双机热备份模式 双机互为备份模式 公用磁盘模式 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"后备系统 磁带机 硬盘 移动磁盘 固定硬盘驱动器 光盘驱动器 CD-ROM 和 DVD-ROM 刻录机 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:4:4","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"数据一致性控制 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"事务 事务的定义 事务记录 恢复算法 undo \u003cTi\u003e redo \u003cTi\u003e ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:1","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"检查点 检查点的作用 新的恢复算法 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:2","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"并发控制 利用互斥锁实现“顺序性” 利用互斥锁和共享锁实现顺序性 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:3","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["others"],"content":"重复数据的数据一致性问题 重复文件的一致性 链接数一致性检查 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:5:4","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["JavaScript"],"content":"#code{ font-family:Arial; font-style:italic; font-weight:bold; border:2px solid #ddd; letter-spacing:9px; color:blue; font-size: 15px; } //设置一个全局的变量，便于保存验证码 var code; function createCode(){ //首先默认code为空字符串 code = ''; //设置长度，这里看需求，我这里设置了4 var codeLength = 4; var codeV = document.getElementById('code'); //设置随机字符 var random = new Array('人','徒','知','枯','坐','息','思','为','进','德','之','功','殊','不','知','上','达','之', '士','圆','通','定','慧','体','用','双','修','即','动','而','静','虽','撄','而','宁'); //循环codeLength 我设置的4就是循环4次 for(var i = 0; i 请点击验证码处: ↑ 验证码 JS 来源互联网 \u003cscript type=\"text/javascript\"\u003e //设置一个全局的变量，便于保存验证码 var code; function createCode(){ //首先默认code为空字符串 code = ''; //设置长度，这里看需求，我这里设置了4 var codeLength = 4; var codeV = document.getElementById('code'); //设置随机字符 var random = new Array(0,1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R', 'S','T','U','V','W','X','Y','Z'); //循环codeLength 我设置的4就是循环4次 for(var i = 0; i \u003c codeLength; i++){ //设置随机数范围,这设置为0 ~ 36 var index = Math.floor(Math.random()*36); //字符串拼接 将每次随机的字符 进行拼接 code += random[index]; } //将拼接好的字符串赋值给展示的Value codeV.value = code; } //下面就是判断是否== 的代码，无需解释,也可以结合ajax在后台做判断 function validate(){ var Input = document.getElementById('input'); var oValue = Input.value.toUpperCase(); if(oValue ==0){ alert('请输入验证码'); }else if(oValue != code){ Input.value = ''; alert('验证码不正确，请重新输入'); createCode(); }else{ Input.value = ''; alert('验证码正确！');//window.open('http://lruihao.cn','_self'); } } //设置此处的原因是每次进入界面展示一个随机的验证码，不设置则为空 window.onload = function (){ createCode(); } \u003c/script\u003e ","date":"2019-03-04","objectID":"/posts/vcode/:0:0","tags":["Frontend","JavaScript"],"title":"JS 验证码","uri":"/posts/vcode/"},{"categories":["生活随笔"],"content":" 这不是英国作家哈代的《The Return of Native》,而是我们这辈的父母所经历的常态。 以下文章由好友杨灿所写 逢近年关，邻居家的王婶又在等她的儿子了。 她的儿子大抵有五年未曾回家了。记得去年，他同王婶说好了回家过年，王婶便从腊月二十直直地等到腊月三十，准备好一桌的年夜饭，最后却只是她一个人随便地扒拉了几口。 我尚且还记得那日，王婶与我母亲一同去河边处理鸡鸭，我也随了去。母亲同王婶说：“源子怎地还不回来？”王婶道：“许是买的车票晚了些，他早前和我说回家过年的，想来还在回来的路上。” 到晚上，万家灯火渐起，都说热热闹闹团圆饭，王婶家却格外冷清。王婶嫁过来时，家中便只有王叔一人，早些年，王叔随人去炸山取石，人也不幸被石头砸死，家中便只有王婶和她儿子二人。王源也知家中境况，自大学毕业后在外工作，至今，除了前年我暑假时回来过一次，其中便从未回来过。 人倒是挺奋进，这些年，王婶家从小木屋变成了三层小洋房，家里也添置了许多家具和电器。王婶倒像一个门卫，守着这栋房子，看着这个家。 不过别家事总归别家事。 王婶是个十分随和的人，也常常和村里人打趣逗乐，常见她笑眼眯眯。一年到头，也唯有这“头”让她难展笑颜。 “王婶子，源哥还没回来吗？” “快了，快了……” 王婶又坐在门口，纳着新鞋，常常一纳就是一天。 我们常听到一个词——衣锦还乡，其实，于父母而言，他们所看重的从来都只是还乡。而所谓衣锦，不过是死要面子者拿来的托辞。衣锦若无，无便无罢，衣锦若有，有便有罢。 衣锦随意，还乡就好。 戊戌年腊月廿七于家中。 ","date":"2019-02-01","objectID":"/posts/renative/:0:0","tags":["生活随笔","他山之石"],"title":"还乡","uri":"/posts/renative/"},{"categories":["Java"],"content":"引用 继承的好处： 提高了代码的复用性 提高了代码的维护性 让类与类之间产生了关系，是多态的前提 继承的弊端：类的耦合性很强 设计原则：低耦合，高内聚。 耦合：类与类的关系。 内聚：自己完成事情的能力。 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:0","tags":["Java","Backend"],"title":"java继承test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"java中的继承特点 Java只支持单继承，不支持多继承。Java支持多层继承(继承体系) class A { } class B extends A { } /* class C extends A,B { } */ class C extends B { } class ExtendsDemo { public static void main(String[] args) { } } ","date":"2019-01-24","objectID":"/posts/jicheng/:0:1","tags":["Java","Backend"],"title":"java继承test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"java中的继承注意事项 子类只能继承父类所有非私有的成员(成员方法和成员变量) 子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法。 不要为了部分功能而去继承 那么，我们什么时候考虑使用继承呢? 继承中类之间体现的是：”is a”的关系。 如果两个类满足这个关系：xxx is a yyy，那么他们就可以使用继承。 Student,Person 对 Dog,Animal 对 Dog,Pig 错 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:2","tags":["Java","Backend"],"title":"java继承test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"继承 继承间的构造方法关系: 创建子类对象，会先去访问父类的构造方法。对父类的数据进行初始化。 package jicheng; class Fu{ public int num = 10; public Fu(){ System.out.println(\"父类\"); } } class Zi extends Fu{ public int num = 20; public Zi(){ System.out.println(\"子类\"); } public void show(){ int num = 30; System.out.println(num);//30 System.out.println(this.num);//20 System.out.println(super.num);//10 } } public class test { public static void main(String[] args) { Zi z = new Zi(); z.show(); } } 程序运行结果 父类 子类 30 20 10 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:3","tags":["Java","Backend"],"title":"java继承test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"代码块 代码块的执行顺序： 静态代码块 –\u003e 构造代码块 –\u003e 构造方法 代码的执行特点: 静态代码块只执行一次，构造代码块每次调用构造方法都执行。 package jicheng; class Fu { static { System.out.println(\"父类静态代码块\"); } { System.out.println(\"父类构造代码块\"); } public Fu() { System.out.println(\"父类构造方法\"); } } class Zi extends Fu { static { System.out.println(\"子类静态代码块\"); } { System.out.println(\"子类构造代码块\"); } public Zi() { System.out.println(\"子类构造方法\"); } } public class test { public static void main(String[] args) { Zi z = new Zi(); Zi z2 = new Zi(); } } 程序运行结果： 父类静态代码块 子类静态代码块 父类构造代码块 父类构造方法 子类构造代码块 子类构造方法 父类构造代码块 父类构造方法 子类构造代码块 子类构造方法 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:4","tags":["Java","Backend"],"title":"java继承test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"继承间的成员关系 成员方法 不同名称： 非常简单，一看就知道调用谁 相同名称： 先在子类找，再在父类找 … 找不到就报错。 成员变量： 名字不同： 非常的简单，一看就知道使用的是谁。 名字相同： 就近原则。 使用变量的时候，会先找局部范围。 如果想直接使用成员变量，加关键字：this即可。 如果想直接使用父类的成员变量，加关键字：super即可。 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:5","tags":["Java","Backend"],"title":"java继承test","uri":"/posts/jicheng/"},{"categories":["Java"],"content":"注意事项 子类中所有的构造方法默认都会访问父类中空参数的构造方法。为什么呢?因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:6","tags":["Java","Backend"],"title":"java继承test","uri":"/posts/jicheng/"},{"categories":["hexo"],"content":" 本以为 coding pages 与腾讯云合作后会更好，没想到正是这种初期 bug 不断，速度也是非常慢。比 gitee, 甚至 github 都要慢很多了。所以决定放弃 coding 了，本想挂到云服务器上，但是这个云服务器只续费了半年，可能不会再续费，前几天看到用腾讯云的 cos 桶 xml 制作动态相册的文章，知道了对象存储这个玩意，腾讯云 COS 提供免费 50G 的存储空间，还有 CDN 加速服务，我觉得是个不错的选择，部署后发现速度还挺好。 适用于 hexo, hugo 等静态博客的部署。 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:0","tags":["hexo","hugo","腾讯云cos桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["hexo"],"content":"创建存储桶 打开腾讯云控制台–云产品–存储–对象存储，然后创建存储桶。 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:1","tags":["hexo","hugo","腾讯云cos桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["hexo"],"content":"开启静态网站设置 在基础配置打开静态网站(关掉强制https) ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:2","tags":["hexo","hugo","腾讯云cos桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["hexo"],"content":"绑定域名 SSL设置 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:3","tags":["hexo","hugo","腾讯云cos桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["hexo"],"content":"域名解析，添加记录 去dns服务商添加域名解析记录CNAME指向上面的域名 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:4","tags":["hexo","hugo","腾讯云cos桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["hexo"],"content":"hexo设置 安装插件 npm install hexo-deployer-cos --save 站点配置文件 deploy: type: cos bucket: yourBucketName #cos桶名称 appId: yourAppId #cos桶名称后数字 secretId: yourSecretId #云API密钥 secretKey: yourSecretKey #云API密钥 region: yourRegion #所属地域 发布还是一样的 hexo clean hexo g -d 结果类似于 ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:5","tags":["hexo","hugo","腾讯云cos桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["hexo"],"content":"CDN 刷新 每次更新博客内容完后，都要登陆腾讯云CDN–缓存刷新，手动刷新一下CDN。 用脚本在每次更新后刷新 安装 npm install qcloud-cdn-node-sdk --save 创建qcloudcdn.js放入script文件夹 const qcloudSDK = require('qcloud-cdn-node-sdk'); qcloudSDK.config({ secretId: '你的ID', secretKey: '你的密钥' }) qcloudSDK.request('RefreshCdnDir', { 'dirs.1': 'http://博客地址' }, (res) =\u003e { console.log(res) }) ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:6","tags":["hexo","hugo","腾讯云cos桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["hexo"],"content":"自动 CDN 刷新配置 (推荐) 进入腾讯云，找到 函数计算 -\u003e CDN 缓存刷新函数 -\u003e 创建 CDN 缓存刷新函数 修改 index.js 内容后重新部署 'use strict' const CosSdk = require('cos-nodejs-sdk-v5') const CdnSdk = require('./common/CdnSdk') const CdnRefreshTask = require('./common/CdnRefreshTask') const { getParams, getObjectUrl, logger, getLogSummary } = require('./common/utils') exports.main_handler = async (event, context, callback) =\u003e { /** * parse param from event and process.env */ const { objects, cdnHosts, secretId, secretKey, token } = getParams(event) logger({ title: 'param is parsed success, param as follow: ', data: { objects, cdnHosts, event } }) /** * init cos instance */ if (!secretId || !secretKey || !token) { throw new Error(`secretId, secretKey or token is missing`) } const cdnSdkInstance = new CdnSdk({ secretId, secretKey, token }) const cosInstance = new CosSdk({ SecretId: secretId, SecretKey: secretKey, XCosSecurityToken: token }) const taskList = objects.map(({ bucket, region, key }) =\u003e { /* 变更内容-START */ const purgeUrls = []; cdnHosts.forEach(host =\u003e { const tempUrl = getObjectUrl({ cosInstance, bucket, region, key, origin: `${/^(http\\:\\/\\/|https\\:\\/\\/)/.test(host) ? '' : 'https://'}${host}` }); purgeUrls.push(tempUrl); // 如果以 /index.html 结尾，则增加目录首页/。 // 例如 https://www.xxxx.com/index.html, 则增加 https://www.xxxx.com/。 if(tempUrl.lastIndexOf('/index.html') == (tempUrl.length - 11)){ purgeUrls.push(tempUrl.substr(0, tempUrl.length - 10)) } }); return new CdnRefreshTask({ cdnSdkInstance, urls: purgeUrls }) /* 变更内容-END */ }) const taskResults = [] for (const task of taskList) { const results = await task.runPurgeTasks() taskResults.push(...results) } logger({ title: 'cdn refresh full logs:', data: taskResults }) const { status, messages } = getLogSummary(taskResults) logger({ messages: messages.map(item =\u003e item.replace(/\\,\\ /g, '\\n')) }) if (status === 'fail') { throw messages.join('; ') } else { return messages.join('; ') } } ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:7","tags":["hexo","hugo","腾讯云cos桶","对象存储"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Java"],"content":"主要方法 static type[] copyof(type[] original,int length) static int binarysearch(type[] a,type key) static boolean equals(type[] a,type[] b) static void fill(type[] a,type val) static void fill(type[] a,int fromindex,int toindex,type val) static void sort(type[] a) ","date":"2019-01-18","objectID":"/posts/arrays/:0:1","tags":["Java","Collator","Comparator","Backend"],"title":"Arrays类及基本使用","uri":"/posts/arrays/"},{"categories":["Java"],"content":"实例代码 package Arrays; import java.text.Collator; import java.util.Arrays; import java.util.Comparator; public class ArraysDemo { public static void main(String agrs[]) { Integer arr[]=new Integer[9]; for(int i=0;i\u003c9;i++) arr[i]=(int)(Math.random()*100); //显示，排序数组 System.out.print(\"原内容：\"); display(arr); Arrays.sort(arr); System.out.print(\"排序后：\"); display(arr); //将值-1分配给数组arr中下标从0到3-1的位置 Arrays.fill(arr, 0,3,-1); System.out.print(\"fill()后：\"); display(arr); //搜索23 System.out.print(\"值23的位置：\"); int index =Arrays.binarySearch(arr, 23);//二分查找 System.out.print(index);//如果查找不到，index为负 System.out.print(\"\\n插入0在3号位置：\"); Arrays.fill(arr,3,4,0); display(arr); System.out.print(\"值0的位置：\"); index =Arrays.binarySearch(arr, 0); System.out.print(index); Integer arr2[]=new Integer[8]; arr2=Arrays.copyOf(arr, arr2.length); //复制8个 System.out.print(\"\\n复制后的数组：\"); display(arr2); if(Arrays.equals(arr, arr2)) System.out.println(\"两数组相同！\"); else System.out.println(\"两数组不相同！\"); System.out.println(\"----------------------------------------\"); String[] str = {\"计算机\",\"黄桑\",\"通信\",\"李瑞豪\"}; Arrays.sort(str); for(int i=0;i\u003cstr.length;i++) System.out.print(str[i]+\" \"); System.out.println(\"\"); //Collator类是用来执行分语言环境的字符串比较，这里用的CHINA Comparator com=Collator.getInstance(java.util.Locale.CHINA);//获取Comparator对象，参数表示按中文排序 //根据指定的 \"比较器\" 产生的顺序对 \"指定对象数组\" 进行排序 Arrays.sort(str,com);//sort(T[] a,Comparator\u003c?super T\u003ec) for(int i=0;i\u003cstr.length;i++) System.out.print(str[i]+\" \"); } static void display(Integer arr[]) { for(int i=0;i\u003carr.length;i++) System.out.print(arr[i]+\" \"); System.out.println(\"\"); } } ","date":"2019-01-18","objectID":"/posts/arrays/:0:2","tags":["Java","Collator","Comparator","Backend"],"title":"Arrays类及基本使用","uri":"/posts/arrays/"},{"categories":["Java"],"content":"程序运行结果 原内容：41 0 44 96 49 96 30 6 87 排序后：0 6 30 41 44 49 87 96 96 fill()后：-1 -1 -1 41 44 49 87 96 96 值23的位置：-4 插入0在3号位置：-1 -1 -1 0 44 49 87 96 96 值0的位置：3 复制后的数组：-1 -1 -1 0 44 49 87 96 两数组不相同！ ---------------------------------------- 李瑞豪 计算机 通信 黄桑 黄桑 计算机 李瑞豪 通信 ","date":"2019-01-18","objectID":"/posts/arrays/:0:3","tags":["Java","Collator","Comparator","Backend"],"title":"Arrays类及基本使用","uri":"/posts/arrays/"},{"categories":["hexo"],"content":" 首先在主题配置文件添加以下关键字 recent_posts: enable: true search: true post: false sidebar: false icon: history title: 近期文章 layout: block ","date":"2019-01-16","objectID":"/posts/recent-posts/:0:0","tags":["hexo"],"title":"在搜索.文章底部.侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["hexo"],"content":"侧栏 在 next/layout/_macro/sidebar.swig 中的 if theme.links 对应的 endif 后面。 {% if theme.recent_posts.enable and theme.recent_posts.sidebar %} \u003cdiv class=\"links-of-blogroll motion-element {{ \"links-of-blogroll-\" + theme.recent_posts.layout }}\"\u003e \u003cdiv class=\"links-of-blogroll-title\"\u003e \u003ci class=\"fa fa-history fa-{{ theme.recent_posts.icon | lower }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul class=\"links-of-blogroll-list\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '3') %} \u003cli\u003e \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} ","date":"2019-01-16","objectID":"/posts/recent-posts/:0:1","tags":["hexo"],"title":"在搜索.文章底部.侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["hexo"],"content":"搜索结果处添加 找到路径H:\\hexo\\themes\\hexo-theme-next\\layout\\_partials\\search下localsearch.swig文件 把\u003cdiv id=\"local-search-result\"\u003e\u003c/div\u003e修改成以下内容（这里显示15篇） \u003cdiv id=\"local-search-result\"\u003e {% if theme.recent_posts.enable and theme.recent_posts.search %} \u003cdiv style=\"text-align: center;padding: 3px 0 0;\"\u003e \u003cdiv style=\"margin-top: 20px;font-size: 18px;font-weight: 600;border-bottom: 1px solid #ccc;\"\u003e \u003ci class=\"fa fa-{{ theme.recent_posts.icon }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul style=\"margin: 0;padding: 0;list-style: none;\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '15') %} \u003cli\u003e \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} \u003c/div\u003e ","date":"2019-01-16","objectID":"/posts/recent-posts/:0:2","tags":["hexo"],"title":"在搜索.文章底部.侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["hexo"],"content":"文章尾部添加 把代码加在H:\\hexo\\themes\\hexo-theme-next\\layout\\_macro\\post.swig里的相应位置（我加在tags后） {% if not is_index and theme.recent_posts.enable and theme.recent_posts.post %} \u003cdiv style=\"text-align: center;padding: 10px 0 0;\"\u003e \u003cdiv style=\"margin: 60px 0px 10px;font-size: 18px;border-bottom: 1px solid #eee;\"\u003e \u003ci class=\"fa fa-{{ theme.recent_posts.icon }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul style=\"margin: 0;padding: 0;list-style: none;font-size: 11px;\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '5') %} \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e\u0026emsp; {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} 其他 可尝试将-date改为-update ","date":"2019-01-16","objectID":"/posts/recent-posts/:0:3","tags":["hexo"],"title":"在搜索.文章底部.侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["Java"],"content":" 大一刚学c的时候以前写过c语言版的。 Math:针对数学进行运算的类 特点：没有构造方法，因为它的成员都是静态的 产生随机数： public static double random(): 产生随机数，范围[0.0,1.0) 产生1-100之间的随机数 int number = (int)(Math.random()*100)+1; 猜数字小游戏案例 class MathDemo { public static void main(String[] args) { //获取随机数 //double d = Math.random(); //System.out.println(d); /* for(int x=0; x\u003c10; x++) { //System.out.println(Math.random()); System.out.println(Math.random()*100); } */ //我们如何获取1-100之间的随机数呢? for(int x=0; x\u003c100; x++) { int number = (int)(Math.random()*100)+1; System.out.println(number); } } } ","date":"2019-01-15","objectID":"/posts/mathclass/:0:0","tags":["Java","Backend"],"title":"java猜数字小游戏（Math类）","uri":"/posts/mathclass/"},{"categories":["Java"],"content":"小游戏 该游戏可以由程序随机产生或由用户输入四个0到9之间的数字，且不重复。玩游戏者通过游戏提示输入八次来匹配上面所输入的数字。A表示位置正确且数字正确，B表示数字正确而位置不正确。 算法： 可以直接算出A类的数目，但是B类的数目直接算出或许会很麻烦，正好我们可以先算出C类数目恰好减去A类就是B类了。 package caishuzi; import java.util.Scanner; class Num { private int[] a= {0,0,0,0}; public Num() {} public void setx() { /*for(int i=0;i\u003c4;i++) { a[i]=(int)(Math.random()*10); }*/ //为了四个互不相同的随机数 a[0]=(int)Math.random()*10+1; for(int i=1;i\u003c4;i++) { int t=(int)(Math.random()*10); for(int j=0;j\u003ci;j++) { if(t==a[j]) { t=(int)(Math.random()*10); j=0; } } a[i]=t; } } public int[] getx() { return a; } public void show() { System.out.println(); for(int i=0;i\u003c4;i++) System.out.print(a[i]+\" \"); System.out.println(); } } public class caishuzi { public static void main(String agrs[]) { int a[] = {0,0,0,0},b[] = {0,0,0,0}; System.out.println(\"* * * *\\n请输入4个数字！A表示位置数字都正确，B表示数字正确位置错误。\"); Scanner sc=new Scanner(System.in); Num n=new Num(); n.setx(); a=n.getx(); /*for(int i=0;i\u003c4;i++) System.out.print(a[i]+\" \"); n.show();*/ for(int k=0;k\u003c10;k++) {//猜测次数 int A=0,B=0,C=0; for(int i=0;i\u003c4;i++) { b[i]=sc.nextInt(); } sc.close(); for(int i=0;i\u003c4;i++){ if (b[i]==a[i])A++; for(int j=0;j\u003c4;j++){ C=b[i]==a[j]?++C:C;//C表示猜测数内和随机数中A类和B类数的数目 if (b[i]==a[j])break; } } B=C-A;// 关键算法（感叹数学魅力） if(A==4) { System.out.println(\"恭喜猜对啦！\"); }else { System.out.println(A+\"A\"+B+\"B\"); } } } } ","date":"2019-01-15","objectID":"/posts/mathclass/:0:1","tags":["Java","Backend"],"title":"java猜数字小游戏（Math类）","uri":"/posts/mathclass/"},{"categories":["Java"],"content":"一次游戏过程 * * * * 请输入4个数字！A表示位置数字都正确，B表示数字正确位置错误。 0 1 2 3 0A1B 0 1 2 4 0A1B 0 1 2 5 1A1B 6 1 2 5 1A2B 1 6 2 5 3A0B 1 6 7 5 恭喜猜对啦！ ","date":"2019-01-15","objectID":"/posts/mathclass/:0:2","tags":["Java","Backend"],"title":"java猜数字小游戏（Math类）","uri":"/posts/mathclass/"},{"categories":["Java"],"content":"面向对象思想(理解) 面向对象是基于面向过程的一种编程思想 思想特点： A:是一种更符合我们思考习惯的思想 B:把复杂的问题简单化 C:让我们从执行者变成了指挥者 举例： A:洗衣服 B:吃饭 C:买电脑 举例并代码体现 把大象装进冰箱 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:1","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"类与对象(掌握) 我们学习编程是为了把现实世界的事物用编程语言描述来实现信息化。 现实世界事物是如何表达的呢? 属性：外在特征 行为：内在行为 我们学习的是java语言，它最基本的单位是类。 所以我们要学会用类来体现一个事物。 类：是一组相关的属性和行为的集合 对象：是该类事物的具体个体。 举例： 学生 类 张三 对象 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:2","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"类的组成(掌握) 成员变量 其实就是变量，只不过定义在类中，方法外，并且可以不用初始化。 成员方法 其实就是方法，只不过不需要static了 案例： 学生类 class Student { String name; int age; public void study() {} } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:3","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"类的使用(掌握) 创建对象 格式：类名 对象名 = new 类名(); 使用成员 成员变量：对象名.变量名; 成员方法：对象名.方法名(…); ","date":"2019-01-15","objectID":"/posts/duixiang/:0:4","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"成员变量和局部变量的区别(理解) 在类中的位置不同 A:成员变量 类中，方法外 B:局部变量 方法的形式参数，或者方法体中 在内存中的位置不同 A:成员变量 在堆中 B:局部变量 在栈中 生命周期不同 A:成员变量 随着对象的存在而存在，随着对象的消失而消失 B:局部变量 随着方法的调用而存在，随着方法的调用完毕而消失 初始化值不同 A:成员变量 有默认初始化值 B:局部变量 没有默认值，必须先声明，赋值，最后才能使用 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:5","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"形式参数问题(理解) 基本类型 基本类型作为形式参数，需要的是该基本类型的值。 引用类型 引用类型作为形式参数，需要的是该引用类型的地址值。(对象) ","date":"2019-01-15","objectID":"/posts/duixiang/:0:6","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"匿名对象(理解) 匿名对象：没有名字的对象。是对象的简化书写方式。 使用场景 A:调用方法，仅仅只调用一次 B:作为实际参数传递 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:7","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"封装(掌握) 隐藏实现细节，提供公共的访问方式 好处： A:隐藏实现细节，提供公共的访问方式 B:提高了代码的复用性 C:提高了代码的安全性 使用原则 A:把成员变量隐藏 B:给出该成员变量对应的公共访问方式 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:8","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"private关键字(掌握) 是一个权限修饰符 可以修饰类的成员(成员变量和成员方法) 仅仅在本类中可以访问,对外提供对应的GetXXX()，SetXXX()等方法 标准代码： class Student { private String name; private int age; public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; } public void study() {} } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:9","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"this关键字(掌握) this：代表本类的对象 应用场景： 解决了局部变量隐藏成员变量的问题。 其他用法和super一起讲。 标准代码： class Student { private String name; private int age; public void setName(String name) {//局部变量 this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void show() { System.out.println(\"姓名是：\"+name+\",年龄是：\"+age); } public void study() { System.out.println(\"学生爱学习\"); } public void eat() { System.out.println(\"学生要吃饭\"); } public void sleep() { System.out.println(\"学生想睡觉\"); } } class StudentTest { public static void main(String[] args) { Student s = new Student(); s.setName(\"林青霞\"); s.setAge(28); s.show(); s.study(); s.eat(); s.sleep(); System.out.println(\"姓名是：\"+s.getName()); System.out.println(\"年龄是：\"+s.getAge()); } } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:10","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"构造方法(掌握) 作用：对对象的数据进行初始化。 特点： A:方法名和类名相同 B:没有返回值类型 C:没有返回值 注意事项 A:如果我们没写构造方法，系统将默认给出无参构造方法 B:如果我们写了构造方法，系统将不再给出默认无参构造方法 建议：我们自己手动给出无参构造方法 给成员变量赋值： A:无参+setXxx() B:带参 一个标准的代码： class Student { private String name; private int age; public Student() {} public Student(String name,int age) {//构造方法 this.name = name; this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void show() { System.out.println(\"姓名是：\"+name+\",年龄是：\"+age); } } class StudentTest { public static void main(String[] args) { //无参+setXxx() Student s = new Student(); s.setName(\"林青霞\"); s.setAge(28); s.show(); //带参 Student ss = new Student(\"张曼玉\",20); ss.show(); } } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:11","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"对象的初始化过程(理解) Student s = new Student();做了哪些事情 A:加载Student.class文件进内存 B:在栈中为s开辟空间 C:在堆中为学生对象开辟空间 D:为学生对象的成员变量赋默认值 E:为学生对象的成员变量赋显示值 F:通过构造方法给成员变量赋值 G:对象构造完毕，把地址赋值给s变量 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:12","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"static关键字(掌握) 是一个状态修饰符。静态的意思 它可以修饰成员变量和成员方法 特点： A:随着类的加载而加载 B:优先于对象存在 C:被所有对象共享 这也是判断我们是不是该使用静态的条件 举例：饮水机(可共享static)和水杯例子。 D:可以通过类名调用 静态修饰的内容，可以通过类名调用，也可以通过对象名调用 方法访问特点 A:普通成员方法 可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法 B:静态成员方法 只能访问静态成员变量，静态成员方法 简记：静态只能访问静态 注意： 静态中是不能有this的。 先进内存的不能访问后进内存的。反之可以。 /* 班级编号应该是被班级每个人都共享的，所以定义一个就应该可以了。 而姓名和年龄，每个人应该是不一样的，所以，每个对象，都应该定义自己的。 在java中，用什么来表示成员变量是被共享的呢? static */ class Student { //姓名 String name; //年龄 int age; //班级编号 //String classNumber; static String classNumber; public Student(String name,int age) { this.name = name; this.age = age; } public Student(String name,int age,String classNumber) { this.name = name; this.age = age; this.classNumber = classNumber; } public void show() { System.out.println(name+\"---\"+age+\"---\"+classNumber); } } class StudentDemo { public static void main(String[] args) { //创建学生对象 Student s1 = new Student(\"林青霞\",28,\"20150306\"); s1.show(); /* Student s2 = new Student(\"马云\",35,\"20150306\"); s2.show(); Student s3 = new Student(\"马化腾\",33,\"20150306\"); s3.show(); */ Student s2 = new Student(\"马云\",35); s2.show(); Student s3 = new Student(\"马化腾\",33); s3.show(); } } /* static:静态关键字。 作用： 可以修饰成员变量和成员方法 特点： A:随着类的加载而加载 B:优先于对象存在 C:被类的所有对象共享 这也是我们判断是否使用静态关键字的条件 饮水机：可以被静态修饰 水杯：不可以被静态修饰 D:可以通过类名调用 我们的调用既可以是对象，还可以是类名 */ class Student { public void show() { System.out.println(\"show\"); } public static void show2() { System.out.println(\"show2\"); } } class StudentDemo2 { public static void main(String[] args) { Student s = new Student(); s.show(); s.show2(); Student.show2(); //Student.show();\u0026ensp; } } /* static的注意事项： A:在静态方法中是没有this关键字的 因为静态是随着类的加载而加载，优先于对象而存在。而this是随着对象的创建而存在。 先进内存的， 不能访问后进内存的；而后进内存的，可以访问先进内存的。 B:静态只能访问静态。 非静态的成员方法： 可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法 静态的成员方法： 只能访问静态的成员变量，静态的成员方法 */ /* class Student { private String name; public static void setName(String name) {//\u0026ensp;静态方法不能用this this.name = name; } public void show() { System.out.println(name); } }*/ class Demo { int x = 10; static int y = 20; public void show() { System.out.println(x); System.out.println(y); } public static void show2() { //System.out.println(x);\u0026ensp; System.out.println(y);//√ } public void show3() { show(); show2(); } public static void show4() { //show();只能访问静态的成员方法 show2(); } } class StudentDemo3 { public static void main(String[] args) { //Student.setName(\"林青霞\"); } } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:13","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"静态成员变量和普通成员变量的区别(理解) 所属不同 静态属于类的，称为类变量 非静态属于对象的，称为对象变量，实例变量 内存空间不同 静态在方法区的静态区 非静态在堆内存 生命周期不同 静态随着类的加载而加载，随着类的消失而消失 非静态随着对象的创建而存在，随着对象的消失而消失 调用不同 静态可以通过类名调用，也可以通过对象名调用。建议通过类名调用 非静态只能通过对象名调用 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:14","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"main方法是静态的(理解) public static void main(String[] args) public:访问权限修饰符，表示最大的访问权限，被jvm调用，所有权限要够大。 static:被jvm调用，不用创建对象，直接类名访问 void:被jvm调用，不需要给jvm返回值 main:一个通用的名称，虽然不是关键字，但是被jvm识别 String[] args: 早期出现是为了接收键盘录入数据的。 ","date":"2019-01-15","objectID":"/posts/duixiang/:0:15","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"实例 /*求和*/ class Demo { private int x; private int y; public Demo() {} public Demo(int x,int y) { this.x = x; this.y = y; } public void setX(int x) { this.x = x; } public int getX() { return x; } public void setY(int y) { this.y = y; } public int getY() { return y; } //成员变量已经有x,y了。这里就没有必要在定义了 /* public int sum(int x,int y) { return x + y; } */ public int sum() { return x + y; } } class Test { public static void main(String[] args) { Demo d = new Demo(); d.setX(10); d.setY(20); int result = d.sum(); System.out.println(result); } } /*求和*/ class Demo { public int sum(int x,int y) { return x + y; } } class Test2 { public static void main(String[] args) { Demo d = new Demo(); int result = d.sum(10,20); System.out.println(result); } } /* 定义一个员工类,自己分析出几个成员， 然后给出成员变量，构造方法，getXxx()/setXxx()方法， 以及一个显示所有成员信息的方法。并测试。 Employee： 成员变量：员工编号,姓名,职位 构造方法：无参，带参 成员方法：getXxx()/setXxx()方法，show() */ class Employee { private String eid; private String name; private String job; public Employee() {} public Employee(String eid,String name,String job) { this.eid = eid; this.name = name; this.job = job; } public void setEid(String eid) { this.eid = eid; } public String getEid() { return eid; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setJob(String job) { this.job = job; } public String getJob() { return job; } public void show() { System.out.println(\"员工编号是：\"+eid+\",姓名是：\"+name+\",职位是：\"+job); } } class EmployeeDemo { public static void main(String[] args) { //无参 Employee e = new Employee(); e.setEid(\"itcast007\"); e.setName(\"周星驰\"); e.setJob(\"高级工程师\"); e.show(); //带参 Employee e2 = new Employee(\"itcast003\",\"刘德华\",\"挖掘机工程师\"); e2.show(); } } ","date":"2019-01-15","objectID":"/posts/duixiang/:0:16","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":"java类中的成员变量和方法访问权限 关键词 同一个类 同一个包 不同包中的子类 不同包中的非子类 private √ default √ √ protected √ √ √ public √ √ √ √ ","date":"2019-01-15","objectID":"/posts/duixiang/:0:17","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":" 水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153）。 ","date":"2019-01-14","objectID":"/posts/xunhuan/:0:0","tags":["水仙花数","Backend","Java"],"title":"java水仙花数（循环）","uri":"/posts/xunhuan/"},{"categories":["Java"],"content":"定义 水仙花数只是自幂数的一种，严格来说3位数的3次幂数才称为水仙花数。 附：其他位数的自幂数名字 一位自幂数：独身数 两位自幂数：没有 三位自幂数：水仙花数 四位自幂数：四叶玫瑰数 五位自幂数：五角星数 六位自幂数：六合数 七位自幂数：北斗七星数 八位自幂数：八仙数 九位自幂数：九九重阳数 十位自幂数：十全十美数 package xunhuan; import java.util.Scanner; public class shuixianhua { public static void main(String[] agrs) { System.out.print(\"指定最大位数N:\"); Scanner input = new Scanner(System.in); int N = input.nextInt(); input.close(); for (int i = 3; i \u003c= N; i++) { int a[] = new int[i]; int num = (int) Math.pow(10, i - 1) + 1; System.out.print(i + \"位的水仙花数有：\\t\"); while (num \u003c= Math.pow(10, i)) { int sum = 0; for (int j = 0; j \u003c i; j++) a[j] = (int) (num / Math.pow(10, j) % 10);//取各个位的数 for (int j = 0; j \u003c i; j++) sum = sum + (int) Math.pow(a[j], i); if (num == sum) System.out.print(num + \"\\t\"); num++; } System.out.print(\"\\n\"); } } } 由于int精度限制，最多算到9位，而且使用常规算法，算到8，9位的时候就特别慢了。 指定最大位数N:10 3位的水仙花数有： 153 370 371 407 4位的水仙花数有： 1634 8208 9474 5位的水仙花数有： 54748 92727 93084 6位的水仙花数有： 548834 7位的水仙花数有： 1741725 4210818 9800817 9926315 8位的水仙花数有： 24678050 24678051 88593477 9位的水仙花数有： 146511208 ","date":"2019-01-14","objectID":"/posts/xunhuan/:0:1","tags":["水仙花数","Backend","Java"],"title":"java水仙花数（循环）","uri":"/posts/xunhuan/"},{"categories":["Java"],"content":"记忆格式： (1)导包： import java.util.Scanner; 注意：位置在class的上面。 (2)创建键盘录入对象： Scanner sc = new Scanner(System.in); (3)获取数据 int i = sc.nextInt(); (4)练习： A:求两个数据的和 B:获取两个数据中较大的值 C:获取三个数据中较大的值 D:比较两个数是否相等 ","date":"2019-01-14","objectID":"/posts/input/:0:1","tags":["Java","Backend"],"title":"java 录入数据","uri":"/posts/input/"},{"categories":["Java"],"content":"实例 package helloworld; import java.util.Scanner; public class helloworld { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int i=sc.nextInt(),j=sc.nextInt(),k=sc.nextInt(); sc.close(); System.out.println(i+\"+\"+j+\"=\"+(i+j)); System.out.println(\"MAXij=\"+Max(i,j)); System.out.println(\"MAXijk=\"+Max(i,j,k)); } //Max()方法重载 static int Max(int i,int j) { return i\u003ej?i:j; } static int Max(int i,int j,int k) { if(i==j) System.out.println(\"i和j相等\"); else if(i==k) System.out.println(\"i和k相等\"); else if(j==k) System.out.println(\"j和k相等\"); return (i=i\u003ej?i:j)\u003ek?i:k; } } 结果 5 5 6 5+5=10 MAXij=5 i和j相等 MAXijk=6 ","date":"2019-01-14","objectID":"/posts/input/:0:2","tags":["Java","Backend"],"title":"java 录入数据","uri":"/posts/input/"},{"categories":["Java"],"content":"标识符： 给类，接口，方法或者变量起名字的符号 ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:1","tags":["Backend","Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"组成规则： A:英文字母大小写 B:数字 C:_和$ ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:2","tags":["Backend","Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"注意事项： A:不能以数字开头 B:不能是Java中的关键字 C:区分大小写 Student,student 这是两个名称 ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:3","tags":["Backend","Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Java"],"content":"常见命名方式： A:包 其实就是文件夹,用于解决相同类名问题 全部小写 单级：com 多级：cn.itcast B:类或者接口 一个单词：首字母大写 Student,Person,Teacher 多个单词：每个单词的首字母大写 HelloWorld,MyName,NameDemo C:方法或者变量 一个单词：全部小写 name,age,show() 多个单词：从第二个单词开始，每个单词首字母大写 myName,showAllStudentNames() D:常量 一个单词：全部大写 AGE 多个单词：每个单词都大写，用_连接 STUDENT_MAX_AGE ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:4","tags":["Backend","Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["English"],"content":"常见情况 ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"由and或both and连接的并列主语，谓语动词一般用复数 English and chinese are two quite different languages. Both brother and sister tire of city life. ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:1","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"一但主语前被no,every,each所修饰时，谓语动词用单数 No desk and (no) chair is seen in the hall. All work and no play makes Jack a dull boy. They each have been to the Forbidden city. each位于主语后，所以谓语动词用复数 ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:2","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"当主语表示同一事物的两个部分，同一个人的两个身份（第二个名词前无冠词），谓语动词用单数 比如the（a）horse and cart a watch and chain a knife and fork a cup and soucer the butter and bread The horse and cart has fallen down the cliff(悬崖). Butter and bread is his favourate. The poet(诗人) and writer has been sentenced(判决) to death. The poet and the writer have been sentenced(判决) to death. ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:3","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"两数相加或相乘，单复皆可，相减或相除，只能用单数，量词做主语，用单数 等于： be,equal,be equal to,make 相加： and,plus 相减： minus 相乘： multily,time 相除： divided by One and one make(makes) two. ","date":"2019-01-12","objectID":"/posts/subject-verb/:1:4","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"就近原则 not only…but also there/here be or,nor,either…or,neither…nor,not…but There is a desk and two chairs in the room. Are you or your sister fond of classical music? An apple or two lies on the desk.(数量词后用单数) One or two apples lie on the desk. Not he but you have come. ","date":"2019-01-12","objectID":"/posts/subject-verb/:2:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"就远原则 两单体两结构三with四除外 like,including rather than,as well as with,together with,along with except,besides,but,in addition to The couple in addition to their child are mean. Lauren,rather than anyone else was chose his partener. A library together with 3000 books was destroyed in the fire. ","date":"2019-01-12","objectID":"/posts/subject-verb/:3:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"时间，金钱，距离，温度，天气，重量等不可数名词，to do,doing,从句做主语时，谓v用单数 To go to bed early and rise early is a good habit. What he says and behaives doesn’t concern me. ","date":"2019-01-12","objectID":"/posts/subject-verb/:4:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"分数，百分数，the rest(+of+n)做主语，用单数 谓语动词由of后面的名词决定，一般用单数。 分数用法： 通常分子读基数，分母读序数，分子超过1时，分母加s。即 基+序(s)+of+n+谓 Most students are in favaour of the contract(契约) but the rest disagree. be favaour of: be for,approve of,support,agree with About two thirds of the earth’s surface is covered by water. ","date":"2019-01-12","objectID":"/posts/subject-verb/:5:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"一些短语 one of+n或the only one of+n,一般用单数（定从根据中心词在of前后） a number of+n（用复数） \u0026 the number of+n（用单数） one in 或 one out of+n (用单数) a large quantity of \u0026 large quantity of + 可\\不可数n a large amount of \u0026 large amounts of + 不可数n He is one of the students who were awarded the other day. He is the only one of the students who was awarded the other day. One of his family was a traitor(卖国贼，叛徒) during the world war two. A number of teenagers are addicted to the Internet. The number of students who are addicted to the Internet is up to(接近于) 15. Large amounts of power are foused on him alone.==a large amount of power is foused on him alone. ","date":"2019-01-12","objectID":"/posts/subject-verb/:6:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"不定代词做主语，谓语动词用单数 all修饰人，谓语动词用复数，修饰物，谓语动词用单数 All are present besides the professor. All that glitters(发光体) is not gold. not与all/both等连用表部分否定 ","date":"2019-01-12","objectID":"/posts/subject-verb/:7:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"the +adj表一类人做主语时，谓语动词用复数 The injured are taken good care of in hospital. The agreeable is not always the useful.(不表人) ","date":"2019-01-12","objectID":"/posts/subject-verb/:8:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"成双成对的词做主语，用复数 trousers(裤子),chopsticks,scissors(剪刀),glasses Pants are what I want. The pair of glasses seems expensive.(谓语动词与表示计量单位的名词形式一致) Three set of fashionable socks are shown in today’s evening proper(恰当地). 一系列： a piece/pair/set/suit/series of ","date":"2019-01-12","objectID":"/posts/subject-verb/:9:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"以s结尾特殊专用名词，用单数 表学科，疾病，山脉，河流，书名，歌名，格言等 maths,physicsa(物理),politics(政治),classics,economics,Aids,SARs,diabetes(糖尿病),arthritis(关节炎),bronchitis(支气管炎),Himalayas,Arabian Night Arabian Night sounds beautiful. ","date":"2019-01-12","objectID":"/posts/subject-verb/:10:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"many a +单n+单谓： “许多” more than one +单n+单谓： “不止一个” Many a man thinks life is meaningless without a purpose/an aim. More than one student has put forward the suggestion. More students than one are against the proposal. More than 20% students were absent at the meeting yesterday.(不止) ","date":"2019-01-12","objectID":"/posts/subject-verb/:11:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"police,people,cattle做主语，用复数 It is reported that police are trying their best to capture the murder. ","date":"2019-01-12","objectID":"/posts/subject-verb/:12:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"the Olympics \u0026 the Olympic games The Olympices is hold every four years. == The Olympic games are hold every four year. ","date":"2019-01-12","objectID":"/posts/subject-verb/:13:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"集体名词做主语，表整体用单数，表成员用复数 family,class,group,team,army,public,crew,population The innovation experiment(革新实验) class consists of 24 students and enjoy chinese. Population in China is 1.4 billion or so(about) 20% (Population) have no access to clean water. ","date":"2019-01-12","objectID":"/posts/subject-verb/:14:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"单复同形，sheep,deer,means,Chinese等谓语动词依据情况而定 Many deer live on the African grassland. ","date":"2019-01-12","objectID":"/posts/subject-verb/:15:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"地点状语位于句首 Among the crow stand his parents. On the wall hangs an alarm clock. ","date":"2019-01-12","objectID":"/posts/subject-verb/:16:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["English"],"content":"“of”: of表所属时，中心词在of之前，谓语动词由中心词决定，特例除外。 ","date":"2019-01-12","objectID":"/posts/subject-verb/:17:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["生活随笔"],"content":" 以前每年都会在QQ空间写每年的总结，可是现在已经过了肆意在空间写说说的年纪了。所幸还有博客这一席之地。 18年主要的收获，经历大概就在下面了，可还是没有学到什么硬本事，寒假还是要学习一下 java 和 jsp。 首先最开心的是在狗年刚开始3月底回到湘潭后，拿下了驾照（年前挂了一次很不爽），可以开共享汽车了，体验共享时代的新滋味。 然后是11月份的软考，虽然没有认真准备考试，还是过了（上午压线）。不知道是今年的容易还是怎么的，反正我考完就觉得挺容易的。 5月底搭建了现在这个hexo静态博客，还收到了一些网上朋友的打赏，感谢！ 用打赏的钱买了两个服务器一个国内的，一个国外的。搭了一个文件浏览器作为自己的网盘,还搭了一个ss梯子供自己翻墙使用。 参加了 2018 年 ACM 的湘潭全国邀请赛，在湘大，虽然很遗憾没有拿奖，但就当走过这步吧，略过。 暑假结束，退出了 E313ACM 实验室，也就没有刷题打比赛了。 大二获得了个国家励志，还不错。hhhh有奖金! 真的很菜但是退实验之前，学院的编程比赛还是运气好拿了个三等奖。 ","date":"2019-01-12","objectID":"/years/2018/:0:0","tags":["总结","生活随笔"],"title":"2018年度总结","uri":"/years/2018/"},{"categories":["English"],"content":" 形式倒装，句子本不是本来的语序。 ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:0","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["English"],"content":"may位于句首，标祝愿 例句 May you succeed. May you have a happy holiday. Long live chairman Mao.(毛主席万古长青) ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:1","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["English"],"content":"whatever直接做成分或放在名词之前，however 放在adv,adj之前或many,much等词之前 例句 Whatever the weather is,he sticks out(坚持) walking outside. Go to stamp sales and buy whatever you can offord. Whatever reasons you have,you should carry out your promise. However many difficulties(n.) you meet with,you should try to overcome them. Whatever difficulties(n.) you meet with,you should try to overcome them. However difficult(adj.) the problem is,we must work it out today. ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:2","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["English"],"content":"the + 比较级，the + 比较级 --\u003e“越…越…” 例句 The hander you study,the greater progress you will make. The more you listen to English,the easier it becomes. The older you grow,the more challenges you will meet. ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:3","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["English"],"content":"感叹句 例句 What an interesting talk they had! How interesting the talk was! ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:4","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["English"],"content":" 完全倒装： 把整个谓语动词放到主语前。 ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:0","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["English"],"content":"表方位或时间的副词(adv)、表地点的介词短语位于句首时 例句 Here comes the bus. In the lecture hall of a university sits a professor. Out rushed the children. Now comes your turn. Up jumped the cat and caught the mouse. Down came the rain and up went the umbrellas. Among the people stood his friend,Jim. (To be) South of the river lies a small factory. 但主语为表示人称的代词时无需倒装 Here are you. Away it flew. ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:1","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["English"],"content":"表语(词/短语)位于句首时，adj/doing/done 例句 Written on the blackboard are the name of these who were late. Gone are the days when we worked together. Standing at the tree is a shy girl with two big eges. Present(adj) at the conference were all leaders of this city. Lying on the grassland is the boy who was injured in the fire. ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:2","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["English"],"content":"存在句there be中，其中be -\u003eexist/arise/follow/enter/appear/live等表状态vi 例句 There come shows for help from the river. There seems something wrong with machine. There remains nothing to be done. There happened an event last week. ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:3","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["English"],"content":" 虽然我英语四级没过，词汇量也不很多，甚至下降了很多，但是对于英语的语法我还是很喜欢的，马上快四级了又，复习整理一下以前的语法笔记。以下内容纯手打！！ 先从倒装句开始吧！分为三大类，部分倒装，完全倒装和形式倒装。先复习第一种。 部分倒装： 把谓语动词的一部分（助动词，be动词，情态动词）提到主语前面。 ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:0","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["English"],"content":"xx也如此，xx也一样 表示前面的内容也适用于后者，用\"so/nor/neither + 动词 + 主语\"句型。表“xx也如此，xx也一样”。可用,、;、and隔开（注意情形）。 例句 They love having lots of friends, so dothe disabled.(这里the + 形容词表一类人) I have had a new idea; so hasmy friends. Lily can’t ride bicycle, nor/neither canlucy. The injured look disappointed(沮丧的), so didsenior citizens.(老人) (否定前缀词≠否定) If you aren’t for the plan; nor/neither willI. , 或 ; 前的句子若为从句，先将主句补充出，其后再根据主句改。 这里主句应为： I will not be for the plan.(be for 同意) It is burning(燃烧) hot today, so it is(那确实) and/; so was (it)yesterday.(这里只用用and或;) Everyone is here and looks upset, so it is with Mary = it is the same withMary. 这个句型同样适用于前面的六个例子，但是前面是并列句必须用这个句型。 The truth is that no one is perfect.When all potential(潜在的) for ugliness in removed, so is all of the potential for beauty. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:1","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["English"],"content":"否定副词或含有否定的介词短位于句首 例句 Neither does Mr.Green know the matter(事件) nor does he care about it. neither……nor…… 既不也不 either……or……要么要么，不是就是 Not only did we lose our way but also (we) came close to losing our lives.(come close to 接近，差一点就) Not until I began to work hard did I realize how much time I had wasted. 从句不倒装，原句为： I didn’t realize how much time I had wasted until I began to work hard. No sooner had they arrived at the tomb than they fell ill.(一……就……) In no case will we give up half-way. Hardly does Jim think it possible to finish the task before/when dark. hardly…before/when 一……就…… 这里取\"几乎不\"释义应该更合适. Not a (single) mistake has Mary made so far.(玛丽到目前为止一个错误也没犯。) not a (single) + 单数名词 表示“一个也没有”%} In no time(立刻马上) Jone worked out the figure(体积). (无否定不倒装) ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:2","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["English"],"content":"only + 状语位于句首 例句 Only in this way are you able to do it well. 倒装前： You are able to do it well only in this way. Only when they returned home did they understand what had happened. Only on such a trip will you gain a better appreciation(理解) of Eurepean literature. Only the teacher got the news that our school could have a 4-day holiday.(同位语从句，only+主语所以不倒装) ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:3","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["English"],"content":"So/Such…that…句型位于句首 So + adj + a/an + 单数名词 = Such + a/an + adj + 单数名词 如此...以至于... so侧重于adj/adv such侧重于n. 比如，so many/much/few/little 例句 So crowded was the art gallery(展览会) that I couldn’t move about (it). Such good weather was it that we all went out last week. Such a lovely girl is kate that everyone likes her. So loudly did he speak that even people next room could hear him. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:4","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["English"],"content":"as引导让步狀语从句 as引导让步状语从句(虽然，即使，尽管，无论)，把从句中的表语，动词，副词提至句首(as 后不用再倒装了)，当表语是名词时，提至句首时一律用零冠词(其中as可用though替代,倒装后省略but,though,however,even,though,although等) 例句 Child as he is,he knows a lot. Poor as King was,he tried his best to help others. Try as he may,he has never made his boss satisfied. Search as you would,you could find no body in the room. Much as I want to buy the car,I can’t afford(支付) it. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:5","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["English"],"content":"把虚拟语气从句中的were,had,should提至句首，并省略if 例句 Had you followwed my advice,you couldn’t have made such a silly mistake. Were you not a boy,you could wear a dress. Should he invite me,I might take part in this party. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:6","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["English"],"content":"表肯定含义的时间频率词位于句首 always,often,many a time(many times多次),every + 时间,now and then(时不时的) 例句 Many a time has he offered me some good suggestions. Now and then does my class teacher warn us not yo use cellphones in the classroom. ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:7","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["English"],"content":"疑问句用部分倒装 普通的疑问句： How do you do that? 除了： What is wrong? = What is the matter? … ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:8","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["hexo"],"content":" 2021/10/2 更新 博客已迁移至 Hugo, 插件演示不适用，已删除。 让文章写的好看又简洁又好用的插件！hexo完整的标签列表，next插件列表 ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:0","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"hexo插件 hexo-lazyload-image npm install hexo-lazyload-image --save First add configuration in _config.yml from your hexo project. lazyload: enable: true onlypost: false loadingImg: # eg ./images/loading.gif hexo-ruby-marks 不支持ruby新标签的浏览器将显示rp中的内容。 \u003cruby\u003e博採眾長\u003crp\u003e（\u003c/rp\u003e \u003crt\u003elruihao.cn\u003c/rt\u003e\u003crp\u003e）\u003c/rp\u003e\u003c/ruby\u003e 博採眾長（ lruihao.cn） 插件使用 npm i hexo-ruby-marks {% ruby _**base**_|_**top text**_ %} hexo-pwa npm install --save hexo-pwa You can configure this plugin in _config.yml.(配置完即可使用不许单独设置manifest.json文件及配置，插件生成) pwa: manifest: path: /manifest.json body: name: hexo short_name: hexo icons: - src: /images/android-chrome-192x192.png sizes: 192x192 type: image/png - src: /images/android-chrome-512x512.png sizes: 512x512 type: image/png start_url: /index.html theme_color: '#ffffff' background_color: '#ffffff' display: standalone serviceWorker: path: /sw.js preload: urls: - / posts: 5 opts: networkTimeoutSeconds: 5 routes: - pattern: !!js/regexp /hm.baidu.com/ strategy: networkOnly - pattern: !!js/regexp /.*\\.(js|css|jpg|jpeg|png|gif)$/ strategy: cacheFirst - pattern: !!js/regexp /\\// strategy: networkFirst priority: 5 hexo-tag-dplayer hexo-tag-dplayer npm install hexo-tag-dplayer --save {% dplayer key=value ... %} key can be dplayer options: 'autoplay', 'loop', 'screenshot', 'hotkey', 'mutex', 'dmunlimited' : bool options, use \"yes\" \"y\" \"true\" \"1\" \"on\" or just without value to enable 'preload', 'theme', 'lang', 'logo', 'url', 'pic', 'thumbnails', 'vidtype', 'suburl', 'subtype', 'subbottom', 'subcolor', 'subcolor', 'id', 'api', 'token', 'addition', 'dmuser' : string arguments 'volume', 'maximum' : number arguments container options: 'width', 'height' : string, used in container element style other: 'code' : value of this key will be append to script tag {% dplayer \"url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4\" \"addition=https://dplayer.daoapp.io/bilibili?aid=4157142\" \"api=https://api.prprpr.me/dplayer/\" \"pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg\" \"id=9E2E3368B56CDBB4\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %} hexo-tag-aplayer more npm install --save hexo-tag-aplayer {% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %} 标签参数 title : 曲目标题 author: 曲目作者 url: 音乐文件 URL 地址 picture_url: (可选) 音乐对应的图片地址 narrow: （可选）播放器袖珍风格 autoplay: (可选) 自动播放，移动端浏览器暂时不支持此功能 width:xxx: (可选) 播放器宽度 (默认: 100%) lrc:xxx: （可选）歌词文件 URL 地址 当开启 Hexo 的 文章资源文件夹 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用： {% aplayer \"Caffeine\" \"Jeff Williams\" \"caffeine.mp3\" \"picture.jpg\" \"lrc:caffeine.txt\" %} {% aplayer \"你离开了南京，从此没人和我说话\" \"李志\" \"https://cdn.lruihao.cn/files/nanjing.mp3\" \"https://p2.music.126.net/UuSe-Vc6rS7JtRJSQgDU2g==/2323268069553116.jpg?param=300x300\" %} hexo-pdf pdf传送门 hexo-filter-flowchart(流程图) 语法 npm install --save hexo-filter-flowchart ```%flow #去掉%号 st=\u003estart: Start|past:\u003ehttps://lruihao.cn[blank] e=\u003eend: End:\u003ehttps://www.lruihao.cn[blank] op1=\u003eoperation: My Operation|past op2=\u003eoperation: Stuff|current sub1=\u003esubroutine: My Subroutine|invalid cond=\u003econdition: Yes or No?|approved:\u003e/hexo/nextplugin.html c2=\u003econdition: Good idea|rejected io=\u003einputoutput: catch something...|request st-\u003eop1(right)-\u003econd cond(yes, right)-\u003ec2 cond(no)-\u003esub1(left)-\u003eop1 c2(yes)-\u003eio-\u003ee c2(no)-\u003eop2-\u003ee ``` hexo-spoiler npm install hexo-spoiler --save If hexo can’t detect this plugin automatically, you need to modify the plugins section of [path_to_your_site]/_config.yml manually, like: plugins:- hexo-spoiler {% spoiler [text] %} It will pixelate your text, and click to reveal. Click again to hide your text again. But you need to add \u003cbr\u003e manually if you want line breaks after/before it. When you writes: {% spoiler text %} {% spoiler ~~text~~ %} {% spoiler *text* %} {% spoiler **text** %}\u003cbr\u003e {% spoiler **hello welcome to 博採眾長！** %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:1","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"宅音乐侧栏播放器插件 体验 源码 目前在next中可能引起部分css冲突，建议在next中使用在单个页面中。 依赖于jQuery，一行js可以引入播放器插件。 ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:2","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"caniuse 使用 {% caniuse feature @ periods %} \u003c!-- Tag Alias --\u003e {% can feature @ periods %} feature : Search for the feature you want on https://caniuse.com, then click on the hash sign to the left of the search result heading and you will get the unique name of this feature. periods : Select the browser versions to display. Supported values: past_1, past_2, past_3, past_4, past_5, current, future_3, future_2, future_1. If this value is empty, the default value 'current' will be used. 栗子 Caniuse without periods {% caniuse fetch %} Caniuse with current period {% can sharedarraybuffer @ current %} Caniuse with future periods {% caniuse loading-lazy-attr @ future_3,future_2,future_1 %} Caniuse with past periods {% caniuse link-rel-modulepreload @ past_1,past_2,past_3,past_4,past_5 %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:3","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"Include Raw This tag include any raw content into your posts. Path is relative to your site source directory. {% include_raw '_data/path/to/file.html' %} Let’s create include-raw.html file in _data directory under site root directory with following content: Any \u003cstrong\u003eraw content\u003c/strong\u003e may be included with this tag. Then in any post we can use this content with include_raw tag: {% include_raw '_data/path/to/include-raw.html' %} Any raw content may be included with this tag. ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:4","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"button more info {% button url, text, icon [class], [title] %} \u003c!-- Tag Alias --\u003e {% btn url, text, icon [class], [title] %} url : Absolute or relative path to URL. text : Button text. Required if no icon specified. icon : FontAwesome icon name (without 'fa-' at the begining). Required if no text specified. [class] : FontAwesome class(es): fa-fw | fa-lg | fa-2x | fa-3x | fa-4x | fa-5x Optional parameter. [title] : Tooltip at mouseover. Optional parameter. \u003cdiv class=\"text-center\"\u003e{% btn #, Text \u0026 Large Icon \u0026 Title, home fa-fw fa-lg, Title %}\u003c/div\u003e ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:5","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"Mermaid more info example {% mermaid gitGraph: %} options { \"nodeSpacing\": 150, \"nodeRadius\": 10 } end commit branch newbranch checkout newbranch commit commit checkout master commit commit merge newbranch {% endmermaid %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:6","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"video Usage {% video url %} Examples {% video https://example.com/sample.mp4 %} {% video /path/to/your/video.mp4 %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:7","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"tab选项卡 “tab\"为选项卡的名称，可以自定义，数字是几表示从第几个选项卡开始。非必须，若数值为-1则隐藏选项卡内容。 查看更多 {% tabs Unique name, [index] %} \u003c!-- tab [Tab caption] [@icon] --\u003e Any content (support inline tags too). \u003c!-- endtab --\u003e {% endtabs %} Unique name : Unique name of tabs block tag without comma. Will be used in #id's as prefix for each tab with their index numbers. If there are whitespaces in name, for generate #id all whitespaces will replaced by dashes. Only for current url of post/page must be unique! [index] : Index number of active tab. If not specified, first tab (1) will be selected. If index is -1, no tab will be selected. It's will be something like spoiler. Optional parameter. [Tab caption] : Caption of current tab. If not caption specified, unique name with tab index suffix will be used as caption of tab. If not caption specified, but specified icon, caption will empty. Optional parameter. [@icon] : FontAwesome icon name (without 'fa-' at the begining). Can be specified with or without space; e.g. 'Tab caption @icon' similar to 'Tab caption@icon'. Optional parameter. {% tabs tab,2 %} \u003c!-- tab --\u003e this is tab1 \u003c!-- endtab --\u003e \u003c!-- tab --\u003e this is tab2 \u003c!-- endtab --\u003e \u003c!-- tab --\u003e this is tab3 \u003c!-- endtab --\u003e {% endtabs %} 数值为-1 {% tabs 选项,-1 %} \u003c!-- tab --\u003e **选项1** \u003c!-- endtab --\u003e \u003c!-- tab --\u003e **选项2** \u003c!-- endtab --\u003e \u003c!-- tab --\u003e **选项3** \u003c!-- endtab --\u003e {% endtabs %} 名字写在选项里面 {% tabs Fourth unique name %} \u003c!-- tab Solution 1 --\u003e **This is Tab 1.** \u003c!-- endtab --\u003e \u003c!-- tab Solution 2 --\u003e **This is Tab 2.** \u003c!-- endtab --\u003e \u003c!-- tab Solution 3 --\u003e **This is Tab 3.** \u003c!-- endtab --\u003e {% endtabs %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:8","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"note便签 主题配置文件搜索note,可设置风格和图标是否显示。 # Note tag (bs-callout). note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 15 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 写法 {% note default %} #### default 类型还有以下几种 {% endnote %} {% note primary %} #### primary 内容 {% endnote %} {% note success %} #### success 内容 {% endnote %} {% note info %} #### info 内容 {% endnote %} {% note warning %} #### warning 内容 {% endnote %} {% note danger %} #### danger 内容 {% endnote %} {% note %} #### 不填 内容 {% endnote %} {% note danger no-icon %} #### danger no-icon 内容 {% endnote %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:9","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"引用(文本居中) {% cq %} **there are test words** {% endcq %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:10","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"Font Awesome图标 Font Awesome 是一套绝佳的图标字体库和CSS框架。 Font Awesome 字体为您提供可缩放矢量图标,它可以被定制大小、颜色、阴影以及任何可以用CSS的样式。 要使用Font Awesome图标，请在HTML页面的 部分中添加以下行： 1、国内推荐 CDN \u003clink rel=\"stylesheet\" href=\"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css\"\u003e 2、海外推荐 CDN \u003clink rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css\"\u003e next已经引用了，可以直接用，比如： \u003ci class=\"fa fa-car\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car\" style=\"font-size:48px;\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car\" style=\"font-size:60px;color:red;\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-lg\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-2x\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-3x\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-4x\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-car fa-5x\"\u003e\u003c/i\u003e 动态图标 \u003ci class=\"fa fa-spinner fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-circle-o-notch fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-refresh fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-cog fa-spin\"\u003e\u003c/i\u003e \u003ci class=\"fa fa-spinner fa-pulse\"\u003e\u003c/i\u003e ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:11","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"代码块等 [language] [title] [url] [link text] code snippet - printf(\"Hello World!\"); + printf(\"Hello_World!\"); iframe 在文章中插入 iframe。 {% iframe url [width] [height] %} ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:12","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"Todo list 已完成 未完成 \u003cul\u003e \u003cli\u003e\u003ci class=\"fa fa-check-square\"\u003e\u003c/i\u003e 已完成\u003c/li\u003e \u003cli\u003e\u003ci class=\"fa fa-square\"\u003e\u003c/i\u003e 未完成\u003c/li\u003e \u003c/ul\u003e \u003c!--或者--\u003e - \u003ci class=\"fa fa-check-square\"\u003e\u003c/i\u003e 已完成 - \u003ci class=\"fa fa-square\"\u003e\u003c/i\u003e 未完成 ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:13","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"Label 主题配置文件中打开 # Label tag. label: true @前面的是label的名字，后面的是要显示的文字 {% label default@default %} primary success info warning danger ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:14","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["hexo"],"content":"其他 包括小色块、左侧色条、右侧色条、上方色条、数字色块（需要自定义样式） ","date":"2018-11-24","objectID":"/posts/nextplugin/:0:15","tags":["hexo"],"title":"hexo插件及next内置样式集","uri":"/posts/nextplugin/"},{"categories":["others"],"content":" 前面我有文章提到怎么提交本地文件到github,coding等远程仓库。每次可以分为三个步骤 git add * (添加需要提交的文件，这里全选) git commit -m “提交信息” git push 但是这样感觉很麻烦每次都要重复输入提交命令和提示信息。 这个时候可以用到windows批处理bat文件(linux的话可以用shell脚本)。用完发现好用到不行! ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:0","tags":["脚本","bat"],"title":"通过bat批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["others"],"content":"新建文本文档 @echo off title Commit git add . set /p m=Message: git commit -m \"%m%\" git push 然后另存为commit.bat文件，只要后缀是bat就行了。 ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:1","tags":["脚本","bat"],"title":"通过bat批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["others"],"content":"使用 把文件放到你原本需要提交代码的本地文件夹。双击运行，输入提交信息回车即可。 ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:2","tags":["脚本","bat"],"title":"通过bat批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["others"],"content":"hexo博客新姿势 hexo提交也很麻烦，当然也要批处理一下呀 hexo clean\u0026\u0026hexo g -d ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:3","tags":["脚本","bat"],"title":"通过bat批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["others"],"content":"其他 死机脚本 (友情提醒千万不要在真机实验，请在虚拟机运行) start cmd ifconfig 另外也说一下linux死机命令。fork炸弹。 死机无非是耗尽系统资源 _(){ _ | _ \u0026 }; _ 这个\u0026指后台运行的意思。 统计文件名 dir \\\\?\\%1 /a:-d /b /o /p /w \u003eFilelist.txt 将需要统计的文件夹拖到bat文件上。 ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:4","tags":["脚本","bat"],"title":"通过bat批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["others"],"content":" 博客app下载 https://ziyuan.lruihao.cn/app/bczc_2.6.2.apk ","date":"2018-11-12","objectID":"/posts/fas-app/:0:0","tags":["lua","fusion"],"title":"博採眾長app","uri":"/posts/fas-app/"},{"categories":["others"],"content":"介绍 使用fusion app对网页进行的封装。 功能： 浏览本博客，主页 私人网盘 2048等小游戏 在线客服，QQ等 pc与移动浏览器标识切换 留言，打赏，博主日志等 分享功能，分享到QQ，微信，浏览器打开等 app内添加书签，自动记录历史记录，刷新等 配合博客的PWA + quicklink功能可实现离线浏览 ","date":"2018-11-12","objectID":"/posts/fas-app/:0:1","tags":["lua","fusion"],"title":"博採眾長app","uri":"/posts/fas-app/"},{"categories":["others"],"content":"下载 app内也可以更新，不过就我自己用，懒得更新。 百度云，密码:479l github下载 PWA应用 地址栏输入: Chrome://flags 搜索并启用以下项目: Desktop PWAs(桌面PWAs)、App Banners(应用横幅)、Experimental App Banners(实验性应用横幅) 重启浏览器使修改的设置生效 点击地址栏最右边按钮 安装“博採眾長” ","date":"2018-11-12","objectID":"/posts/fas-app/:0:2","tags":["lua","fusion"],"title":"博採眾長app","uri":"/posts/fas-app/"},{"categories":["others"],"content":"部分源码 看到这些中文的函数总觉得怪怪的哈哈哈😂 语言：lua 检测更新 --检查测当前是否最新版本 local dl=ProgressDialog.show(activity,nil,'更新检测中…') dl.show() local tt=Ticker() tt.start() packinfo=this.getPackageManager().getPackageInfo(this.getPackageName(),((32552732/2/2-8183)/10000-6-231)/9) version=tostring(packinfo.versionName) versioncode=tostring(packinfo.versionCode) url=\"https://share.weiyun.com/43fa66d8fc95db27141530ed2d006be2\"; function 过滤(content) 版本名=content:match(\"【版本名】(.-)【版本名】\") 版本=content:match(\"【版本】(.-)【版本】\") 内容=content:match(\"【内容】(.-)【内容】\") 链接=content:match(\"【链接】(.-)【链接】\") if(版本名==nil) then 版本名=\"获取失败\" end if(版本==nil) then 版本=\"0\" end if(内容==nil) then 内容=\"获取失败\" end if(链接==nil) then 弹出消息(\"服务器参数配置错误，请过段时间再次尝试\") end if(版本 \u003e versioncode) then dl.dismiss() tt.stop() 对话框() .设置标题(\"检测到更新\") .设置消息(\"版本：\"..version..\"→\"..版本名..\"\\n更新内容：\"..内容) .设置积极按钮(\"下载更新\",function() 下载文件(链接) 弹出消息(\"下载更新中…\") end) .设置消极按钮(\"取消更新\") .显示() else dl.dismiss() tt.stop() 弹出消息(\"当前已是最新版本！\") end end Http.get(url,nil,\"UTF-8\",nil,function(code,content,cookie,header) if(code==200 and content)then content=content:match(\"\\\"html_content\\\":(.-),\"):gsub(\"\\\\u003C/?.-%\u003e\",\"\"):gsub(\"\\\\\\\\\",\"\u0026revs;\"):gsub(\"\\\\n\",\"\\n\"):gsub(\"\u0026nbsp;\",\" \"):gsub(\"\u0026lt;\",\"\u003c\"):gsub(\"\u0026gt;\",\"\u003e\"):gsub(\"\u0026quot;\",\"\\\"\"):gsub(\"\u0026apos;\",\"'\"):gsub(\"\u0026revs;\",\"\\\\\"):gsub(\"\u0026amp;\",\"\u0026\"); 过滤(content) else dl.dismiss() tt.stop() 弹出消息(\"本地网络或服务器异常 \"..code) end end) 方向锁定 --flag在程序启动事件声明的全局变量 if flag==1 then activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR); SetHSP=\"H\" else SetHSP=nil end if SetHSP==nil then --竖屏锁定 activity.setRequestedOrientation(1); flag=1 else flag=0 end 程序启动事件 弹出消息(\"©2018 李瑞豪\") --自动，由物理感应器决定 import \"android.content.pm.ActivityInfo\" flag=1 --程序退出时执行对话框 function onKeyDown(key,event) if(key==4)then if(webView.canGoBack())then webView.goBack() else appinfo=this.getPackageManager().getApplicationInfo(this.getPackageName(),0) applabel=this.getPackageManager().getApplicationLabel(appinfo) 退出确认=对话框() .设置消息(\"您确定要退出 \"..applabel..\" 吗?\") 退出按钮={ [1]=function() 退出确认 .设置积极按钮(\"确认\",function() 退出程序() end ) .设置中立按钮(\"清除缓存\",function() 对话框() .设置消息(\"清除缓存后再次运行程序将变得缓慢\\n您确定要清除 \"..applabel..\" 的缓存吗?\") .设置积极按钮(\"确定\",function() os.execute(\"pm clear \"..this.packageName) 退出程序() end) .设置消极按钮(\"取消\",function() end) .显示() end ) .设置消极按钮(\"取消\") end } math.randomseed(tonumber(tostring(os.time()):reverse():sub(1, 6))) 退出按钮[math.random(1,1)]() 退出确认.show() end return true end end --历史记录 lstads=\"/data/data/\"..activity.getPackageName()..\"/lst.lua\" lstwebads=\"/data/data/\"..activity.getPackageName()..\"/lstweb.lua\" --2.序列化 function slz(obj) local lua = \"\" local t = type(obj) if t == \"number\" then lua = lua .. obj elseif t == \"boolean\" then lua = lua .. tostring(obj) elseif t == \"string\" then lua = lua .. string.format(\"%q\", obj) elseif t == \"table\" then lua = lua .. \"{\\n\" for k, v in pairs(obj) do lua = lua .. \"[\" .. slz(k) .. \"]=\" .. slz(v) .. \",\\n\" end local metatable = getmetatable(obj) if metatable ~= nil and type(metatable.__index) == \"table\" then for k, v in pairs(metatable.__index) do lua = lua .. \"[\" .. slz(k) .. \"]=\" .. slz(v) .. \",\\n\" end end lua = lua .. \"}\" elseif t == \"nil\" then return nil else error(\"can not serialize a \" .. t .. \" type.\") end return lua end function rslz(lua) local t = type(lua) if t == \"nil\" or lua == \"\" then return {} elseif t == \"number\" or t == \"string\" or t == \"boolean\" then lua = tostring(lua) else error(\"can not unserialize a \" .. t .. \" type.\") end lua = \"return \" .. lua local func = loadstring(lua) if func == nil then return nil end return func() end --3.历史记录框布局 function hstshow() hstlayout={ LinearLayout, orientation=\"1\", gravity=\"center\", layout_width=\"wrap_content\", layout_height=\"wrap_content\", { TextView, text=\"\", gravity=\"center\", layout_width=\"wrap_content\", textSize=\"0sp\", background=\"#000000\", layout_height=\"15dp\",}, { TextView, text=\"历史记录\", gravity=\"center\", layout_width=\"wrap_content\", textSize=\"30sp\", textStyle=\"bold\", layout_height=\"50dp\",}, { ListView, id=\"hlst\", items=lst, layout_width=\"fill\", layout_height=\"wr","date":"2018-11-12","objectID":"/posts/fas-app/:0:3","tags":["lua","fusion"],"title":"博採眾長app","uri":"/posts/fas-app/"},{"categories":["others"],"content":"安装 cd ~ curl https://getcaddy.com | bash -s personal http.filemanager ","date":"2018-11-11","objectID":"/posts/caddy-file/:0:1","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["others"],"content":"编写配置文件 vim Caddyfile 内容如下: :80 { filemanager / /sdcard timeouts none gzip } 这里的8080端口号可以随意指定, 如果在手机termux等搭建，由于手机权限比较低, 所以一般设置1024以上的端口.80端口可以直接通过ip访问。如118.24.217.167 如果用域名，先在域名服务商解析ip,再配置文件如下 https://pan.lruihao.cn { filemanager / /sdcard timeouts none tls admin@lruihao.cn gzip } 指定邮箱是为了申请ssl,实现https. ","date":"2018-11-11","objectID":"/posts/caddy-file/:0:2","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["others"],"content":"demo 启动caddy caddy 账号密码默认admin ","date":"2018-11-11","objectID":"/posts/caddy-file/:0:3","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["others"],"content":"设置定时器启动caddy（好像没用,我不会） 为了断开xshell后caddy还在运行。 vim run.sh 编辑以下内容 #!/bin/bash caddy 加权 chmod +x run.sh 设置任务 参考 crontab -e 加入 * * * * * /root/run.sh service crond start ","date":"2018-11-11","objectID":"/posts/caddy-file/:0:4","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["others"],"content":"？？？ 最后误打误撞开启了caddy 昨晚双十一要抢裤子，加上湘潭天气太tm冷了，就上床了，接着用termux远程连接服务器继续搞。结果连接的时候命令输错了-_-! 本来是ssh root@118.24.217.167再输入密码就可以了。这次搞错了多写了个-T,然后运行caddy,ctrl+c 再断开，意外地发现filemanager竟然可以访问了。 ssh -T root@118.24.217.167 caddy Ctrl+c ","date":"2018-11-11","objectID":"/posts/caddy-file/:0:5","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["hexo"],"content":" 最新的next主题已经更新了支持PDF功能，写法也和链接写法一样，可是我没有更新，我按github上那个readme试了一下好像不可以，所以用了另外一种插件的方法。 ","date":"2018-11-09","objectID":"/posts/next-pdf/:0:0","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["hexo"],"content":"iframe(推荐) \u003ciframe src=\"/posts/next-pdf/1.pdf\" style=\"width: 100%;height: 800px;\"\u003e\u003c/iframe\u003e ","date":"2018-11-09","objectID":"/posts/next-pdf/:1:0","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["hexo"],"content":"模板自带 今天（2019.4.3）又看了一下，改了写法，写法和插件一样，我在我的模板里也更新了。（插件模板二选一即可,个人更喜欢插件） 但是如果安装插件后，也是优先模板的pdf脚本解析pdf,所以在我的模板中把模板的pdf脚本先注释了。要启用去掉注释即可。 /* 'use strict'; function pdf(args) { return `\u003cdiv class=\"pdf\" target=\"${args[0]}\" height=\"${args[1] || ''}\"\u003e\u003c/div\u003e`; } hexo.extend.tag.register('pdf', pdf, {ends: false}); */ ","date":"2018-11-09","objectID":"/posts/next-pdf/:2:0","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["hexo"],"content":"pdf插件(推荐) ","date":"2018-11-09","objectID":"/posts/next-pdf/:3:0","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["hexo"],"content":"安装 npm install --save hexo-pdf ","date":"2018-11-09","objectID":"/posts/next-pdf/:3:1","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["hexo"],"content":"使用 {% pdf url %} 比如本文 {% pdf /posts/next-pdf/1.pdf %} ","date":"2018-11-09","objectID":"/posts/next-pdf/:3:2","tags":["hexo"],"title":"next添加支持pdf","uri":"/posts/next-pdf/"},{"categories":["hexo"],"content":"不打赏 出于一些特殊的原因，可能会希望hexo博客某篇单独的文章不打赏，其他文章还是可以打赏的。我是这样做的。 原理： 因为默认的变量值为false,!post.noreward就是true了，所以其他的已经写了的文章而仍然想保留打赏的，就不需要修改了，省去了麻烦，只需要把要改的改成true，取反后就是false,就不会显示了打赏模块了。 ","date":"2018-11-06","objectID":"/posts/noreward/:1:0","tags":["hexo"],"title":"设置单篇文章不打赏、首页不显示文章","uri":"/posts/noreward/"},{"categories":["hexo"],"content":"修改post模板 打开以下路径文件 H:\\hexo\\themes\\hexo-theme-next\\layout\\_macro\\post.swig 查找reward关键词，大概在378行，并添加内容。 ","date":"2018-11-06","objectID":"/posts/noreward/:1:1","tags":["hexo"],"title":"设置单篇文章不打赏、首页不显示文章","uri":"/posts/noreward/"},{"categories":["hexo"],"content":"文章内使用 在头部加上关键词noreward: true，比如本文头部。 --- title: 设置单篇文章不打赏 date: 2018-11-06 13:06:29 tags: - hexo博客 categories: hexo博客 noreward: true notshow: false --- ","date":"2018-11-06","objectID":"/posts/noreward/:1:2","tags":["hexo"],"title":"设置单篇文章不打赏、首页不显示文章","uri":"/posts/noreward/"},{"categories":["hexo"],"content":"其他 本地调试时修改完后记得重启hexo,只要是修改了布局文件就要重新hexo s,修改文章内容等就可以不需要重启，效果如本文 ps: 小声bb,如果有打赏的冲动换一篇文章就是了，嘘！ 其他 顺手改了一下tags的位置，知道tags那一块移到喜欢的位置就好了。 ","date":"2018-11-06","objectID":"/posts/noreward/:1:3","tags":["hexo"],"title":"设置单篇文章不打赏、首页不显示文章","uri":"/posts/noreward/"},{"categories":["hexo"],"content":"首页不显示文章 同理可得找到主题布局文件 layout/index.swig 找到一个for循环，在for循环里面加一个判断就行了。 {% for post in page.posts %} {% if !post.notshow %} {{ post_template.render(post, true) }} {% endif %} {% endfor %} 使用同理，notshow: true 在归档可以看到文章。 ","date":"2018-11-06","objectID":"/posts/noreward/:2:0","tags":["hexo"],"title":"设置单篇文章不打赏、首页不显示文章","uri":"/posts/noreward/"},{"categories":["JavaScript"],"content":" 转自 https://www.cnblogs.com/coober/p/6594379.html 前端开发经常遇到需要判断用户的浏览设备，是pc端还是移动端，移动端使用的是什么手机系统？android、ios、ipad、windows phone等等，有时候还需要知道用户浏览页面是在微信中打开还是在移动端浏览器中打开，等等一系列判断做一些相应的处理。 ","date":"2018-11-03","objectID":"/posts/js-device/:0:0","tags":["JavaScript","他山之石","Frontend"],"title":"js判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["JavaScript"],"content":"首先判断pc端还是移动端 function IsPC() { var userAgentInfo = navigator.userAgent; var Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; var flag = true; for (var v = 0; v \u003c Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u003e 0) { flag = false; break; } } return flag; } ","date":"2018-11-03","objectID":"/posts/js-device/:0:1","tags":["JavaScript","他山之石","Frontend"],"title":"js判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["JavaScript"],"content":"判断用户移动端使用的系统平台 var u = navigator.userAgent; if (u.indexOf('Android') \u003e -1 || u.indexOf('Linux') \u003e -1) { //安卓手机 } else if (u.indexOf('iPhone') \u003e -1) { //苹果手机 } else if (u.indexOf('Windows Phone') \u003e -1) { //winphone手机 } ","date":"2018-11-03","objectID":"/posts/js-device/:0:2","tags":["JavaScript","他山之石","Frontend"],"title":"js判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["JavaScript"],"content":"判断用户是否在微信中打开 function isWeiXin(){ var ua = navigator.userAgent.toLowerCase(); if(ua.indexOf('micromessenger') != -1) { return true; } else { return false; } } ","date":"2018-11-03","objectID":"/posts/js-device/:0:3","tags":["JavaScript","他山之石","Frontend"],"title":"js判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["JavaScript"],"content":"实际运用 根据pc或者移动端控制飘花数目，降低cpu消耗，减少卡顿。demo \u003cscript\u003e function sakuraInit() { $(document).snowfall('clear'); var userAgentInfo = navigator.userAgent; var Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; var flag = true; for (var v = 0; v \u003c Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u003e 0) { flag = false; break; } } if (flag) { $(document).snowfall({image:\"images/1.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/2.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/3.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/4.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); } else { $(document).snowfall({image:\"images/1.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/2.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/3.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/4.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); } } window.onload = sakuraInit(); \u003c/script\u003e ","date":"2018-11-03","objectID":"/posts/js-device/:0:4","tags":["JavaScript","他山之石","Frontend"],"title":"js判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["hexo","Git"],"content":"备份hexo博客 //如果themes/next(主题文件)下面有.git，请删除这个.git文件夹。 cd hexo git init //初始化本地仓库 git add source themes scaffolds _config.yml package.json package-lock.json //将必要的文件依次添加 git commit -m \"blog hexo\" git branch hexo //新建hexo分支 git checkout hexo //切换到hexo分支上 git remote add origin git@github.com:username/username.github.io.git //将本地与Github项目对接 git push origin hexo //push到Github项目的hexo分支上 ","date":"2018-11-03","objectID":"/posts/blog-backup/:0:1","tags":["hexo","Git","Nodejs"],"title":"hexo 博客源码备份","uri":"/posts/blog-backup/"},{"categories":["hexo","Git"],"content":"在其他终端克隆和更新hexo博客 nodejs,git,hexo已经安装好,即搭建完成 克隆hexo博客备份 git clone -b hexo git@github.com:username/username.github.io.git //将Github中hexo分支clone到本地 cd user.github.io npm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init 这样我们的备份文件就会原封不动的拷贝到本地。 写新文章并备份和部署（备用操作） 其实源码拷下来了，这步不做我们也知道怎么做了，完全没必要按照教程死搬硬套。灵活一点就行了。 //进入username.github.io文件夹,应是hexo分支 git pull origin hexo //本地和远端的融合 hexo new post \"new post name\" //写新文章 git add source git commit -m \"xxx\" git push origin hexo //备份 hexo d -g //部署 参考 ","date":"2018-11-03","objectID":"/posts/blog-backup/:0:2","tags":["hexo","Git","Nodejs"],"title":"hexo 博客源码备份","uri":"/posts/blog-backup/"},{"categories":["生活随笔"],"content":"备案 经过时间长达20多天的备案之旅今天终于结束了，也闭馆了20多天，也按相关要求把ICP备案号和公安备案号加载了网站和博客底部。只是今天去岳塘分局签网络安全告知书的时候不小心把身份证落在那个办公室了。亏我走之前一秒还在提醒自己，唉！不过那个办公室的大姐姐挺好的，前面跟我说好星期一来，我还今天上午提前给她打了电话，她还下楼给我开办公楼楼道的门禁，还有我身份证落在那里她说先帮我收着，有时间再去拿！总之，这个姐姐的服务态度五星好评！手动@岳塘分局B204的姐姐。 备案完成也算放下一块提着的石头，可以睡个好觉了！ZzZzzzz ","date":"2018-10-29","objectID":"/posts/beian/:0:0","tags":["生活随笔","网站备案"],"title":"网站备案之旅","uri":"/posts/beian/"},{"categories":["linux"],"content":"今天上机学了几个小命令 read echo if 然后自己写了一个小脚本觉得还挺有趣的 #!/bin/bash #liruihao #menu.sh #sudo apt curl install nyancat sl figlet toilet cowsay echo \"-------------菜-单--------------\" echo \"------------1-打印二维码--------\" echo \"------------2-彩虹猫------------\" echo \"------------3-小火切------------\" echo \"------------4-打字机------------\" echo \"------------5-小许牛------------\" echo \"----------Ctrl+c暂停程序--------\" echo \"\" echo \"请输入序号！\" read i if test $i -eq 1 then echo \"请输入网址！\" read s1 echo $s1 |curl -F-=\\\u003c- qrenco.de fi if test $i -eq 2 then nyancat fi if test $i -eq 3 then sl fi if test $i -eq 4 then echo \"请输入字符串！\" read s2 echo \"选择样式：\" echo \"------样式1-----\" echo \"------样式2-----\" read j if test $j -eq 1 then figlet $s2 else toilet -f mono12 -F gay $s2 fi fi if test $i -eq 5 then echo \"请输入字符串！\" read s3 cowsay $s3 fi echo \"任意建继续！\" read x clear ./menu.sh ","date":"2018-10-29","objectID":"/posts/shell/:0:0","tags":["shell","linux","脚本"],"title":"shell 脚本初体验","uri":"/posts/shell/"},{"categories":["linux"],"content":"搭建Apache web服务 1.安装Apache超文本传输协议(HTTP)服务器的主程序 [root@VM_0_6_centos /]# yum install -y httpd 注意安装目录，可通过cd 命令切换。 2.启动HTTP服务 [root@VM_0_6_centos /]# systemctl start httpd.service 如果启动失败，可通过systemctl status httpd.service查看错误原因。 启动成功，证明http服务已经可以使用，发现还需要把本地文件传到服务器。 默认根目录/var/www/html/ ","date":"2018-10-29","objectID":"/posts/web-server-yun/:0:1","tags":["他山之石","server","linux"],"title":"云服务器 CentOS 系统搭建 web 服务","uri":"/posts/web-server-yun/"},{"categories":["linux"],"content":"使用SSH连接服务器 尝试了两种方式：PuTTY和Xshell（推荐） Xshell方式 官网下载安装Xshell打开，输入ip账号密码连接主机。 使用lrzsz方式上传下载文件 步骤1：在服务器安装lrzsz [root@VM_0_6_centos /]# yum -y install lrzsz 步骤2：输入命令rz打开上传窗口(可以选择多个文件。) 使用sz文件名命令可打开从服务器下载文件的保存窗口。 ","date":"2018-10-29","objectID":"/posts/web-server-yun/:0:2","tags":["他山之石","server","linux"],"title":"云服务器 CentOS 系统搭建 web 服务","uri":"/posts/web-server-yun/"},{"categories":["linux"],"content":"修改HTTP配置 1.VIM编辑器打开配置文件 [root@VM_0_6_centos /]# vim /etc/httpd/conf/httpd.conf 2.按I键进入编辑模式 3.找到并修改以下内容 ServerAdmin 管理员邮箱，用于浏览器请求报错时展示 DocumentRoot 访问根目录（默认：/var/www/html），如项目存放在其他地方，可修改为项目存放位置 \u003cDirectory \"/var/www/html\"\u003e 同DocumentRoot 配置 ServerName 服务器IP或 域名 4.按下ESC键输入:wq保存退出 5.重启服务service httpd restart 6.打开浏览器，输入地址访问 如:我的项目索引html路径为 love/index.html，输入 http://IP地址或域名/love/index.html 7.访问不成功，先检查网络，再查看http服务是否开启，最后检查配置； 访问成功，配置完成。 链接：https://www.jianshu.com/p/0b67c6c5d21d ","date":"2018-10-29","objectID":"/posts/web-server-yun/:0:3","tags":["他山之石","server","linux"],"title":"云服务器 CentOS 系统搭建 web 服务","uri":"/posts/web-server-yun/"},{"categories":["JavaScript"],"content":"获取链接（转） 传送门 在WEB开发中，时常会用到javascript来获取当前页面的url网址信息，在这里是我的一些获取url信息的小总结。 下面我们举例一个URL，然后获得它的各个组成部分：http://i.cnblogs.com/EditPosts.aspx?opt=1 window.location.href(设置或获取整个 URL 为字符串) var test = window.location.href; alert(test); 返回：http://i.cnblogs.com/EditPosts.aspx?opt=1 window.location.protocol(设置或获取 URL 的协议部分) var test = window.location.protocol; alert(test); 返回：http: window.location.host(设置或获取 URL 的主机部分) var test = window.location.host; alert(test); 返回：i.cnblogs.com window.location.port(设置或获取与 URL 关联的端口号码) var test = window.location.port; alert(test); 返回：空字符(如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符) window.location.pathname(设置或获取与 URL 的路径部分（就是文件地址）) var test = window.location.pathname; alert(test); 返回：/EditPosts.aspx window.location.search(设置或获取 href 属性中跟在问号后面的部分) var test = window.location.search; alert(test); 返回：?opt=1 PS：获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用javascript来获得相信应的参数值。 window.location.hash(设置或获取 href 属性中在井号“#”后面的分段) var test = window.location.hash; alert(test); 返回：空字符(因为url中没有) js获取url中的参数值 正则法 function getQueryString(name) { var reg = new RegExp('(^|\u0026)' + name + '=([^\u0026]*)(\u0026|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) { return unescape(r[2]); } return null; } // 这样调用： alert(GetQueryString(\"参数名1\")); alert(GetQueryString(\"参数名2\")); alert(GetQueryString(\"参数名3\")); split拆分法 function GetRequest() { var url = location.search; //获取url中\"?\"符后的字串 var theRequest = new Object(); if (url.indexOf(\"?\") != -1) { var str = url.substr(1); strs = str.split(\"\u0026\"); for(var i = 0; i \u003c strs.length; i ++) { theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]); } } return theRequest; } var Request = new Object(); Request = GetRequest();\u003cbr\u003e// var id=Request[\"id\"]; // var 参数1,参数2,参数3,参数N; // 参数1 = Request['参数1']; // 参数2 = Request['参数2']; // 参数3 = Request['参数3']; // 参数N = Request['参数N']; 指定取 比如说一个url：http://i.cnblogs.com/?j=js,我们想得到参数j的值，可以通过以下函数调用。 function GetQueryString(name) { var reg = new RegExp(\"(^|\u0026)\" + name + \"=([^\u0026]*)(\u0026|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); //获取url中\"?\"符后的字符串并正则匹配 var context = \"\"; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == \"\" || context == \"undefined\" ? \"\" : context; } alert(GetQueryString(\"j\")); ","date":"2018-10-28","objectID":"/posts/href-301/:0:1","tags":["301重定向","JavaScript","Frontend","他山之石"],"title":"使用js准确获取当前页面url网址信息及301重定向实战","uri":"/posts/href-301/"},{"categories":["JavaScript"],"content":"301重定向（实践） 由于之前把blog和网站主页分开在两个仓库所以要想在blog中menu里跳转到站外链接就要做一些处理。以前一直百度不到。 其实想法早就有了，只要在blog首页或者网站首页检测到https://lruihao.cn/home这个链接，或者检测到home字段就自动跳转。想法很简单。可是对js真的一点都不了解，以前百度也找不到实际的效果案例。所以还是自己写吧！附上蹩脚代码。 var path = window.location.href; //alert(path); if (path=='https://lruihao.cn/home/') { window.location.replace(\"https://www.lruihao.cn\"); } 或者 var path = window.location.pathname; //alert(path); if (path=='/home/') { window.location.replace(\"https://www.lruihao.cn\"); } http强制重定向https \u003cscript\u003e var targetProtocol = \"https:\"; var host = \"lruihao.cn\"; //域名判断，因为localhost仅支持http if (window.location.host == host \u0026\u0026 window.location.protocol != targetProtocol){ window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); } \u003c/script\u003e ","date":"2018-10-28","objectID":"/posts/href-301/:0:2","tags":["301重定向","JavaScript","Frontend","他山之石"],"title":"使用js准确获取当前页面url网址信息及301重定向实战","uri":"/posts/href-301/"},{"categories":["others"],"content":" 我用的 win10 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:0","tags":["server","windows"],"title":"windows上搭建web服务器","uri":"/posts/web-server-win/"},{"categories":["others"],"content":"打开控制面板 选择并进入“程序”，双击“启用或关闭Windows服务”，在弹出的窗口中选择“Internet Information Services”下面所有地选项，点击确定后，开始更新服务。 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:1","tags":["server","windows"],"title":"windows上搭建web服务器","uri":"/posts/web-server-win/"},{"categories":["others"],"content":"查看 更新完成后，打开浏览器，输入http://localhost或者127.0.0.1回车，如果此时出现IIS7欢迎界面，说明Web服务器已经搭建成功。 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:2","tags":["server","windows"],"title":"windows上搭建web服务器","uri":"/posts/web-server-win/"},{"categories":["others"],"content":"网站设置 当web服务器搭建成功后，我们下一步所要做的就是把我们开发的网站安装到Web服务器的目录中。一般情况下，当Web服务器安装完成后，会创建路径%系统根目录%inetpub/wwwroot，将我们开发的网站COPY到该路径下。即可实现本地访问该网站。 也可以更改根目录，搜索IIS，点击网站，Default Web Site，基本设置修改物理路径（默认站点名称不要改） 我这里改到了hexo的public相当于hexo部署在本地服务器58.45.227.225 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:3","tags":["server","windows"],"title":"windows上搭建web服务器","uri":"/posts/web-server-win/"},{"categories":["others"],"content":"设置防火墙 让局域网当其它计算机也能访问本地网站资源。具体方法：打开控制面板，选择“系统和安全”，点击“允许程序通过Windows防火墙”，在弹出的对话框中勾选“万维网服务HTTP”右侧的两个复选框，最后点击确定退出。 在局域网中其它计算机上，打开浏览器就可以通过你电脑的ip地址访问了（手机也可以） 本地ip可以通过cmd用ipconfig查看 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:4","tags":["server","windows"],"title":"windows上搭建web服务器","uri":"/posts/web-server-win/"},{"categories":["Git"],"content":"config git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" 第一次使用git的时候需要设置提交者信息。 注意： 如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 ","date":"2018-10-26","objectID":"/posts/gituse/:0:1","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["Git"],"content":"生成ssh 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key： ssh-keygen -t rsa -C \"youremail@example.com\" 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 C:\\Users\\用户名\\或者~/ 下生成 .ssh文件夹，进去，打开 id_rsa.pub，复制里面的 key。去github、coding等平台配置SSH公钥（根据自己情况） ","date":"2018-10-26","objectID":"/posts/gituse/:0:2","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["Git"],"content":"创建本地代码库 在本地创建一个文件夹，作为你上传代码的本地仓库，在这个文件夹内点击右键，选择Git Bash Here，首先要初始化本地仓库: git init 接下来进行远程代码库克隆（事先在coding等中建立一个项目，就是你需要链接的仓库） git clone https://github.com/Lruihao/Lruihao.github.io.git 克隆时会出现输入账号密码的环节正确输入即可。 ","date":"2018-10-26","objectID":"/posts/gituse/:0:3","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["Git"],"content":"代码推送（重点） git status git add * git commit -m \"代码备注随便写\" git push origin master Gearn Git Branching ","date":"2018-10-26","objectID":"/posts/gituse/:0:4","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["termux"],"content":" 前面有一篇文章写到一些,在 Android 上搭建 hexo 博客 本文当初摘要自国光个人博客 如若作者博客IP被墙，可前往国光第三方博客诸如csdn等。备用 ","date":"2018-10-23","objectID":"/posts/termux1/:0:0","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["termux"],"content":"初始化 下载并初始化termux 安装vim 安装编辑器vim pkg install vim 解决中文乱码问题 在home目录下, 新建.vimrc文件 vim .vimrc 添加内容如下: set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 set enc=utf8 set fencs=utf8,gbk,gb2312,gb18030 然后source下变量: source .vimrc 修改启动问候语 vim $PREFIX/etc/motd 按i然后编辑，比如 www.lruihao.cn 李瑞豪 Esc然后：wq退出 管理员权限 手机已经 root,安装tsu, 这是一个su的 termux 版本, 用来在 termux 上替代su: pkg install tsu 然后终端下面输入: tsu 即可切换root用户, 这个时候会弹出root授权提示。在管理员身份下，输入exit可回到普通用户身份。 ","date":"2018-10-23","objectID":"/posts/termux1/:0:1","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["termux"],"content":"美化 Termux-ohmyzsh 作用 ： 美化之外，主要使用了zsh来替代bash作为默认shell。使用一键安装脚本来安装, 一步到位, 顺便启动了外置存储, 可以直接访问 SD 卡下的目录，创建软文件夹。 使用 sh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" 设置色彩样式： 运行chcolor更换色彩样式，或者： ~/.termux/colors.sh 设置字体 运行chfont更换字体，或者： ~/.termux/fonts.sh 需要软件包： curl ","date":"2018-10-23","objectID":"/posts/termux1/:0:2","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["termux"],"content":"访问外置存储 执行过上面的zsh一键配置脚本后, 并且授予文件访问权限的话, 会在家目录生成storage目录，并且生成若干目录，软连接都指向外置存储卡的相应目录 可以让从外置储存复制文件进system分区 创建 QQ 文件夹软连接 ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ 创建blog2文件夹软连接备份文件 ln -s /data/data/com.termux/files/home/storage/shared/blog2 blog2 ","date":"2018-10-23","objectID":"/posts/termux1/:0:3","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["termux"],"content":"安装hexo 安装准备 pkg install nodejs pkg install git npm install hexo-cli -g npm install hexo-deployer-git --save pkg install openssh 初始化hexo hexo init blog cd blog hexo g hexo s 浏览器输入127.0.0.1:4000查看效果 链接github,coding,gitee等远程仓库 ssh-keygen -t rsa -C \"your_email@example.com\" #这将按照你提供的邮箱地址，创建一对密钥(个人喜欢一路回车) 找到~/.ssh/id_rsa.pub这个文件复制里面的内容，到对应的平台生成SSH公钥 设置用户信息 git config --global user.name \"lruihao\" git config --global user.email \"1074627678@qq.com\" 测试链接 ssh -T git@github.com #github ssh -T git@coding.net #coding ssh -T git@gitee.com #gitee 注意#注释部分不要的 站点配置文件 打开站点配置文件填写代码库 例如我的 deploy: - type: git repository: github: git@github.com:Lruihao/Lruihao.github.io.git,master coding: git@git.coding.net:liruihao/liruihao.git,master #message: \"日常更新\" 部署 hexo clean hexo g -d 没出错就可以正常通过相应域名访问了。 https://lruihao.github.io https://liruihao.coding.me https://lruihao.gitee.io //手机hexo效果展示 ","date":"2018-10-23","objectID":"/posts/termux1/:0:4","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["termux"],"content":"ssh连接电脑或者服务器 ssh root@118.24.217.167 会提示输入密码，linux下输入密码是看不到的，大家都知道，小心点别输入错误。 之后就可以手机操作服务器了。 ","date":"2018-10-23","objectID":"/posts/termux1/:0:5","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["termux"],"content":"解决 npm 安装报错（未验证） vim $PREFIX/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js 把里面的 length改成4，我默认的是1。 ","date":"2018-10-23","objectID":"/posts/termux1/:0:6","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["termux"],"content":"nyancat 彩虹猫 彩虹貓（英语：Nyan Cat）是在 2011 年 4 月上传在 Youtube 的视频，并且迅速爆红于网络，並在 2011 年 YouTube 浏览量最高的视频中排名第五. pkg install nyancat nyancat 还有更多姿势这里就不写了，只写一下日常用到的，就这样OK睡觉！ ","date":"2018-10-23","objectID":"/posts/termux1/:0:7","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["termux"],"content":"termux更多常用有趣命令（适用于linux） vim $PREFIX/etc/motd chcolor chfont ~/.termux/colors.sh ~/.termux/fonts.sh echo \"https://www.lruihao.cn\" |curl -F-=\\\u003c- qrenco.de pkg install nyancat nyancat pkg install sl sl pkg install figlet figlet hello pkg install toilet toilet hello toilet -f mono12 -F gay \"hello\" pkg cowsay cowsay \"hello\" pkg install cmatrix cmatrix pkg install w3m w3m www.lruihao.cn cmatrix常用命令如下: cmatrix-a :异步滚动（默认） cmatrix-b :随机粗体 cmatrix-B :全部粗体 cmatrix-o :使用旧风格滚动 cmatrix-x :X window 模式 cmatrix-V :显示版本信息 cmatrix-u :刷新频率，0-9，也就是滚动的快慢 cmatrix-C :显示的颜色，支持green(默认),red,blue,white,yellow,cyan, magenta and black 例如:使用红色 cmatrix -b -C red 使用蓝色 cmatrix -b -C blue 等等........ 主义:在运行状态下,使用0-9数字,可以改变运行速度快慢. 开启你的装逼之路把,骚年! ","date":"2018-10-23","objectID":"/posts/termux1/:0:8","tags":["termux","linux","Nodejs"],"title":"termux基本使用教程","uri":"/posts/termux1/"},{"categories":["Nodejs"],"content":"html网页引用中文字体，文件过大，加载缓慢的解决办法","date":"2018-10-17","objectID":"/posts/web-font/","tags":["字体压缩","Frontend","Nodejs","Backend"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["Nodejs"],"content":"安装 nodeJs 这个不多说，都有。 ","date":"2018-10-17","objectID":"/posts/web-font/:0:1","tags":["字体压缩","Frontend","Nodejs","Backend"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["Nodejs"],"content":"安装字蛛 输入命令 npm install font-spider -g ","date":"2018-10-17","objectID":"/posts/web-font/:0:2","tags":["字体压缩","Frontend","Nodejs","Backend"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["Nodejs"],"content":"运行 安装成功之后就开始压缩了 我的css \u003cstyle type=\"text/css\"\u003e @font-face { font-family: MMT; src: url(\"font/MMT_579767_SOAJ0_0.ttf\"); } \u003c/style\u003e 生成新的字体库，命令行输入 font-spider C:\\Users\\李瑞豪\\Desktop\\love\\index.html 官网 ","date":"2018-10-17","objectID":"/posts/web-font/:0:3","tags":["字体压缩","Frontend","Nodejs","Backend"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["linux"],"content":" 在 Linux 上编译 c 语言文件。 ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:0","tags":["linux","C"],"title":"linux编程初体验","uri":"/posts/linux-hello-c/"},{"categories":["linux"],"content":"打开vim编辑器 (没有就用vi,或者先安装vimsudo apt-get install vim) $ vim ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:1","tags":["linux","C"],"title":"linux编程初体验","uri":"/posts/linux-hello-c/"},{"categories":["linux"],"content":"编辑文件 打开文件编辑器之后编辑文件 首先按Esc再:进入末行命令 再保存为hello.c文件后退出 : w hello.c : q 打开目录看看生成的文件 $ ls ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:2","tags":["linux","C"],"title":"linux编程初体验","uri":"/posts/linux-hello-c/"},{"categories":["linux"],"content":"编译生成可执行文件并执行 $ gcc hello.c -o hello $ ./hello 若权限不够则加可执行权限chmod +x hello ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:3","tags":["linux","C"],"title":"linux编程初体验","uri":"/posts/linux-hello-c/"},{"categories":["others"],"content":"介绍 沐目体 字体简介 #沐目体# 沐目之，湘也。（以女盆友前女友名字命名的字体） 笔头设置 狼毫笔型，粗细为9，速度模式 屏写方式 最新版下载 · 沐目体下载 使用手机造字app手写制作，写了大概1年半吧，终于写完了，写完看效果发现粗细细了点，字型也小了点，只好以后有时间再改罗。基本上还是挺满意的，下面是效果图。 注：仅用于个人非商用！ ","date":"2018-10-12","objectID":"/posts/font-mmt/:1:0","tags":["沐目体"],"title":"一款自己写的字体-沐目体","uri":"/posts/font-mmt/"},{"categories":["others"],"content":"预览 前尘硬化像石头 随缘地抛下便逃走 我绝不罕有 往街里绕过一周 我便化乌有 你还嫌不够 我把这陈年风褛 送赠你解咒 ","date":"2018-10-12","objectID":"/posts/font-mmt/:2:0","tags":["沐目体"],"title":"一款自己写的字体-沐目体","uri":"/posts/font-mmt/"},{"categories":["others"],"content":"字稿 ","date":"2018-10-12","objectID":"/posts/font-mmt/:3:0","tags":["沐目体"],"title":"一款自己写的字体-沐目体","uri":"/posts/font-mmt/"},{"categories":["others"],"content":"概念 流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。 未使用流水线 使用流水线 流水线周期为执行时间最长的一段。 ","date":"2018-10-09","objectID":"/posts/liushuixian/:0:1","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["others"],"content":"流水线计算公式 首先使用理论公式，没有答案用实践公式。 ","date":"2018-10-09","objectID":"/posts/liushuixian/:0:2","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["others"],"content":"流水线吞吐率计算 流水线吞吐率是指单位时间内处理的任务的数量。 基本公式 最大吞吐率 ","date":"2018-10-09","objectID":"/posts/liushuixian/:0:3","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["others"],"content":"流水线加速比 完成一批任务,不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。 公式： S=不使用流水线执行时间/使用流水线执行时间 流水线加速比越高越好，说明使用流水线的效果。 ","date":"2018-10-09","objectID":"/posts/liushuixian/:0:4","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["others"],"content":"流水线的效率 ","date":"2018-10-09","objectID":"/posts/liushuixian/:0:5","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["others"],"content":"例题 ","date":"2018-10-09","objectID":"/posts/liushuixian/:0:6","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["others"],"content":"其他 主机 CISC和RISC 类型 指令 寻址方式 实现方式 其他 CISC(复杂指令集) 数量多，使用频率差别大，可变长格式 支持多种 微程序控制技术(微码) 研制周期长 RISC(精简指令集) 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存 支持方式少 增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线 优化编码，有效支持高级语言 ","date":"2018-10-09","objectID":"/posts/liushuixian/:0:7","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["others"],"content":"数据的表示 数据的表示可分为：原码，反码和补码。（二进制） 原码： 符号位0为正，1为负。 反码： 符号位0为正，1为负。 正数： 反码同原码。 负数： 符号位除外其他位按位取反。 补码： 正数： 同原码。 负数： 符号位除外其他位按位取反再+1。 移码： 补码符号位取反。 ","date":"2018-10-08","objectID":"/posts/data/:0:1","tags":["计算机数据","计算机组成与体系结构"],"title":"计算机数据","uri":"/posts/data/"},{"categories":["others"],"content":"数据表示范围 原码： -(z^n-1 - 1) ~ 2^n-1 - 1 反码： -(z^n-1 - 1) ~ 2^n-1 - 1 补码： -z^n-1 ~ 2^n-1 - 1 (补码正0和负0相同，少占一数位，就多一个范围) 例： 8位二进制，除去符号位还有7位，7个1为最大数，相当于8个1减1，也就是2^7-1,所以范围就算出来了。 ","date":"2018-10-08","objectID":"/posts/data/:0:2","tags":["计算机数据","计算机组成与体系结构"],"title":"计算机数据","uri":"/posts/data/"},{"categories":["others"],"content":"浮点数运算 对阶（小阶对大阶）+ 尾数计算（科学计数法）+ 结果规格化（科学技术法） ","date":"2018-10-08","objectID":"/posts/data/:0:3","tags":["计算机数据","计算机组成与体系结构"],"title":"计算机数据","uri":"/posts/data/"},{"categories":["JavaScript"],"content":" 这几天看到别人的博客有开关灯效果，就想给自己的博客也加一个，其实以前就在想了。经过谷歌百度后这样实现了。css+js 如何给Web页面增加夜间模式功能? 其实所谓的夜间模式就是在页面上增加一个透明的遮罩层，但是遮罩层会挡住页面元素， 解决方法是 添加DIV，给DIV的outline属性一个很大的outline-width值，用outline的边框作为遮罩，这样既能正常点击页面元素，又能达到夜间模式的效果。 ","date":"2018-09-27","objectID":"/posts/night/:0:0","tags":["JavaScript","Frontend"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":"css部分 \u003cstyle\u003e .cover{ position:fixed; top: 0px; left: 0px; outline:5000px solid rgba(0, 0, 0, 0);//初始亮度 z-index: 99999; } \u003c/style\u003e ","date":"2018-09-27","objectID":"/posts/night/:0:1","tags":["JavaScript","Frontend"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":"js部分 \u003cscript\u003e var brightness; //显示遮罩 function cover(brightness) { if (typeof(div) == 'undefined') { div = document.createElement('div'); div.setAttribute('style', 'position:fixed;top:0;left:0;outline:5000px solid;z-index:99999;'); document.body.appendChild(div); } else { div.style.display = ''; } div.style.outlineColor = 'rgba(0,0,0,' + brightness + ')'; } //事件监听 window.addEventListener('keydown', function(e) { if (e.altKey \u0026\u0026 e.keyCode == 90) { cover(brightness = 0.3); } if (e.altKey \u0026\u0026 e.keyCode == 88) { cover(brightness = 0); } if (e.altKey \u0026\u0026 e.keyCode == 38) { if (brightness - 0.05 \u003e 0.05) cover(brightness -= 0.05); } if (e.altKey \u0026\u0026 e.keyCode == 40) { if (brightness + 0.05 \u003c 0.95) cover(brightness += 0.05); } }, false); \u003c/script\u003e ","date":"2018-09-27","objectID":"/posts/night/:0:2","tags":["JavaScript","Frontend"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":"html部分 \u003cdiv class=\"cover\"\u003e\u003c/div\u003e ","date":"2018-09-27","objectID":"/posts/night/:0:3","tags":["JavaScript","Frontend"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":"使用 Alt+Z:打开夜间模式 Alt+X:关闭 Alt+↑:增加亮度 Alt+↓:降低亮度 ","date":"2018-09-27","objectID":"/posts/night/:0:4","tags":["JavaScript","Frontend"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":" 从暑假到现在有好几个小伙伴问我博客的标题怎么变来变去的，不想再和每个人都说一遍了，耽误时间，索性写一下。 ","date":"2018-09-26","objectID":"/posts/crash-cheat/:0:0","tags":["JavaScript","Frontend","hexo"],"title":"网页离开时改变标题“崩溃欺骗”","uri":"/posts/crash-cheat/"},{"categories":["JavaScript"],"content":"创建一个js文件 我们先创建一个js文件，我们用记事本就好了，然后改个文件名，不妨就叫crash-cheat.js吧，你们可以随意！ 然后把文件放到source文件夹的js文件夹的src里面。（我用的next主题，放这里统一存放，其他主题随意） 崩溃欺骗(Jquery版) var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', \"https://i.loli.net/2018/08/24/5b7fcb00ed9bf.png\"); document.title = '怎么回事╭(°A°`)╮'; clearTimeout(titleTime); } else { $(\"[rel='icon']\").attr('href', \"https://i.loli.net/2018/09/25/5baa4f21661e7.png\"); document.title = '小老弟(ฅ\u003eω\u003c*ฅ)'; titleTime = setTimeout(function () { document.title = OriginTitle; $(\"[rel='icon']\").attr('href', \"/images/favicon-32x32-next.png\"); }, 2000); } }); 崩溃欺骗(JS版) var oldTitle = document.title; var titleTime; //標題恢復計時器 document.addEventListener(\"visibilitychange\", function () { if (document.hidden) { document.querySelector(\"[rel='icon']\").setAttribute(\"href\", \"/images/icons/favicon-32.png\"); document.title = \"網站崩潰了！\"; clearTimeout(titleTime); } else { document.title = \"其實並沒有！\"; document.querySelector(\"[rel='icon']\").setAttribute(\"href\", \"/images/icons/crash.png\"); titleTime = setTimeout(function () { document.title = oldTitle; }, 1000); } }); ","date":"2018-09-26","objectID":"/posts/crash-cheat/:1:0","tags":["JavaScript","Frontend","hexo"],"title":"网页离开时改变标题“崩溃欺骗”","uri":"/posts/crash-cheat/"},{"categories":["JavaScript"],"content":"使用 在hexo\\themes\\hexo-theme-next\\layout文件路径找到layout.swig文件，其他有些主题用的是.ejs后缀，一样的。 然后打开文件，在\u003cbody\u003e\u003c/body\u003e之间加入调用刚刚的js。 \u003cscript type=\"text/javascript\" src=\"/js/src/crash-cheat.js\"\u003e\u003c/script\u003e 重新部署博客就可以了。 ","date":"2018-09-26","objectID":"/posts/crash-cheat/:2:0","tags":["JavaScript","Frontend","hexo"],"title":"网页离开时改变标题“崩溃欺骗”","uri":"/posts/crash-cheat/"},{"categories":["Git","linux"],"content":"下载git wget https://github.com/git/git/archive/v2.14.1.zip ","date":"2018-09-22","objectID":"/posts/linux-git/:0:1","tags":["Git","linux"],"title":"linux/centos 下的安装git","uri":"/posts/linux-git/"},{"categories":["Git","linux"],"content":"安装依赖 sudo yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker ","date":"2018-09-22","objectID":"/posts/linux-git/:0:2","tags":["Git","linux"],"title":"linux/centos 下的安装git","uri":"/posts/linux-git/"},{"categories":["Git","linux"],"content":"解压git unzip v2.14.1.zip 注： unzip命令用不了，具体步骤如下： #yum list | grep zip/unzip #yum install zip #yum install unzip 基本完成，如果在编译的时候出现错误：gcc : error trying to exec 'cc1plus': execvp : No sunch file or directory 可以用gcc -v/g++ -v 来查看gcc 版本，会发现没有安装。安装如下： #yum list | grep gcc #yum install gcc-c++ #yum install unzip ","date":"2018-09-22","objectID":"/posts/linux-git/:0:3","tags":["Git","linux"],"title":"linux/centos 下的安装git","uri":"/posts/linux-git/"},{"categories":["Git","linux"],"content":"将git安装到/usr/local上 先进入git文件夹 编译 安装 cd git-2.14.1 make prefix=/usr/local all make prefix=/usr/local install ","date":"2018-09-22","objectID":"/posts/linux-git/:0:4","tags":["Git","linux"],"title":"linux/centos 下的安装git","uri":"/posts/linux-git/"},{"categories":["Git","linux"],"content":"验证是否安装完成 git --version … ","date":"2018-09-22","objectID":"/posts/linux-git/:0:5","tags":["Git","linux"],"title":"linux/centos 下的安装git","uri":"/posts/linux-git/"},{"categories":["生活随笔"],"content":" 手机便签里保存的一段话，也记不得在哪看到的了。 每一个优秀的人，都有一段沉默的时光，是那一段时光，不抱怨不诉苦，最后渡过了这段感动自己的日子。 什么都还没有，所以没有卖弄的资格。如果有了什么，就没有卖弄的必要。 人生的每一笔经历，都在书写你的简历。多做你本以为微不足道的事情，回头看的时候，都有着无法细数的刻度。 自己拼出来的东西，和别人送到嘴边的东西，意义和珍惜的程度都大为不同。 我从不担心我努力了不优秀，只担心优秀的人都比我更努力。 决定你高度的是你对自己的要求。 以前的我，常常担心、常常犹豫，可现在我发现，人生的每一个阶段，都需要我们有一种能力同一时间完成很多重要的事情。 学习的时候，我们要谈谈恋爱。工作的时候，我们要担心家庭。所以，这是一种平衡的能力。 相信我，你做得到。因为，那么那么多学长学姐都走过来了，所以不用怕不用怕，你从来都不是一个人。 不要抱怨，抱怨永远只能显示你没本事。因为如果你有本事，就可以改变现状，而不只是忍受。 既然改变不了，又不够走开，那么就沉默地接受现实。 隐忍，是我们抵抗世界的力量，当你拥有，你才有资格自由。 我们做的每一个决定，都是由自己来买单。 而当你可以把自己不喜欢的东西都做好的时候，相信你一定可以把自己喜欢的东西做的更好！ 努力和效果之间，永远有这样一段距离。成功和失败的唯一区别是，你能不能坚持挺过这段无法估计的距离。 你可以试试？ 坚持做一件事情，坚持下去。不管它是什么。 选择本身，就是放弃另一种跋涉的可能。尝试倾听自己内心的声音，而不是外在的掌声。 尝试选择适合自己的，而不是别人眼里最好的。 尝试决定我们的决定，不是因为选项表面的光鲜亮丽。 所以，每当我们每做一个选择的时候，总记得兑现心中的对自己的承诺。 不要想得到一切，对生活对自己都慷慨一些。 ","date":"2018-09-21","objectID":"/posts/mood/:0:0","tags":["生活随笔"],"title":"每一个优秀的人，都有一段沉默的时光","uri":"/posts/mood/"},{"categories":["linux"],"content":" vim 编辑器是 Linux 系统自带的文本编辑器 ","date":"2018-08-31","objectID":"/posts/vim/:0:0","tags":["vim","linux","termux"],"title":"linux系统进入退出vim编辑器及termux修改问候语","uri":"/posts/vim/"},{"categories":["linux"],"content":"进入VIM编辑器 vim /\u003c路径\u003e/文件名.后缀名 如果这个文件，以前是没有的，则为新建，会有提示，否者则没有提示。 进入编辑器后，按\"I”，即切换到“INSERT”状态。即插入状态，就可以通过上下左右移动光标，或空格、退格及回车等进行编辑内容了，和WINDOWS是一样的了。 ","date":"2018-08-31","objectID":"/posts/vim/:1:0","tags":["vim","linux","termux"],"title":"linux系统进入退出vim编辑器及termux修改问候语","uri":"/posts/vim/"},{"categories":["linux"],"content":"退出vim编辑器的方法及区别 退出编辑器分为4种情况： 保存退出 正常退出 不保存退出 强制退出 ","date":"2018-08-31","objectID":"/posts/vim/:2:0","tags":["vim","linux","termux"],"title":"linux系统进入退出vim编辑器及termux修改问候语","uri":"/posts/vim/"},{"categories":["linux"],"content":"保存退出 先按Esc退出插入状态，再输入英文:,在下方会出现冒号，等待输入命令,再输入WQ回车就保存了,W,Q分别对应功能， W: write ,写入 Q: quit ,退出 保存退出还有二个方法： 在最后输入命令时，直接输入\"x\"，也是一样的，即X=WQ。 最快捷的方法：按了ESC后，直接按shift+zz，或者切换到大写模式按ZZ，就可以保存退出了，即是按两下大写的Z。 查看命令 cat /\u003c路径\u003e/文件名.后缀名 ","date":"2018-08-31","objectID":"/posts/vim/:2:1","tags":["vim","linux","termux"],"title":"linux系统进入退出vim编辑器及termux修改问候语","uri":"/posts/vim/"},{"categories":["linux"],"content":"正常退出 正常退出有个前提条件是：打开的文本文件在内容上没有被改动过。 按了ESC后再输入冒号:，在输入命令时，直接输入q。 ","date":"2018-08-31","objectID":"/posts/vim/:2:2","tags":["vim","linux","termux"],"title":"linux系统进入退出vim编辑器及termux修改问候语","uri":"/posts/vim/"},{"categories":["linux"],"content":"不保存退出 很多时候打开了文件，或者修改了一些地方，才发现错了，非常需要不保存退出。 先按ESC，再输入冒号:，在输入命令时，直接输入q!。 ","date":"2018-08-31","objectID":"/posts/vim/:2:3","tags":["vim","linux","termux"],"title":"linux系统进入退出vim编辑器及termux修改问候语","uri":"/posts/vim/"},{"categories":["linux"],"content":"强制退出 强制退出。这个实在是不应该做的操作，因为很操蛋！ 先按ESC，再按冒号:，在输入命令时，直接输入!，但退出后，会有提示修改内容尚未保存，是否继续！ ","date":"2018-08-31","objectID":"/posts/vim/:2:4","tags":["vim","linux","termux"],"title":"linux系统进入退出vim编辑器及termux修改问候语","uri":"/posts/vim/"},{"categories":["linux"],"content":"termux使用vim修改问候语 没错又是termux,就是以前一篇文章提到的“安卓上的Linux”。 先 vim $PREFIX/etc/motd 如果报错，好像是要安装Python pkg install python 进入后先使用dd把以前的问候语一行一行删掉，再输入i，进入插入操作，修改你自定义的问候语。之后ESC,再:WQ退出保存，重启termux就可以看到修改后的效果了。如图。 termux美化termux-ohmyzsh ","date":"2018-08-31","objectID":"/posts/vim/:3:0","tags":["vim","linux","termux"],"title":"linux系统进入退出vim编辑器及termux修改问候语","uri":"/posts/vim/"},{"categories":["hexo"],"content":"警告 2018/11/1说明 next主题好像更新了，现在自带的可以用了，如果可以用了，以下教程可以忽略！！！ 最近有几个小伙伴问我博客的字数统计怎么实现的，怎么网上的教程不管用啊？一开始我搭建博客的时候也遇到了类似的问题，按照github上wordcount的readme操作后，并没有什么用，我打开post相关配置文件并没有发现发现wordcount这个关键词，next本身似乎也并没有在主题配置文件提供选项(或许是个人原因)，所以只好自己动手加一个了。为了不重复回答问题，先做个原创记录。转载请注明出处。在此抛转引玉，如果有更好的方法请在留言区提出，我会及时更改。同时也希望小伙伴多发扬折腾精神，多专研，少提问，毕竟还是RTFSC大法好！(Read the fucking source code) ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:0:0","tags":["hexo","字数统计"],"title":"hexo next主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["hexo"],"content":"安装 wordcount github 如果没有安装 hexo-wordcount 插件，先安装该插件： npm i --save hexo-wordcount # Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) npm install hexo-wordcount@2 --save ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:1:0","tags":["hexo","字数统计"],"title":"hexo next主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["hexo"],"content":"post添加 打开hexo\\themes\\hexo-theme-next\\layout\\_macro路径下的post.swig文件，既然没有字数统计那么我们就加一个，简单暴力地直接在阅读数后面加上一条就好了，在文件类搜索关键词busuanzi,我用的是不蒜子,如果用的了leancloud的搜leancloud就好了，其他类似。找到这段代码后 {% if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %} \u003cspan class=\"post-meta-divider\"\u003e|\u003c/span\u003e \u003cspan class=\"post-meta-item-icon\" {% if not theme.post_meta.item_text %} title=\"{{ __('post.views') }}\" {% endif %}\u003e \u003ci class=\"fa fa-{{ theme.busuanzi_count.post_views_icon }}\"\u003e\u003c/i\u003e {% if theme.post_meta.item_text %} {{__('post.views') + __('symbol.colon') }} {% endif %} \u003cspan class=\"busuanzi-value\" id=\"busuanzi_value_page_pv\" \u003e\u003c/span\u003e \u003c/span\u003e {% endif %} 在endif上面，即本文代码块那个空行处添加以下代码 \u003cspan class=\"post-meta-divider\"\u003e|\u003c/span\u003e \u003cspan title=\"{{ __('post.wordcount') }}\"\u003e\u003cspan class=\"post-meta-item-icon\"\u003e\u003ci class=\"fa fa-file-word-o\"\u003e\u003c/i\u003e\u003c/span\u003e字数： {{ wordcount(post.content) }}\u003c/span\u003e ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:2:0","tags":["hexo","字数统计"],"title":"hexo next主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["hexo"],"content":"全站添加 打开hexo\\themes\\hexo-theme-next\\layout\\_partials路径下footer.swig文件，在你喜欢的位置添加以下代码 \u003cdiv class=\"theme-info\"\u003e \u003cdiv class=\"powered-by\"\u003e\u003c/div\u003e \u003cspan class=\"post-count\"\u003e全站共 {{ totalcount(site) }} 字\u003c/span\u003e \u003c/div\u003e ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:3:0","tags":["hexo","字数统计"],"title":"hexo next主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["hexo"],"content":"搭建这个博客以来，隔一段时间就出现一次部署失败的错误，每次都差不多，莫名其妙地出现的。。。前几次不知道怎么瞎搞就好了。 现在做一下记录，防止以后出错用。 错误如下 Connection reset by 13.229.188.59 port 22 fatal: sha1 file '\u003cstdout\u003e' write error: Broken pipe fatal: The remote end hung up unexpectedly fatal: The remote end hung up unexpectedly FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Error: Connection reset by 13.229.188.59 port 22 fatal: sha1 file '\u003cstdout\u003e' write error: Broken pipe fatal: The remote end hung up unexpectedly fatal: The remote end hung up unexpectedly at ChildProcess.\u003canonymous\u003e (H:\\Hexo\\node_modules\\hexo-util\\lib\\spawn.js:37:17) at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at ChildProcess.cp.emit (H:\\Hexo\\node_modules\\cross-spawn\\lib\\enoent.js:40:29) at maybeClose (internal/child_process.js:850:16) at Socket.\u003canonymous\u003e (internal/child_process.js:323:11) at emitOne (events.js:96:13) at Socket.emit (events.js:188:7) at Pipe._handle.close [as _onclose] (net.js:492:12) ... 确保ssh正常，hexo-deploy-git插件正常的情况下删除.deploy_git文件夹就好了。 最后吐槽一下，这个鬼错误，搞我一晚上醉了。。。我又打算重装了的。。。。。/吐血 ","date":"2018-08-21","objectID":"/posts/hexo-d-error/:0:0","tags":["hexo"],"title":"hexo d 出错","uri":"/posts/hexo-d-error/"},{"categories":["JavaScript","hexo"],"content":" 本文适合我这种纯小白。 目前为止，全网也就只有一个博主写到过这样动态显示subtitle的文章。传送门（关键词：js,后加载） 但是嘞，该博写的不怎么详细，17年底写的。当然更大的可能是next更新了一些文件结构，所以不适合现在使用了。以前我按原博的流程配置了一下没成功就搁在那里了，今天突然心血来潮。翻了翻原博主博客的源码，再与自己的对比了一下，发现了一些端倪。稍作调整后如下： ","date":"2018-08-20","objectID":"/posts/dongtaisub/:0:0","tags":["hexo","JavaScript","Frontend"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["JavaScript","hexo"],"content":"修改站点配置文件，主要修改subtitle subtitle: 不怕万人阻挡，只怕自己投降。W你如何回忆，决定你是一个怎样的人！W这是一个句子。W这是另一个句子。W这些句子你们不要搞一样的不然怎么叫个性签名-_-！。 句子与句子之间以W分割，后续需要根据该标志位去拆分句子组。 小伙伴们博主这里只是提供一个思路，不要和我用一模一样的啊，不然撞了多尴尬呀 ","date":"2018-08-20","objectID":"/posts/dongtaisub/:1:0","tags":["hexo","JavaScript","Frontend"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["JavaScript","hexo"],"content":"修改 header\\index.swig 修改 themes\\next\\layout_partials\\header 下面的 index.swig 文件 在最开头添加如下代码： (这里用的原博的js) \u003cscript\u003e function GetRandomNum(Min,Max) { var Range = Max - Min; var Rand = Math.random(); return(Min + Math.round(Rand * Range)); } function setSidebarMarginTop (headerOffset) { return $('#sidebar').css({ 'margin-top': headerOffset }); } function getHeaderOffset () { return $('.header-inner').height() + CONFIG.sidebar.offset; } window.onload=function(){ var subtitle = \"{{config.subtitle}}\"; var mytitle = subtitle.split(\"W\"); var max = mytitle.length-1; var index = GetRandomNum(0,max); var text = mytitle[index]; $(\"#helloTitle\").html(text); var headOffset = getHeaderOffset(); setSidebarMarginTop(headOffset); //动态subtitle设置 } \u003c/script\u003e ","date":"2018-08-20","objectID":"/posts/dongtaisub/:2:0","tags":["hexo","JavaScript","Frontend"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["JavaScript","hexo"],"content":"修改 brand.swig 找到 {% if subtitle %} {% if theme.seo %} ... {% else %} ... {% endif %} {% endif %} 把这一段，把原来的修改成以下代码即可 ps: title和subtitle的字体还有颜色也可以在这个文件修改，即使用style标签，按个人爱好修改也可不要。 {% if subtitle %} {% if theme.seo %} \u003cp class=\"site-subtitle\" id=\"helloTitle\" itemprop=\"description\"\u003e\u003c/p\u003e {% else %} \u003cp id=\"helloTitle\" class=\"site-subtitle\"\u003e\u003c/p\u003e {% endif %} {% endif %} 之后部署后每次刷新就可以看到不同的 subtitle 了，开心😀 ","date":"2018-08-20","objectID":"/posts/dongtaisub/:3:0","tags":["hexo","JavaScript","Frontend"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["JavaScript","hexo"],"content":"今日诗词 今日诗词 \u003cspan id=\"jinrishici-sentence\"\u003e正在加载今日诗词....\u003c/span\u003e \u003cscript src=\"https://sdk.jinrishici.com/v2/browser/jinrishici.js\" charset=\"utf-8\"\u003e\u003c/script\u003e 正在加载今日诗词.... ","date":"2018-08-20","objectID":"/posts/dongtaisub/:4:0","tags":["hexo","JavaScript","Frontend"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["JavaScript","hexo"],"content":"api 调用 直接 js 调用 api 简单快速 2021/9/30 更新 一言api-参数详见 已经挂了 \u003cdiv\u003e \u003cscript type=\"text/javascript\" src=\"https://api.imjad.cn/hitokoto/?cat=\u0026charset=utf-8\u0026length=\u0026encode=js\u0026fun=sync\u0026source=\"\u003e\u003c/script\u003e \u003cdiv id=\"hitokoto\"\u003e \u003cscript\u003ehitokoto()\u003c/script\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2018-08-20","objectID":"/posts/dongtaisub/:5:0","tags":["hexo","JavaScript","Frontend"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["生活随笔"],"content":"七夕又快到了，分享一个曾经玩过的代码，用C语言画一个跳动的心，很有逼格有木有。 #include \u003cstdio.h\u003e#include \u003cmath.h\u003e#include \u003cwindows.h\u003e#include \u003ctchar.h\u003e float f(float x, float y, float z) { float a = x * x + 9.0f / 4.0f * y * y + z * z - 1; return a * a * a - x * x * z * z * z - 9.0f / 80.0f * y * y * z * z * z; } float h(float x, float z) { for (float y = 1.0f; y \u003e= 0.0f; y -= 0.001f) if (f(x, y, z) \u003c= 0.0f) return y; return 0.0f; } int main() { HANDLE o = GetStdHandle(STD_OUTPUT_HANDLE); _TCHAR buffer[25][80] = { _T(' ') }; _TCHAR ramp[] = _T(\".:-=+*#%@\"); for (float t = 0.0f;; t += 0.1f) { int sy = 0; float s = sinf(t); float a = s * s * s * s * 0.2f; for (float z = 1.3f; z \u003e -1.2f; z -= 0.1f) { _TCHAR* p = \u0026buffer[sy++][0]; float tz = z * (1.2f - a); for (float x = -1.5f; x \u003c 1.5f; x += 0.05f) { float tx = x * (1.2f + a); float v = f(tx, 0.0f, tz); if (v \u003c= 0.0f) { float y0 = h(tx, tz); float ny = 0.01f; float nx = h(tx + ny, tz) - y0; float nz = h(tx, tz + ny) - y0; float nd = 1.0f / sqrtf(nx * nx + ny * ny + nz * nz); float d = (nx + ny - nz) * nd * 0.5f + 0.5f; *p++ = ramp[(int)(d * 5.0f)]; } else *p++ = ' '; } } for (sy = 0; sy \u003c 25; sy++) { COORD coord = { 0, sy }; SetConsoleCursorPosition(o, coord); WriteConsole(o, buffer[sy], 79, NULL, 0); } Sleep(33); } } exe文件下载 ","date":"2018-08-15","objectID":"/posts/heart/:0:0","tags":["生活随笔","C","C++"],"title":"高逼格c语言画心","uri":"/posts/heart/"},{"categories":["Git"],"content":"在git没有运行完成之前强制关闭，下次提交的时候会产以下生错误，或者类似的。 fatal: Unable to create '/xxx/xx/.git/index.lock': File exists. If no other git process is currently running, this probably means a git process crashed in this repository earlier. Make sure no other git process is running and remove the file manually to continue. 原因是在你进行某些比较费时的git操作时自动生成，操作结束后自动删除，相当于一个锁定文件，目的在于防止对一个目录同时进行多个操作。 有时强制关闭进行中的git操作，这个文件没有被自动删除，之后你就无法进行其他操作，必须手动删除，进入.git文件中删除，打开显示隐藏文件。如果没有看见.git文件夹，可以直接用命令 rm -f ./.git/index.lock。之后就可以正常使用。 ","date":"2018-08-14","objectID":"/posts/git-index-lock/:0:0","tags":["Git"],"title":"git index.lock","uri":"/posts/git-index-lock/"},{"categories":["termux"],"content":" 暑假刚开始的时候放假回家没带电脑，只能玩手机，想折腾一下博客都没有条件，在一个发现一个app,卧槽😱，termux真的强大！(初始化需要科学上网)安卓手机上的linux简直了，在手机就可以搭了一个hexo博客，只要在github上实现分支管理就可以多终端同步更新了。恕我学疏才浅，还只想到这些！一开始想回校后，折腾一下hexo-admin实现类似动态博客一样的多终端管理(手动滑稽)，现在发现termux这样子的操作也不错嘛，挺装哔hhhhhh**部署后的效果** ","date":"2018-08-11","objectID":"/posts/termux/:0:0","tags":["termux","hexo","Nodejs"],"title":"在Android上搭建hexo博客","uri":"/posts/termux/"},{"categories":["termux"],"content":"准备 Termux 文件管理器（RE,MT文件管理器等高级一点的） ","date":"2018-08-11","objectID":"/posts/termux/:1:0","tags":["termux","hexo","Nodejs"],"title":"在Android上搭建hexo博客","uri":"/posts/termux/"},{"categories":["termux"],"content":"开始 打开Termux，输入$pkg install nodejs安装Nodejs，在输入pkg install git安装Git。 过程会出现一个提示，输入y回车确认即可。 按照Hexo官网提示安装Hexo。 npm install hexo-cli -g hexo init blog cd blog 注意ssh配置先安装：pkg install openssh 然后按照基本操作配置Hexo，GitHub或者gitee,coding等连上，部署测试一次。 安装部署插件npm install hexo-deployer-git --save，部署hexo d -g 没有问题的话进行下一步。 ","date":"2018-08-11","objectID":"/posts/termux/:2:0","tags":["termux","hexo","Nodejs"],"title":"在Android上搭建hexo博客","uri":"/posts/termux/"},{"categories":["termux"],"content":"编辑 写文章的话创建md文件命令和电脑上一样，文件管理器打开/data/data/com.termux/files/home/i/source/_posts/ 编辑文章md文件。这种方式需要Root。 没有Root的话可以使用Vim，网上很多教程。但是这种方式相对来说更麻烦。 ","date":"2018-08-11","objectID":"/posts/termux/:3:0","tags":["termux","hexo","Nodejs"],"title":"在Android上搭建hexo博客","uri":"/posts/termux/"},{"categories":["termux"],"content":"参考 termux高级终端安装使用配置教程 使用 Termux 在手机上运行 linux 黑科技 hexo 搭建过程 超详细教程 ","date":"2018-08-11","objectID":"/posts/termux/:4:0","tags":["termux","hexo","Nodejs"],"title":"在Android上搭建hexo博客","uri":"/posts/termux/"},{"categories":["termux"],"content":"效果图(未连接github，coding等) 效果图1 效果图2 效果图3 效果图4 ","date":"2018-08-11","objectID":"/posts/termux/:5:0","tags":["termux","hexo","Nodejs"],"title":"在Android上搭建hexo博客","uri":"/posts/termux/"},{"categories":["ACM"],"content":"链接：https://www.nowcoder.com/acm/contest/157/A 来源：牛客网 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:0","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列(组合数学)","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"题目描述 xb有m种石子，每种无限个，Ta想从这些石子中取出n个，并按顺序排列起来，为了好看，相邻的石子不能相同。xb想知道有多少种排列的方法。 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:1","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列(组合数学)","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"输入描述: 第一行有两个正整数n，m。 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:2","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列(组合数学)","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"输出描述: 第一行一个整数，表示在m种石子中取出n个的排列方案数模1000000007后的值。 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:3","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列(组合数学)","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"示例1 输入 1 1 输出 1 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:4","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列(组合数学)","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"示例2 输入 2 3 输出 6 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:5","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列(组合数学)","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"示例3 输入 3 3 输出 12 ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:6","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列(组合数学)","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"备注: 对于100%的测试数据： 1 ≤ n, m ≤ 1000 数据量较大，注意使用更快的输入输出方式。 水题。。。 #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ long long n,m,ans; scanf(\"%lld%lld\",\u0026n,\u0026m); ans=m; for(int i=1;i\u003cn;i++) ans=(ans*(m-1))%1000000007; printf(\"%lld\\n\",ans); return 0; } ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:7","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列(组合数学)","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"题目链接 Dreamoon wants to climb up a stair of n steps. He can climb 1 or 2 steps at each move. Dreamoon wants the number of moves to be a multiple of an integer m. What is the minimal number of moves making him climb to the top of the stairs that satisfies his condition? ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:0","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"Input The single line contains two space separated integers n, m (0 \u003c n ≤ 10000, 1 \u003c m ≤ 10). ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:1","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"Output Print a single integer — the minimal number of moves being a multiple of m. If there is no way he can climb satisfying condition print - 1 instead. ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:2","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"Examples input 10 2 output 6 input 3 5 output -1 ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:3","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"Note For the first sample, Dreamoon could climb in 6 moves with following sequence of steps: {2, 2, 2, 2, 1, 1}. For the second sample, there are only three valid sequence of steps {2, 1}, {1, 2}, {1, 1, 1} with 2, 2, and 3 steps respectively. All these numbers are not multiples of 5. 有一个n级台阶，每次可以走一级或两级，问最少的步数是多少，且步数必须是m的倍数。 找一下数学公式就好了。 具体看代码。 #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ int x,n,m; cin\u003e\u003en\u003e\u003em; if(n\u003cm){ cout\u003c\u003c-1\u003c\u003cendl; return 0; } if(n==m){ cout\u003c\u003cn\u003c\u003cendl; return 0; } if(n%2==0){ x=n/2%m; if(x==0) cout\u003c\u003cn/2\u003c\u003cendl; else cout\u003c\u003cn/2+m-x\u003c\u003cendl; }else if(n%2!=0){ x=(n/2+1)%m; if(x==0) cout\u003c\u003cn/2+1\u003c\u003cendl; else cout\u003c\u003c(n/2+1)+m-x\u003c\u003cendl; } return 0; } ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:4","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"题目链接 ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:0","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi(组合数学)","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"题目大意 就是给定两个字符串，第一个字符串由\"+\",\"-“组成，第二个字符串由”+\",\"-\",\"?“组成，“+”代表加1，\"-“代表减一，“?“代表可取正也可取负，问第二个字符串的位置和第一个字符串相等的概率是多少。 我一开始的想法是把（+1，-1）^n 看成和二项式定理一样的展开始式，只不过把乘法改为加法，然后得到公式 c(n,0)(n+(-1)0)+c(n,1)(n-1+(-1)1)+c(n,i)(n-i+(-1)i)+...+c(n,n)(n-n+(-1)n) 化简一下可知通项为c(n,i)(n-2*i) 然后我对第一个串求出位置sum,第二个串先求出已知位置sum1，然后记录下？的个数，然后遍历找出展开式中某一项n-2i+sum1==sum，这样x的系数就是可能出现位置相等的所有情况，用(n-2i)/系数和就是概率了啊，可是为什么不对呢，本地调试，数据没问题，可是交到cf上第二组都过不了，烦亏我还觉得想到一个独辟的方法呢，过不了。。。 //cf错误报告，思前恐后不晓得why,wtf???先码着吧 Test: #2, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER Input +-+- +-?? Output -0.000000000000 Answer 0.500000000000 Checker Log wrong answer 1st numbers differ - expected: '0.5000000', found: '-0.0000000', error = '0.5000000' ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:1","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi(组合数学)","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"错误代码 #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ int i,j,cnt=0; long long c[11][11],sum=0,sum1=0; for(i = 0; i \u003c 11; i++){//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(j = 1; j \u003c i; j++) c[i][j] = c[i-1][j] + c[i-1][j-1]; } string a,b; cin\u003e\u003ea\u003e\u003eb; //cout\u003c\u003ca\u003c\u003cendl\u003c\u003cb\u003c\u003cendl; int len=a.length(); for(i=0;i\u003clen;i++) if(a[i]=='+') sum+=1; else sum-=1; for(i=0;i\u003cb.length();i++){ if(b[i]=='+') sum1+=1; else if(b[i]=='-')sum1-=1; if(b[i]=='?') cnt++; } if(sum==sum1\u0026\u0026cnt==0){ printf(\"1.000000000000\\n\"); return 0; } int flag=0; int x=0; for(j=0;j\u003c=cnt;j++) x+=c[cnt][j]; //cout\u003c\u003cx\u003c\u003cendl; for(i=0;i\u003c=cnt;i++) if(cnt-2*i+sum1==sum){ flag=1; long double y=c[cnt][i]*1.0/x; printf(\"%.12llf\\n\",y); } if(!flag)printf(\"0.000000000000\\n\"); return 0; } 想不通，没办法只好换思路。。。。 我先分别记下a,b串的'+','-','?‘个数，然后后我们很容易知道，如要a,b位置相等,则加号和减号的数目，两串要相等，且a中的加号要比b中已知的加号要多，减号也要比b中已知的要多，否则打死都不会相等的，仔细比划一下就知道了。然后有z个‘?’，相当于有z个坑，让我们去填使得a,b相等。只能填+或-，设加号差等于x-p,所以概率就等于c(z,x-p)/2^z。 ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:2","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi(组合数学)","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"AC代码 #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ string a,b; int x,y,z,p,q,c[11][11],i,j; for(i = 0; i \u003c 11; i++){ c[i][0] = 1; c[i][i] = 1; for(j = 1; j \u003c i; j++) c[i][j] = c[i-1][j] + c[i-1][j-1]; } cin\u003e\u003ea; cin\u003e\u003eb; x=y=z=p=q=0; for(i=0;i\u003ca.length();i++) if(a[i]=='+') x++; else y++; for(i=0;i\u003cb.length();i++){ if(b[i]=='+') p++; else if(b[i]=='-') q++; else z++; } if(x==p\u0026\u0026z==0){ printf(\"1.000000000000\\n\"); return 0; } if(x-p\u003c0||y-q\u003c0) { printf(\"0.000000000000\\n\"); return 0; } x=x-p; printf(\"%0.12f\",c[z][x]*1.0/(2\u003c\u003c(z-1))); return 0; } 几分钟写完后面的代码，心中一万头草泥马在奔腾。。。。 ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:3","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi(组合数学)","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"转载注明，侵删 ","date":"2018-08-10","objectID":"/posts/euclid/:0:0","tags":["数学","数论","ACM","欧几里得","他山之石","C++","C"],"title":"The equation-SGU106(扩展欧几里得)","uri":"/posts/euclid/"},{"categories":["ACM"],"content":"题意： 给出a,b,c,x1,x2,y1,y2，求满足ax+by+c=0，且x∈[x1,x2],y∈[y1,y2]的整数解个数。 ","date":"2018-08-10","objectID":"/posts/euclid/:0:1","tags":["数学","数论","ACM","欧几里得","他山之石","C++","C"],"title":"The equation-SGU106(扩展欧几里得)","uri":"/posts/euclid/"},{"categories":["ACM"],"content":"分析： 对于解二元一次不定方程，容易想到利用扩展欧几里得求出一组可行解后找到通解，下面来介绍一下欧几里得以及扩展欧几里得。 欧几里得： 又名辗转相除法，是用来计算两个数的最大公约数，其中就是利用gcd(a,b)=gcd(b,a mod b)来求解。下证gcd(a,b)=gcd(b,a mod b)的正确性： 设a,b的一个公约数为d 设a mod b=r，则a=kb+r(k为整数)，r=a-kb 因为d|a,d|b 所以d|a-kb,即d|r，而r=a mod b 所以d为b,a mod b的公约数 又因为d也为a,b的公约数，所以（a,b)和(b,a mod b)的公约数一样，所以最大公约数必然一样，得证。 代码描述： int gcd(int a,int b) { if (b==0) return a; return gcd(b,a%b); } 扩展欧几里得 顾名思义，为上述欧几里得算法的扩展。欧几里得是用来求a,b的最大公约数，那么扩展欧几里得不仅能求出a,b的最大公约数，还能求出满足ax+by=gcd(a,b)的一组可行解。 求解过程中，扩展欧几里得比欧几里得多了一个赋值过程，具体证明如下： 设ax1+by1=gcd(a,b),bx2+(a mod b)y2=gcd(b,a mod b) 因为由欧几里得算法可知，gcd(a,b)=gcd(b,a mod b) 所以ax1+by1=bx2+(a mod b)y2 因为a mod b=a-(a div b)*b（div为整除 所以有ax1+by1=bx2+(a-(a div b)*b)y2 将右边移项，展开得： ax1+by1=ay2+bx2-(a div b)*b*y2 =ay2+b[x2-(a div b)]y2 所以可得： x1=y2 y1=x2-(a div b)*y2 将得到的的x1,y1递归操作求解x2,y2，如此循环往复，将会像欧几里得一样得到b=0的情况，此时递归结束，返回x=1,y=0，回溯得解。 代码描述： 此函数返回的是a,b的最大公约数，同时也求解出满足ax+by=gcd(a,b)的一组可行的(x,y) int exgcd(int a,int b,int \u0026x,int \u0026y) { if (b==0) {x=1;y=0;return a;} int t=exgcd(b,a%b,x,y); int x0=x,y0=y; x=y0;y=x0-(a/b)*y0; return t; } 关于求解二元一次不定方程ax+by=c 首先，如果c不是gcd(a,b)的倍数，方程显然无解。 扩展欧几里得求解的是ax+by=gcd(a,b)=1的可行解，但是题目中并没有说c与a,b互质之类的条件，所以需要在开始时两边同时除以gcd(a,b)。 设d=gcd(a,b) 设a'=a/d,b'=b/d,c'=c/d, 则下面需要求解a’x+b’y=c’的整数解，而gcd(a',b')=1， 则我们只需求a’x+b’y=1的可行解 直接使用扩展欧几里得，得到(x',y'),则最终解为x'*c',y'*c'设为(x0,y0)。 现在得到了一组可行解，但是如何得到通解呢？ 将(x0,y0)代入ax+by=c，则有 a*(x0)+b*(y0)=c 通过拆添项，可有： a*(x0+1*b)+b*(y0-1*a)=c a*(x0+2*b)+b*(y0-2*a)=c a*(x0+3*b)+b*(y0-3*a)=c …… a*(x0+k*b)+b*(y0-k*a)=c (k∈Z) 至此，我们得到了通解的方程 x=x0+k*b y=y0-k*a (k∈Z) 这样，所有满足ax+by=c的可行解都可求出。 ","date":"2018-08-10","objectID":"/posts/euclid/:0:2","tags":["数学","数论","ACM","欧几里得","他山之石","C++","C"],"title":"The equation-SGU106(扩展欧几里得)","uri":"/posts/euclid/"},{"categories":["ACM"],"content":"具体实现 有了主体算法，下面要谈到具体实现了。 先处理一下无解的情况： 当a=0并且b=0，而c≠0时，显然无解； 当a=0,b=0，而c=0时，[x1,x2],[y1,y2]都为可行解，根据乘法原理，可行解的个数为(x2-x1+1)*(y2-y1+1); 当a=0 b≠0时： 此时即为求解by=c，则y=c/b， 如果c/b不是整数或c/b不在[y1,y2]的范围内，无解 否则[x1,x2]内全部整数都为可行解. 当b=0,a≠0时，同上。 若c不是gcd(a,b)的个数，方程显然无解。 处理完了一些繁琐的细节后，下面是具体的求解过程： 扩展欧几里得求解的是ax+by=c，而本题是ax+by+c=0，需将c移项。 对于本道题，首先要注意的是，对于负数的模运算在此算法中无法得到正确解，所以要处理一下a,b,c的正负情况。 如果a为负数，只需将a取相反数后，再处理一下x∈[x1,x2]的范围。当a取了相反数，相当于把x也取反，则需要把x的范围由[x1,x2]转变成[-x2,-x1],类似于把数轴反了过来。b同理。 利用扩展欧几里得解二元一次不定方程，得到一组可行解(x0,y0)。 因为题目中对x,y有条件约束，而有x=x0+kb,y=y0-kb，我们可以求出满足x∈[x1,x2],y∈[y1,y2]的k的取值范围, 即为求解x1\u003c=x0+kb\u003c=x2,y1\u003c=y0-kb\u003c=y2的整数k的个数 但是在求解这两个一次函数的过程中，会有除不尽的现象，该如何取整呢？ 举个例子 当出现2.5\u003c=k\u003c=5.5时，我们需要的可行的k为3,4,5，所以需要将2.5向上取整得到3，5.5向下取整得到5，即为3\u003c=k\u003c=5； 当出现-5.5\u003c=\u003c=-2.5时，我们需要的可行的k为-5,-4,-3,所以需要将-5.5向上取整得到-5,-2.5向下取整得到-3，即为-5\u003c=k\u003c=-3； 正负数的情况都已经考虑完全了，可以得到取整的结论：上界下取整，下界上取整。 最后，将得到的两个范围取交集，得到[l,r]，则最终答案为r-l+1。 这样，本题就可以完美解决了。 // BY Rinyo #include\u003ccstdio\u003e#include\u003ccmath\u003elong long a,b,c,x1,x2,yy1,y2,x0,yy0; inline long long cmin(const long long \u0026x,const long long \u0026y) {return x\u003cy?x:y;} inline long long cmax(const long long \u0026x,const long long \u0026y) {return x\u003ey?x:y;} long long gcd(long long a,long long b) { if (b==0) return a; return gcd(b,a % b); } void exgcd(long long a,long long b) { if (b==0){x0=1;yy0=0;return;} exgcd(b,a%b); long long t=x0;x0=yy0;yy0=t-a/b*yy0; return; } int main() { scanf(\"%I64d%I64d%I64d%I64d%I64d%I64d%I64d\",\u0026a,\u0026b,\u0026c,\u0026x1,\u0026x2,\u0026yy1,\u0026y2); c=-c; if (c\u003c0) {a=-a;b=-b;c=-c;} if (a\u003c0) {a=-a;long long t=x1;x1=-x2;x2=-t;} if (b\u003c0) {b=-b;long long t=yy1;yy1=-y2;y2=-t;} if (a==0 \u0026\u0026 b==0) { if (c==0) { printf(\"%I64d\",(x2-x1+1)*(y2-yy1+1)); return 0; } printf(\"0\");return 0; } else if (a==0) { if (c %b ==0) if (c/b\u003c=y2 \u0026\u0026 c/b\u003e=yy1) {printf(\"%I64d\",x2-x1+1);return 0;} printf(\"0\");return 0; } else if (b==0) { if (c%a==0) if (c/a\u003c=x2 \u0026\u0026 c/a\u003e=x1) {printf(\"%I64d\",y2-yy1+1);return 0;} printf(\"0\");return 0; } long long d=gcd(a,b); if (c%d!=0){printf(\"0\");return 0;} a=a/d;b=b/d;c=c/d; exgcd(a,b); x0=x0*c;yy0=yy0*c; double tx2=x2,tx1=x1,tx0=x0,ta=a,tb=b,tc=c,ty1=yy1,ty2=y2,ty0=yy0; long long down1=floor(((tx2-tx0)/tb)),down2=floor(((ty0-ty1)/ta)); long long r=cmin(down1,down2); long long up1=ceil(((tx1-tx0)/tb)),up2=ceil(((ty0-ty2)/ta)); long long l=cmax(up1,up2); if (r\u003cl) printf(\"0\"); else printf(\"%I64d\",r-l+1); return 0; } 扩展欧几里得模板 #include\u003ciostream\u003eusing namespace std; int exgcd(int a,int b,int \u0026x,int \u0026y) { if(b==0) { x=1; y=0; return a; } int gcd=exgcd(b,a%b,x,y); int x2=x,y2=y; x=y2; y=x2-(a/b)*y2; return gcd; } int main() { int x,y,a,b; cout\u003c\u003c\"请输入a和b:\"\u003c\u003cendl; cin\u003e\u003ea\u003e\u003eb; cout\u003c\u003c\"a和b的最大公约数:\"\u003c\u003cendl; cout\u003c\u003cexgcd(a,b,x,y)\u003c\u003cendl; cout\u003c\u003c\"ax+by=gcd(a,b) 的一组解是:\"\u003c\u003cendl; cout\u003c\u003cx\u003c\u003c\" \"\u003c\u003cy\u003c\u003cendl; return 0; } ","date":"2018-08-10","objectID":"/posts/euclid/:0:3","tags":["数学","数论","ACM","欧几里得","他山之石","C++","C"],"title":"The equation-SGU106(扩展欧几里得)","uri":"/posts/euclid/"},{"categories":["ACM"],"content":"题目链接 ","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:1","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282(快速幂+对数运算)","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"题目大意： 给定两个数n,k 求n^k的前三位和最后三位。 ","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:2","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282(快速幂+对数运算)","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"分析 求后三位的话：直接快速幂，对1000取模就好了。 求前三位，对于给定的一个数n,它可以写成n=10^a,其中这个a为浮点数,则t=n^k=(10^a)^k=10^a*k=(10^x)*(10^y);其中x,y分别是a*k的整数部分和小数部分，对于t=n^k这个数，它的位数由(10^x)决定，它的位数上的值则有(10^y)决定，因此我们要求t的前三位，只需要将10^y求出，在乘以100，就得到了它的前三位。 分析完，我们再整体看，设n^k=10^z;那么z=k*log10(n) fmod(z,1)可以求出x的小数部分。 //再一次吐槽lightoj的头文件，让我不能用万能头\u003cbits/stdc++.h\u003e #include\u003cstdio.h\u003e#include\u003cmath.h\u003e typedef long long LL; int quickpow (int m, int n, int k) { int b = 1; while (n \u003e 0) { if (n \u0026 1) b = (b * m) % k; n \u003e\u003e= 1; m = (m * m) % k; } return b%k; } int main () { int t, flag = 1; scanf (\"%d\", \u0026t); while (t--) { LL n, k; scanf (\"%lld %lld\", \u0026n, \u0026k); int first = pow (10.0, 2.0 + fmod (k*log10(n*1.0), 1)); int last = quickpow (n%1000, k, 1000); printf (\"Case %d: %d %03d\\n\", flag++, first, last); } return 0; } ","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:3","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282(快速幂+对数运算)","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"注： C库函数 - fmod() C 库函数 double fmod(double x, double y) 返回 x 除以 y 的余数。 x – 代表分子的浮点值。 y – 代表分母的浮点值。 该函数返回 x/y 的余数。 下面的实例演示了 fmod() 函数的用法。 #include \u003cstdio.h\u003e#include \u003cmath.h\u003e int main () { float a, b; int c; a = 9.2; b = 3.7; c = 2; printf(\"%f / %d 的余数是 %lf\\n\", a, c, fmod(a,c)); printf(\"%f / %f 的余数是 %lf\\n\", a, b, fmod(a,b)); return(0); } 结果： 9.200000 / 2 的余数是 1.200000 9.200000 / 3.700000 的余数是 1.800000","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:4","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282(快速幂+对数运算)","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"A. The Rank 题目大意： 给出n个学生的成绩，Thomas Smith的成绩是第一行，然后要按总成绩进行排序，总分相同的按编号从小到大排； 开始看还以为要写sort的cmp函数进行多条件排序，敲完才发现其实只要按总分就可以了，因为托马斯的id是一，必然会排在前面。 #include\u003cbits/stdc++.h\u003eusing namespace std; int a[4],sum[1005]; int main(){ int n,s,f1; cin\u003e\u003en; for(int j=1;j\u003c=n;j++){ s=0; for(int i=0;i\u003c4;i++){ cin\u003e\u003ea[i]; s+=a[i]; } sum[j]=s; if(j==1) f1=s; } sort(sum+1,sum+n+1,greater\u003cint\u003e()); for(int i=1;i\u003c=n;i++) if(sum[i]==f1){ cout\u003c\u003ci\u003c\u003cendl; break; } return 0; } ","date":"2018-08-09","objectID":"/posts/cfcontest1017/:0:1","tags":["ACM","Codeforces","组合数学","C++"],"title":"Codeforces Round 502(Div.1 + Div.2)","uri":"/posts/cfcontest1017/"},{"categories":["ACM"],"content":"B. The Bits 题目大意： 先给出二进制数的长度，然后输入两个二进制数a,b，问交换a中的某些位数的数，使得a|b(按位或)的结果不同，求有多少种不同的或值。 a,b上下对应的情况：a/b 个数 1/0 m 0/0 n 1/1 x 0/1 y 用组合数学的思想来想： 只要看b为0的位就行了，如果0/0,a只能换1的位置，为了避免重复，所以这里总数为n*x, 再考虑1/0的情况，只能和0的位置换，这是后可以把0/0没算的都算上，所以总数m*(n+y) 所以最后总数为sum=n*x+m*(n+y) #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ long long n,m,x,y,t; n=m=x=y=0; char a[100005],b[100005]; cin\u003e\u003et; cin\u003e\u003ea\u003e\u003eb; for(int i=0;i\u003ct;i++){ int p=a[i]-'0'; int q=b[i]-'0'; if(p==0\u0026\u0026q==0) n++; if(p==1\u0026\u0026q==0) m++; if(p==1\u0026\u0026q==1) x++; if(p==0\u0026\u0026q==1) y++; } long long sum=n*x+m*(y+n); cout\u003c\u003csum\u003c\u003cendl; return 0; } ","date":"2018-08-09","objectID":"/posts/cfcontest1017/:0:2","tags":["ACM","Codeforces","组合数学","C++"],"title":"Codeforces Round 502(Div.1 + Div.2)","uri":"/posts/cfcontest1017/"},{"categories":["ACM"],"content":"欧拉函数是求小于x并且和x互质的数的个数 通式：φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn) 其中p1, p2……pn为x的所有质因数，x是不为0的整数 φ(1)=1（唯一和1互质的数就是1本身）【注意：每种质因数只一个。比如12=223】 ","date":"2018-08-08","objectID":"/posts/euler/:0:1","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"定理： 若n是素数p的k次幂，φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)，因为除了p的倍数外，其他数都跟n互质 欧拉函数是积性函数——若m,n互质，φ(mn)=φ(m)φ(n) ","date":"2018-08-08","objectID":"/posts/euler/:0:2","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"特殊性质： 当n为奇数时，φ(2n)=φ(n) p是素数，φ(p) = p - 1，φ(p)称为p的欧拉值 若a为素数,b mod a=0,φ(a*b)=φ(b)*a ","date":"2018-08-08","objectID":"/posts/euler/:0:3","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"模板 //直接法 int Euler(int n){ int res = n,i; //由于任何一个合数都至少有一个不大于根号n的素因子，所以只要遍历到根号n即可 for(i=2;i * i \u003c= n;i++) if(n%i == 0){ //第一次找到的必为素因子 n /=i ; res = res - res/i; //x(1-1/p1) while(n % i ==0) n/=i; //将该素因子的倍数也全部筛掉 } if (n \u003e 1) res = res - res/n; return res; } 以上转载注明 //素数筛选法，先素数筛选，再求欧拉 /* 特性 : 1.若a为质数,phi[a]=a-1; 2.若a为质数,b mod a=0,phi[a*b]=phi[b]*a 3.若a,b互质,phi[a*b]=phi[a]*phi[b](当a为质数时,if b mod a!=0 ,phi[a*b]=phi[a]*phi[b]) */ int m[n],phi[n],p[n],nump; //m[i]标记i是否为素数,0为素数,1不为素数;p是存放素数的数组;nump是当前素数个数;phi[i]为欧拉函数 int make() { phi[1]=1; for (int i=2;i\u003c=n;i++) { if (!m[i])//i为素数，m[]初始化为0 { p[++nump]=i;//将i加入素数数组p中 phi[i]=i-1;//因为i是素数,由特性得知 } for (int j=1;j\u003c=nump\u0026\u0026p[j]*i\u003cn;j++) //用当前已的到的素数数组p筛,筛去p[j]*i { m[p[j]*i]=1;//可以确定i*p[j]不是素数 if (i%p[j]==0) //看p[j]是否是i的约数,因为素数p[j],等于判断i和p[j]是否互质 { phi[p[j]*i]=phi[i]*p[j]; //特性2 break; } else phi[p[j]*i]=phi[i]*(p[j]-1); //互质,特性3,p[j]-1就是phi[p[j]] } } } 附素数打表 int p[N]={1,1,0}; void prime(){ for(int i=2;i\u003cN;i++) if(!p[i]){ for(int j=2*i;j\u003c=N;j+=i)//筛掉i的倍数 p[j]=1; } } ","date":"2018-08-08","objectID":"/posts/euler/:0:4","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"例题 Bi-shoe and Phi-shoe LightOJ - 1370 题意： 给一些数Ai（第 i 个数），Ai这些数代表的是某个数欧拉函数的值，我们要求出数 Ni 的欧拉函数值不小于Ai。而我们要求的就是这些 Ni 这些数字的和sum，而且我们想要sum最小，求出sum最小多少。 解题思路： 要求和最小，我们可以让每个数都尽量小，那么我们最后得到的肯定就是一个最小值。 给定一个数的欧拉函数值ψ(N)，我们怎么样才能求得最小的N? 我们知道，一个素数P的欧拉函数值ψ(P)=P-1。所以如果我们知道ψ(N)，那么最小的N就是最接近ψ(N)，并且大于ψ(N) 的素数。我们把所有素数打表之后再判断就可以了。 这个lightoj有毒，什么头文件都不支持，卡了我好久。。。 #include\u003cstdio.h\u003e#define N 1000005 #define ll long long int m[N]={1,1,0}; int p[100000],cnt=0; int max(int x,int y){ return x\u003ey?x:y; } void prime(){ for(int i=2;i\u003cN;i++) if(!m[i]){ for(int j=2*i;j\u003c=N;j+=i) m[j]=1; p[cnt++]=i; } } int binary_search(int x){//二分查找 int l=0,r=cnt; while(l\u003c=r){ int mid=(l+r)/2; if(p[mid]\u003ex) r=mid-1; else l=mid+1; } for(int i=max(r,0);;i++) if(p[i]\u003ex) return p[i]; } int main(){ prime(); int T,n,cas=1,temp; scanf(\"%d\",\u0026T); while(T--){ scanf(\"%d\",\u0026n); ll sum=0; for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026temp); sum+=binary_search(temp); } printf(\"Case %d: %lld Xukha\\n\",cas++,sum); } return 0; } ","date":"2018-08-08","objectID":"/posts/euler/:0:5","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"题目链接](http://poj.org/problem?id=1797) 大意： 要从城市1到城市N运送货物，有M条道路，每条道路都有它的最大载重量，问从城市1到城市N运送最多的重量是多少。 其实题意很简单，就是找一条1–\u003eN的路径，在不超过每条路径的最大载重量的情况下，使得运送的货物最多。一条路径上的最大载重量为这个路径上权值最小的边; //dijkstra #include\u003ciostream\u003e#include\u003ccstdio\u003e#define min(a,b) (a\u003cb?a:b) using namespace std; int n,m,v[1010],maps[1010][1010],d[1010];//此时d表示1到每一个点的能通过的最大的重量 int dijkstra(){ int i,j,k; for(i=1;i\u003c=n;i++){ v[i]=0; d[i]=maps[1][i];//这个时候d不代表最短路径，而是从1到n的最大承载量 } for(i=1;i\u003c=n;i++){//n个点 int f=-1; for(j=1;j\u003c=n;j++) if(!v[j]\u0026\u0026d[j]\u003ef){ f=d[j]; k=j; } v[k]=1; for(j=1;j\u003c=n;j++) if(!v[j]\u0026\u0026d[j]\u003cmin(d[k],maps[k][j]))//更新说明见图解 d[j]=min(d[k],maps[k][j]); } return d[n]; } int main(){ int ans=1; int a,b,w; int T; scanf(\"%d\",\u0026T); while(T--){ for(int i=0;i\u003c=n;i++) for(int j=0;j\u003c=n;j++) maps[i][j]=0; scanf(\"%d%d\",\u0026n,\u0026m); for(int i=1;i\u003c=m;i++){ scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026w); maps[a][b]=maps[b][a]=w; } printf(\"Scenario #%d:\\n%d\\n\\n\",ans++,dijkstra()); } return 0; } ","date":"2018-08-06","objectID":"/posts/poj1797/:0:0","tags":["ACM","POJ","最短路","C++"],"title":"Heavy Transportation-poj1797(dijkstra或最大生成树)","uri":"/posts/poj1797/"},{"categories":["JavaScript"],"content":"看到知乎，百度的页面F12检查后都会有一些有趣的招聘信息。于是乎我也想给我的博客加一个。 我主要用到的工具： console.log() Notepad++ 在线图片转文字工具 ","date":"2018-08-04","objectID":"/posts/console-log/:0:0","tags":["hexo","Frontend","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["JavaScript"],"content":"用法 用js在\u003cbody\u003e\u003c/body\u003e使用console.log()就行了，hexo的主题文件在_layout.swig里，所以我们打开该文件，在该位置，添加js就行了； ","date":"2018-08-04","objectID":"/posts/console-log/:1:0","tags":["hexo","Frontend","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["JavaScript"],"content":"图案 我用的我自己的一张照片(电脑上照片就那么几张。。。)，然后用 在线图片转文字工具 转字符， 选择文件，设置大小，然后生成，生成后，复制TXT文件（下面那个框，上面的是HTML代码） 粘贴到 Notepad++ 里面，然后按图操作； Ctrl+H 替换 最后就变成一个字符串了。 ","date":"2018-08-04","objectID":"/posts/console-log/:2:0","tags":["hexo","Frontend","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["JavaScript"],"content":"效果图 线上demo,按 F12 找到 console ","date":"2018-08-04","objectID":"/posts/console-log/:3:0","tags":["hexo","Frontend","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["JavaScript"],"content":"我的txt \\n` @@#``@@@@@@@@@@@@@@@@@@##,` \\n` @@#`;@@@@@@@@@@@@@@@@@@@':' \\n` @@#`@@@@@@@@@@@@@@@@@@@#+#;` \\n` @@#`@@@@@@@@@@@@@@@@@@###@'. \\n` @@+.@@@@@@@@@@@@@@@@@@@@@##, \\n` @@#,@@@@@@@@@@@@@@@@@@@@@@#, \\n` #@#:@@@@@@@@@@@@@@@@@@@@@@@, \\n` #@#'@@@@@@@@@@@@@@@@@@@@@@@. \\n` +@#;@@@@@@@@@@@@@@@@@@@@@@# \\n` `;: ;@#'@@@@@@@@@@@@@@@@@@+'+@' \\n` `,,;';'+';'@@+:@@@@@@@@@@@@##@#',.:#; \\n,, `` ``..,:;@@#'@@@@@@@@#####@@@@#:`:. \\n` `````:++@@@@@@@@@@@@@###@@@@#+,.. \\n ``````.#@@@@@@@@@@@@@@#@@@#++#'`` \\n` ```.,,:,.`:@@@@@@@@@@@@@###@@@##'.` \\n``..`````..,::;+@@@@@@@@@@@@#+`::+##'`. \\n` ````.```,@@@@@@@@@@@##;``.,';` ` \\n``.;@@@@@@@@@@@@@@@@@@@@@@###;``..`````` \\n#@@@@@@@@@@@@@@@@@@@@@@@@##@#;``,``,.`` \\n@@@@@@@@@@@@@@@@@@@.`````..``.. +` `:` \\n@+''++#####@@#`.@@@``````` ` `,``` `` \\n';;;;'+##+'+.`;+@@@,..```` `` :,. \\n;::,,:;+#++``,,#@@@'..``````` ,`.`` \\n;,,,,...'#.,,..#@@@#,,.`````` .```` \\n:,,,,....`,::;''+#@#;,..`````````.`` \\n:,,,.....'##++''';:+':,.`..,,...` \\n:,,,...#####+'+#@@@'.';+:. ` `` \\n;,,.`'####'#,`.`+@@@+'``` `.` \\n;,.`#@@@#+:'+++##+@##@,,,,` \\n',.#@@###'''';:,.```,+#. \\n+,#@@@####;,,..``````````````` `.:,::\\n+@@@@###+;,,..`````````````````` `.,\\n#@@@##+',,,........`````````````` \\n@@@@#+:,,,,`........`````````` \\n@@@#+:,,,,.`````.....`````````` `` \\n@@##':,......`````....``` ````` ```\\n@@@#':,....,..``````..```` ``` ```\\n@@@#',....,,,..``````````` ``` ..\\n@@@#,.....,,,,.`` ```````` `````` \\n@@@+....,,,,,..````````````` `````````` \\n@@@:....,,,,.LiRuihao```````` ```````````` \\n#@@,....,,,,.Always Be Yourself !````````````\\n,##,,...,::,.````````````..`````` `......``\\n,'#,,..,,:::.`````````........`````` `.,,..\\n\\n你好！\\n欢迎进入什么都不会的李瑞豪的个人网站！\\nhttps://lruihao.cn\\nhttps://www.lruihao.cn\\nhttps://lruihao.github.io\\nhttps://liruihao.coding.me\\n\\n\\n\\n 其他个人网站，个人博客也是可以的。 ","date":"2018-08-04","objectID":"/posts/console-log/:4:0","tags":["hexo","Frontend","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["ACM"],"content":"题目链接 题目大意： 说的是，一只奶牛位于N号节点，输入N个节点和T对双向的边，求出由N到1的最短的距离，其实就是问的单源最短路问题。 两个点可能有多条路，选择最短的。 #include\u003cstdio.h\u003e#include\u003cstring.h\u003e#include\u003calgorithm\u003eusing namespace std; const int INF=99999999; //设为无穷大 int maps[1005][1005],v[1005],d[1005]; //v表示是否已经过遍历 d表示从源到点当前最短路 int n; void Dijkstra(int s,int t) { int i,j,k,mini; for(i=1;i\u003c=n;i++) d[i]=INF; //除源点设为0距离外 其他先设为无穷大 d[s]=0; for(i=1;i\u003c=n;i++) //n点循环n次 ,找出n个k,找n个点 { mini=INF; k=-1; for(j=1;j\u003c=n;j++) //在所有未标记点中 选d值最小的点 if(!v[j] \u0026\u0026 d[j]\u003cmini) mini=d[k=j]; v[k]=1; //标记节点 if(k==t) { printf(\"%d\\n\",d[t]); return; } for(j=1;j\u003c=n;j++) if(!v[j] \u0026\u0026 (d[k]+maps[k][j])\u003cd[j]) //表示从k出发的点，对于所有边，更新相连点 d[j]=d[k]+maps[k][j]; } } int main() { int T,i,j,x,y,D; while(scanf(\"%d %d\",\u0026T,\u0026n)!=EOF) { memset(v,0,sizeof(v)); //清除标记 for(i=1;i\u003c=n;i++) for(j=1;j\u003c=n;j++) maps[i][j]=INF; for(i=1;i\u003c=T;i++){ scanf(\"%d%d%d\",\u0026x,\u0026y,\u0026D); if(maps[x][y]\u003eD) //可能有多条路，只记录最短的 maps[x][y]=D,maps[y][x]=D; } Dijkstra(1,n); } return 0; } ","date":"2018-08-03","objectID":"/posts/poj2387/:0:0","tags":["ACM","最短路","C++","C"],"title":"Til the Cows Come Home-poj2387(dijkstra判断重边)","uri":"/posts/poj2387/"},{"categories":["ACM"],"content":"Dijkstra算法 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:0:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"1.定义概览 Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。 问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径） ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:1:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"2.算法描述 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:2:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"1)算法思想： 设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:2:1","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"2)算法步骤： a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则\u003cu,v\u003e正常有权值，若u不是v的出边邻接点，则\u003cu,v\u003e权值为∞。 b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。 c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。 d.重复步骤b和c直到所有顶点都包含在S中。 执行动画过程如下图 spfa算法 spfa是一种求单源最短路的算法 算法中需要用到的主要变量 int n; //表示n个点，从1到n标号 int s,t; //s为源点，t为终点 int d[N]; //d[i]表示源点s到点i的最短路 int p[N]; //记录路径（或者说记录前驱） queue q; //一个队列，用STL实现，当然可有手打队列，无所谓 bool vis[N]; //vis[i]=1表示点i在队列中 vis[i]=0表示不在队列中 几乎所有的最短路算法其步骤都可以分为两步 1.初始化 2.松弛操作 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:2:2","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"初始化： d数组全部赋值为INF（无穷大）；p数组全部赋值为s（即源点），或者赋值为-1，表示还没有知道前驱,然后d[s]=0; 表示源点不用求最短路径，或者说最短路就是0。将源点入队； （另外记住在整个算法中有顶点入队了要记得标记vis数组，有顶点出队了记得消除那个标记） ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:3:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"队列+松弛操作 读取队头顶点u，并将队头顶点u出队（记得消除标记）；将与点u相连的所有点v进行松弛操作，如果能更新估计值（即令d[v]变小），那么就更新，另外，如果点v没有在队列中，那么要将点v入队（记得标记），如果已经在队列中了，那么就不用入队 以此循环，直到队空为止就完成了单源最短路的求解 SPFA可以处理负权边 定理: 只要最短路径存在，上述SPFA算法必定能求出最小值。 证明： 每次将点放入队尾，都是经过松弛操作达到的。换言之，每次的优化将会有某个点v的最短路径估计值d[v]变小。所以算法的执行会使d越来越小。由于我们假定图中不存在负权回路，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。（证毕） 期望的时间复杂度O(ke)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2。 判断有无负环： 如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图） 代码 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:4:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"题目链接 密码：l9sn 终于不爆零了，但是还是wa了无数次，有时候代码感觉都差不多 ","date":"2018-08-02","objectID":"/posts/nowcodersummer-5th/:0:0","tags":["Nowcoder","ACM","C++"],"title":"牛客暑假多校第五场","uri":"/posts/nowcodersummer-5th/"},{"categories":["ACM"],"content":"G-max /* //wa #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,c;//好像不会爆int吧，头晕 cin\u003e\u003ec\u003e\u003en; int t=n/c; if(t\u003c1) cout\u003c\u003c\"-1\\n\";// else if(t==1) cout\u003c\u003cc*c\u003c\u003cendl; else cout\u003c\u003c(t*c)*((t-1)*c)\u003c\u003cendl; return 0; }*/ //AC #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ long long n,c; cin\u003e\u003ec\u003e\u003en; long long t=n/c; if(t\u003c1) cout\u003c\u003c-1\u003c\u003cendl; else if(t==1) cout\u003c\u003cc*c\u003c\u003cendl; else cout\u003c\u003c(t*c)*((t-1)*c)\u003c\u003cendl; return 0; } ","date":"2018-08-02","objectID":"/posts/nowcodersummer-5th/:1:0","tags":["Nowcoder","ACM","C++"],"title":"牛客暑假多校第五场","uri":"/posts/nowcodersummer-5th/"},{"categories":["ACM"],"content":"J-plan /*枚举所有情况 全买双人n%2 0 or 1//剩1个人的时候，可以多开一间房或者退一间2人房开一间3人房 全买3人n%3 0 or 1 or 2 再比较大小 */ #include\u003cbits/stdc++.h\u003e#define INF 1\u003c\u003c20 using namespace std; typedef long long ll; ll min(ll a,ll b){ return a\u003cb?a:b; } int main(){ ll n,p2,p3,sum,sum1; while(cin\u003e\u003en\u003e\u003ep2\u003e\u003ep3){ if(n%2==0) sum=p2*(n/2); else sum=p2*(n/2)+min(min(p2,p3),p3-p2);//退二买三； if(n%3==0) sum1=p3*(n/3); else if(n%3==1) sum1=p3*(n/3)+min(min(p2,p3),2*p2-p3);//退3买2*2 else if(n%3==2) sum1=p3*(n/3)+min(p3,p2);//退3买3*2 cout\u003c\u003cmin(sum1,sum)\u003c\u003cendl; } return 0; } ","date":"2018-08-02","objectID":"/posts/nowcodersummer-5th/:2:0","tags":["Nowcoder","ACM","C++"],"title":"牛客暑假多校第五场","uri":"/posts/nowcodersummer-5th/"},{"categories":["ACM"],"content":"题目链接 思路参考1,思路参考2（没看懂） 先占坑，有时间再理理思路。 同一棵树中 d=1,即x和y是同类，则需满足r[x]==r[y] d=2,x应该吃了y,也就是(r[x]+1)%3 == r[y] 不同树合并且更新关系(x树做主根) ' 如果 x和y为关系r1, y和z为关系r2， 那么x和z的关系就是（r1+r2）%3 如果 d==1则x和y是同类 ，那么 y对x的关系是0,如果d==2 ,则x吃了y, 那么y对x的关系是1, x对y的关系是2。综上所述 ,无论d为1或者是为2, y对x的关系都是 d-1。 fy对y 的关系为 3-r[y] （有点互补的感觉，注意这里是不同类喔） y对x的关系为 d-1, x 对fx 的关系为 r[x] 所以fy对fx 的关系是（3-r[y] + d-1 + r[x]）%3。可以借助向量图理解 fy-\u003ey-\u003ex-\u003efx #include\u003ccstdio\u003e const int maxn = 50000+10; int p[maxn]; //存父节点 int r[maxn];//存与父节点的关系 0 同一类，1被父节点吃，2吃父节点 void set(int n) //初始化 { for(int x = 1; x \u003c= n; x++) { p[x] = x; //开始自己是自己的父亲节点 r[x] = 0;//开始自己就是自己的父亲，每一个点均独立 } } int find(int x) //找父亲节点 { if(x == p[x]) return x; int t = p[x]; p[x] = find(p[x]); r[x] = (r[x]+r[t])%3; //回溯由子节点与父节点的关系和父节点与根节点的关系找子节点与根节点的关系 return p[x]; } void Union(int x, int y, int d) { int fx = find(x); int fy = find(y); p[fy] = fx; //合并树 注意：被 x 吃，所以以 x 的根为父 r[fy] = (r[x]-r[y]+3+(d-1))%3; //对应更新与父节点的关系 } int main() { int n, m; scanf(\"%d%d\", \u0026n, \u0026m); set(n); int ans = 0; int d, x, y; while(m--) { scanf(\"%d%d%d\", \u0026d, \u0026x, \u0026y); if(x \u003e n || y \u003e n || (d == 2 \u0026\u0026 x == y)) ans++; //如果节点编号大于最大编号，或者自己吃自己，说谎 else if(find(x) == find(y)) //如果原来有关系，也就是在同一棵树中，那么直接判断是否说谎 { if(d == 1 \u0026\u0026 r[x] != r[y]) ans++; //如果 x 和 y 不属于同一类 if(d == 2 \u0026\u0026 (r[x]+1)%3 != r[y]) ans++; // 如果 x 没有吃 y (注意要对应Uinon(x, y)的情况，否则一路WA到死啊！！！) } else Union(x, y, d); //如果开始没有关系，则建立关系 } printf(\"%d\\n\", ans); return 0; } ","date":"2018-08-02","objectID":"/posts/poj1182/:0:0","tags":["ACM","并查集","POJ","C++","C"],"title":"食物链-poj1182（带权并查集经典模板）","uri":"/posts/poj1182/"},{"categories":["ACM"],"content":"题目链接：小希的迷宫 ","date":"2018-08-01","objectID":"/posts/hdu1272/:1:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272(并查集or树性质)","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"并查集： 无回路 单连通 并查集做，首先想到的是判断两个点是否连通，不连通就合并，已连通的话说明会形成回路，则可以判定No，交了一发错了。 想了一下没有考虑到多个连通域的情况，该题必须只有一个连通域 ","date":"2018-08-01","objectID":"/posts/hdu1272/:2:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272(并查集or树性质)","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"树的性质： 既然单连通无回路，则这肯定是一棵树；那么edge=v-1; 最后注意空树的情况，至于自环我这里No也过了，没有去验证自环Yes的情况了 //并查集 #include\u003cbits/stdc++.h\u003eusing namespace std; int pre[100001]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int a,int b){ int x=find(a),y=find(b); if(x!=y) pre[y]=x; } int main(){ int a,b,flag,i,sum; while(1) { flag = 0; while(~scanf(\"%d%d\",\u0026a,\u0026b) \u0026\u0026 a!=0 \u0026\u0026 b!=0){ if(a==-1 \u0026\u0026 b==-1) return 0; if(pre[a]==0)pre[a]=a; if(pre[b]==0)pre[b]=b; if(find(a)==find(b))flag = 1; else if(flag!=1) join(a,b); } for(sum = 0,i=1;i\u003c100001;i++){ if(pre[i]==i)sum++; pre[i] = 0; } if(sum\u003e1 || flag == 1) printf(\"No\\n\"); else printf(\"Yes\\n\"); } } //1 2 3 4 0 0 No 没有连通 //0 0 Yes //1 1 0 0 No(该代码) //树性质 #include \u003cstdio.h\u003ebool s[100001]; int main() { int a,b,i,len,num,v; for(i=0;i\u003c100001;++i) s[i]=false; len=0,num=0,v=0; while(1) { scanf(\"%d%d\",\u0026a,\u0026b); if(a==-1\u0026\u0026b==-1) break; if(a==0\u0026\u0026b==0) { if(v==0) { printf(\"Yes\\n\"); continue; } if(num==len-1) //划重点！！ printf(\"Yes\\n\"); else printf(\"No\\n\"); num=len=v=0; for(i=0;i\u003c100001;++i) s[i]=false; continue; } v=1; if(s[a]==false) len++;//点数 if(s[b]==false) len++; s[a]=s[b]=true; num++;//边数 } return 0; ","date":"2018-08-01","objectID":"/posts/hdu1272/:3:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272(并查集or树性质)","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"题目链接：How Many Answers Are Wrong 思路参考：本题直接参考,图文解释 #include\u003cbits/stdc++.h\u003eusing namespace std; typedef long long LL; int pre[200010],ranks[200010]; int find(int root){ if(pre[root] != root) { int f = pre[root]; pre[root] = find(pre[root]);//递归路径压缩 ranks[root] += ranks[f]; /*精髓假如一开始没关系，那么用rank数组来表示a，b各自到各自祖先的距离。 那么在把a的祖先给b的祖先当父亲之后，那么b到祖先的距离也就是rank[b]就要再加上b原本的祖先到a的祖先的距离，更新一下， 其中find函数（找根节点的函数）里rank[x]+=rank[pre[x]]（这里pre数组存的是对应数的父节点）*/ } return pre[root]; } int main(){ int n,m; while(~scanf(\"%d%d\",\u0026n,\u0026m)){ int ans=0; for(int i=1; i\u003c=n; i++) pre[i]=i; memset(ranks,0,sizeof(ranks)); while(m--){ int a,b,c; scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026c); a--;//[a,b]~~(a--,b] int fa=find(a); int fb=find(b); if(fa!=fb){ pre[fb]=fa;//注意合并顺序，反过来下面的也要改 ranks[fb]=ranks[a]-ranks[b]+c;//更新距离 } else { if(ranks[b]-ranks[a]!=c) ans++; } } printf(\"%d\\n\",ans); } return 0; } ","date":"2018-08-01","objectID":"/posts/hdu3038/:0:0","tags":["并查集","ACM","HDU","C++"],"title":"How Many Answers Are Wrong-hdu3038(带权并查集)","uri":"/posts/hdu3038/"},{"categories":["ACM"],"content":"题目链接：Bear and Finding Criminals 大致题意就是小熊警察住在某个城市，他要抓各个城市的罪犯，现在用一个BCD可以知道那个城市里一定有罪犯。 一定能确定该城市有小偷的几种情况： 1.警察所住城市有罪犯，则一定能检测到 2.警察所住城市的左边和右边位置若都不为0，则说明两座城市都有罪犯（只有一边为1是不能确定到底哪个城市有罪犯的） 3.警察所在城市的一边检测到有罪犯，但在另一边已经没有城市了，则说明该城市一定有罪犯 #include\u003cbits/stdc++.h\u003eusing namespace std; int t[107]; int main() { int n, a; while(cin\u003e\u003en\u003e\u003ea){ int sum = 0; for(int i =1; i \u003c= n; i++) cin \u003e\u003e t[i]; if(t[a]) sum++;//小熊所在城市有罪犯 for(int i = 1; i \u003c= n; i++){ if(a-i \u003e 0\u0026\u0026a+i \u003c= n) { if(t[a-i] == 1\u0026\u0026t[a+i] == 1) sum+=2; } else if(a-i \u003c= 0\u0026\u0026a+i \u003c= n){//警察在第一个点 if(t[a+i]) sum++; } else if(a-i \u003e 0\u0026\u0026a+i \u003e n){ if(t[a-i]) sum++; } } cout \u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-31","objectID":"/posts/codeforces680b/:0:0","tags":["Codeforces","ACM","C++"],"title":"Bear and Finding Criminals-Codeforces680B","uri":"/posts/codeforces680b/"},{"categories":["ACM"],"content":"题目链接：Bear and Five Cards 大致题意就是小熊有5张卡片，每张卡片有对应的分数，他可以选择丢弃2张相同的或者3张相同的卡片，没有相同的就无法丢弃，问小熊剩下的分数最少是多少。 没有想得那么复杂，由于分数最大才100，所以直接暴力就好了。。。 #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ int a[5],b[107],i,j,sum=0,sum1=0; for(i=0;i\u003c5;i++){ cin\u003e\u003ea[i]; sum+=a[i]; } sort(a,a+5); memset(b,0,sizeof(b)); for(i=0;i\u003c5;i++) b[a[i]]++; for(i=0;i\u003c107;i++){ if(b[i]==2) sum1=max(2*i,sum1); if(b[i]\u003e=3) {sum1=max(3*i,sum1);/*cout\u003c\u003c3*i\u003c\u003c\" \"\u003c\u003csum1\u003c\u003cendl;*/} } cout\u003c\u003csum-sum1\u003c\u003cendl; return 0; } ","date":"2018-07-31","objectID":"/posts/codeforces680a/:0:0","tags":["Codeforces","ACM","C++"],"title":"Bear and Five Cards-Codeforces680A","uri":"/posts/codeforces680a/"},{"categories":["ACM"],"content":"并查集求连通域数目，初始化sum=n； 题目链接： how many tables #include\u003cbits/stdc++.h\u003eusing namespace std; int pre[1005]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } int main(){ int n,m,t,sum,root1,root2; cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003em; sum=n; for(int i=1;i\u003c=n;i++) pre[i]=i; for(int i=0;i\u003cm;i++){ cin\u003e\u003eroot1\u003e\u003eroot2; int xx=find(root1); int yy=find(root2); if(xx!=yy){ pre[xx]=yy; sum--; } } cout\u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-31","objectID":"/posts/how-tables/:0:0","tags":["并查集","HDU","C++","ACM"],"title":"how many tables-HDU-1213(并查集求连通域数目)","uri":"/posts/how-tables/"},{"categories":["ACM"],"content":"题目链接：The-suspects ","date":"2018-07-31","objectID":"/posts/the-suspects/:1:0","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611(并查集)","uri":"/posts/the-suspects/"},{"categories":["ACM"],"content":"翻译： 警察抓贩毒集团。有不同类型的犯罪集团，人员可能重复，集团内的人会相互接触。现在警察在其中一人（0号）身上搜出毒品，认为与这个人直接接触或通过其他人有间接接触的人都是嫌疑犯。问包括0号犯人共有多少嫌疑犯？ ","date":"2018-07-31","objectID":"/posts/the-suspects/:2:0","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611(并查集)","uri":"/posts/the-suspects/"},{"categories":["ACM"],"content":"Input 多样例输入。 每个测试用例以两个整数n和m开头，其中n为人数，m为犯罪集团数。你可以假定0 \u003c n \u003c= 30000和0 \u003c= m \u003c= 500。在所有的情况下，每个人都有自己独特的整数编号0到n−1, 且0号是公认的嫌疑犯。 接下来m行输入，每个犯罪集团一行。每一行从一个整数k开始，它本身表示集团内成员的数量。按照成员的数量，在这个组中有k个整数表示人员。一行中的所有整数都被至少一个空格隔开。 n = 0且m = 0时输入结束。 ","date":"2018-07-31","objectID":"/posts/the-suspects/:2:1","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611(并查集)","uri":"/posts/the-suspects/"},{"categories":["ACM"],"content":"Output 对于每个样例，输出嫌疑犯人数。 ","date":"2018-07-31","objectID":"/posts/the-suspects/:2:2","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611(并查集)","uri":"/posts/the-suspects/"},{"categories":["ACM"],"content":"Sample Input 100 4 2 1 2 5 10 13 11 12 14 2 0 1 2 99 2 200 2 1 5 5 1 2 3 4 5 1 0 0 0 ","date":"2018-07-31","objectID":"/posts/the-suspects/:2:3","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611(并查集)","uri":"/posts/the-suspects/"},{"categories":["ACM"],"content":"Sample Output 4 1 1 这题也很好理解，AC代码如下： #include\u003ccstdio\u003e int pre[30010],x[30010]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy) pre[fy]=fx; } int main(){ int n,m,i,k,sum; while(scanf(\"%d%d\",\u0026n,\u0026m),n||m){ sum=0; for(i=0;i\u003cn;i++) pre[i]=i; while(m--){ scanf(\"%d\",\u0026k); for(i=0;i\u003ck;i++) scanf(\"%d\",\u0026x[i]); for(i=1;i\u003ck;i++) join(x[i-1],x[i]); } for(i=0;i\u003cn;i++) if(find(0)==find(i)) sum++;//再次查找并压缩路径，注不用pre[i] printf(\"%d\\n\",sum); } return 0; } ","date":"2018-07-31","objectID":"/posts/the-suspects/:2:4","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611(并查集)","uri":"/posts/the-suspects/"},{"categories":["ACM"],"content":"题目链接：wireless network ","date":"2018-07-31","objectID":"/posts/wireless-network/:1:0","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236(并查集)","uri":"/posts/wireless-network/"},{"categories":["ACM"],"content":"翻译： 南亚发生了一次地震。ACM (Asia Cooperated Medical 亚洲联合医疗队) 已经为膝上型电脑搭建了一个无线网络，但受到了一次不可预知的余震攻击，因此网络中的所有电脑都被破坏了。电脑被逐台修复，网络逐步恢复了工作。由于受到硬件的约束，每台电脑只能与距离它不超过 d 米的其它电脑直接通信。但每台电脑可被看作其它两台电脑的通信中转点，也就是说，如果电脑 A 和电脑 B 可以直接通信，或存在一台电脑 C 既可与 A 也可与 B 通信，那么电脑 A 和电脑 B 之间就能够通信。 在处理网络修复的过程中，工作人员们在任何一个时刻，可以执行两种操作：维修一台电脑，或测试两台电脑是否能够通信。请您找出全部的测试操作。 ","date":"2018-07-31","objectID":"/posts/wireless-network/:2:0","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236(并查集)","uri":"/posts/wireless-network/"},{"categories":["ACM"],"content":"输入 第一行包含了两个整数 N 和 d (1 \u003c= N \u003c= 1001, 0 \u003c= d \u003c= 20000)。此处 N 是电脑的数目，编号从 1 到 N；同时，D 是两台电脑之间能够直接通信的最大距离。接下来的 N 行，每行包含两个整数 xi, yi (0 \u003c= xi, yi \u003c= 10000)，表示 N 台电脑的坐标。从第 (N+1) 行到输入结束，是逐一执行的操作，每行包含一个操作，格式是以下两者之一： “O p” (1 \u003c= p \u003c= N)，表示维护电脑 p 。 “S p q” (1 \u003c= p, q \u003c= N)，表示测试电脑 p 和 q 是否能够通信。 输入不超过 300000 行。 ","date":"2018-07-31","objectID":"/posts/wireless-network/:2:1","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236(并查集)","uri":"/posts/wireless-network/"},{"categories":["ACM"],"content":"输出 对于每个测试操作，如果两台电脑能够通信，则打印 “SUCCESS”；否则，打印 “FAIL”。 ","date":"2018-07-31","objectID":"/posts/wireless-network/:2:2","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236(并查集)","uri":"/posts/wireless-network/"},{"categories":["ACM"],"content":"示例输入 4 1 0 1 0 2 0 3 0 4 O 1 O 2 O 4 S 1 4 O 3 S 1 4 ","date":"2018-07-31","objectID":"/posts/wireless-network/:2:3","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236(并查集)","uri":"/posts/wireless-network/"},{"categories":["ACM"],"content":"示例输出 FAIL SUCCESS ","date":"2018-07-31","objectID":"/posts/wireless-network/:2:4","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236(并查集)","uri":"/posts/wireless-network/"},{"categories":["ACM"],"content":"AC代码： #include \"iostream\"#include \"cstring\"using namespace std; int pre[1005]; int x[1005],y[1005],use[1005]; int findd(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int x,int y){ int fx=findd(x),fy=findd(y); if(fx!=fy) pre[fx]=fy; } int dis(int i,int num,int d){ d=d*d; int xx=x[i]-x[num]; int yy=y[i]-y[num]; if((xx*xx+yy*yy)\u003c=d) return 1; return 0; } int main(){ int n,d; char s; memset(use,0,sizeof(use)); cin\u003e\u003en\u003e\u003ed; for(int i=0;i\u003c=n;i++) pre[i]=i; for(int i=1;i\u003c=n;i++) cin\u003e\u003ex[i]\u003e\u003ey[i]; while(cin\u003e\u003es){ if(s=='O'){ int num; cin\u003e\u003enum; use[num]=1; findd(num);//路径压缩 for(int i=1;i\u003c=n;i++) if(i!=num\u0026\u0026use[i]==1\u0026\u0026dis(i,num,d))//修好了，且可以被合并（自己除外） join(i,num); } else if(s=='S'){ int q,p; cin\u003e\u003eq\u003e\u003ep; if(findd(q)==findd(p)) cout\u003c\u003c\"SUCCESS\"\u003c\u003cendl; else cout\u003c\u003c\"FAIL\"\u003c\u003cendl; } } return 0; } ","date":"2018-07-31","objectID":"/posts/wireless-network/:2:5","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236(并查集)","uri":"/posts/wireless-network/"},{"categories":["ACM"],"content":"Codeforces Round #500 (Div. 2) 题目链接：Piles With Stones 大致题意就是有n堆石头，第一天每堆有一定数目的石头，第二天石头可能被小朋友移动或者带走，求满足题意的两天的石碓； 所以第二天的石头总数不会大于第一天的，所以是sum1-sum2\u003e=0即可。 //又只打了一道题，扣了80多分。。。 #include\u003cbits/stdc++.h\u003eusing namespace std; int x[55],y[55],n,s1=0,s2=0; int main(){ scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026x[i]); s1+=x[i]; } for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026y[i]); s2+=y[i]; } if((s1-s2)\u003e=0) printf(\"Yes\\n\"); else printf(\"No\\n\"); return 0; } ","date":"2018-07-31","objectID":"/posts/piles-with-stones/:0:0","tags":["ACM","Codeforces","C++"],"title":"Piles-with-stones","uri":"/posts/piles-with-stones/"},{"categories":["ACM"],"content":"并查集入门推荐：超有爱的并查集~ 题目链接：畅通工程 题意分析： 首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。 #include\u003ciostream\u003e#include\u003ccstdio\u003eusing namespace std; int pre[1010]; int findd(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } int main(){ int n,m,i,sum,r1,r2,star,end1; while(scanf(\"%d\",\u0026n)\u0026\u0026n){ sum=n-1; for(i=1;i\u003c=n;i++) pre[i]=i; scanf(\"%d\",\u0026m); while(m--){ scanf(\"%d%d\",\u0026star,\u0026end1); r1=findd(star); r2=findd(end1); if(r1!=r2){ pre[r1]=r2; sum--; } } printf(\"%d\\n\",sum); } return 0; } 基础回顾： find()函数找根结点的两种写法如下： 第一种递归： int find(int x) { return x == pre[x] ? x : find(pre[x]); } 第二种： int find(int x) { int root, temp; root = x; while(root != pre[root]) root = pre[root]; while(x != root) { temp = pre[x]; pre[temp] = root; x = temp; } return root; } 合并函数 void join(int x,int y){ int fx=find(x); int fy=find(y); if(fx!=fy) pre[fx]=fy; } ","date":"2018-07-31","objectID":"/posts/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/:0:0","tags":["ACM","并查集","HDU","C++","C"],"title":"畅通工程-HDU-1232(并查集经典模板)","uri":"/posts/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/"},{"categories":["ACM"],"content":"两题水过，暴力，找规律。。 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:0:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"托米的赌球 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:1:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"托米的划分 ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:2:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"a #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ int c[13],d[13]={100,50,20,10,5,2,1,50,20,10,5,2,1}; int i,t; cin\u003e\u003et; int a,b; while(t--){ memset(c,0,sizeof(c)); cin\u003e\u003ea\u003e\u003eb; for(i=0;i\u003c7;i++){ int x=0; if(a\u003ec[i]){ x=a/d[i]; c[i]+=x; a-=x*d[i]; } } for(i=7;i\u003c13;i++){ int x=0; if(b\u003ec[i]){ x=b/d[i]; c[i]+=x; b-=x*d[i]; } } cout\u003c\u003cc[0]; for(i=1;i\u003c13;i++) cout\u003c\u003c\" \"\u003c\u003cc[i]; cout\u003c\u003cendl; } return 0; } ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:3:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["ACM"],"content":"b f(n)=f(n-1)+n-1; #include\u003cbits/stdc++.h\u003eusing namespace std; long long sum; int main(){ int n; int t; cin\u003e\u003et; while(t--){ sum=1; cin\u003e\u003en; if(n==1) sum=0; for(int i=3;i\u003c=n;i++) sum+=i-1; cout\u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:4:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["others"],"content":"在线算法 在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。 在计算机科学中，一个在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。相对的，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。例如，选择排序在排序前就需要知道所有待排序元素，然而插入排序就不必。 因为在线算法并不知道整个的输入，所以它被迫做出的选择最后可能会被证明不是最优的，对在线算法的研究主要集中在当前环境下怎么做出选择。对相同问题的在线算法和离线算法的对比分析形成了以上观点。如果想从其他角度了解在线算法可以看一下流算法（关注精确呈现过去的输入所使用的内存的量），动态算法（关注维护一个在线输入的结果所需要的时间复杂度）和在线机器学习。 一个很好的展示在线算法概念的例子是 加拿大旅行者问题，这个问题的目标是在一个有权图中以最小的代价到达一个目标节点，但这个有权图中有些边是不可靠的可能已经被剔除。然而一个旅行者只有到某个边的一个端点时才能确定该边是否已经被移除了。最坏情况下，该问题会变得简单了，即所有的不确定的边都被移除该问题将会变成通常的最短路径问题。 ","date":"2018-07-26","objectID":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/:1:0","tags":["在线离线算法"],"title":"在线离线算法","uri":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"},{"categories":["others"],"content":"离线算法 离线算法( off line algorithms)，是指基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。 设计策略 在执行算法前输入已知的基本假设 前提 具有问题完全信息 算法设计策略都是基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果，通常将这类具有问题完全信息前提下设计出的算法称为离线算法( off line algorithms) ","date":"2018-07-26","objectID":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/:2:0","tags":["在线离线算法"],"title":"在线离线算法","uri":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"},{"categories":["ACM"],"content":"非常可乐 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S\u003c101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出\"NO\"。 ","date":"2018-07-24","objectID":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/:0:0","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs模拟倒水or数论）","uri":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/"},{"categories":["ACM"],"content":"Input 三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以\"0 0 0\"结束。 ","date":"2018-07-24","objectID":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/:0:1","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs模拟倒水or数论）","uri":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/"},{"categories":["ACM"],"content":"Output 如果能平分的话请输出最少要倒的次数，否则输出\"NO\"。 ","date":"2018-07-24","objectID":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/:0:2","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs模拟倒水or数论）","uri":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/"},{"categories":["ACM"],"content":"Sample Input 7 4 3 4 1 3 0 0 0 ","date":"2018-07-24","objectID":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/:0:3","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs模拟倒水or数论）","uri":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/"},{"categories":["ACM"],"content":"Sample Output NO 3 模拟一下倒水的过程，一共有三种倒法，a向bc，b向ac，c向ab。(相当于一共六个方向)搜索并记录搜索过的过程就好了。 #include\u003cbits/stdc++.h\u003eusing namespace std; int a,b,c; int used[111][111][111]; struct node { int x,y,z; int step; }m,n; int bfs() { queue\u003cnode\u003eq; m.x = a; m.y = 0; m.z = 0; m.step = 0; used[a][0][0] = 1; q.push(m); while (!q.empty()) { int trans; //倒水量 m = q.front(); q.pop(); //成功分好的三种情况 if ((m.x == 0 \u0026\u0026 m.y == m.z) || (m.y == 0 \u0026\u0026 m.x == m.z) || (m.z == 0 \u0026\u0026 m.x == m.y)) return m.step; //下面开始6个搜索（由一个杯子向另外两个倒水） if (m.x) { //第一 trans = min(m.x , b - m.y);//自己模拟一下倒水过程就知道了 n.x = m.x - trans; n.y = m.y + trans; n.z = m.z; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } //第二 trans = min(m.x , c - m.z); n.x = m.x - trans; n.y = m.y; n.z = m.z + trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } } if (m.y) { //第三 trans = min(m.y , a - m.x); n.x = m.x + trans; n.y = m.y - trans; n.z = m.z; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } //第四 trans = min(m.y , c - m.z); n.x = m.x; n.y = m.y - trans; n.z = m.z + trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } } if (m.z) { //第五 trans = min(m.z , a - m.x); n.x = m.x + trans; n.y = m.y; n.z = m.z - trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } //第六 trans = min(m.z , b - m.y); n.x = m.x; n.y = m.y + trans; n.z = m.z - trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } } } return 0; } int main() { while (~scanf (\"%d %d %d\",\u0026a,\u0026b,\u0026c) \u0026\u0026 (a || b || c)) { if (a\u00261) //先简单的剪枝一下,奇数肯定不能平分 printf (\"NO\\n\"); else { memset (used,0,sizeof (used)); int ans = bfs(); if (ans) printf (\"%d\\n\",ans); else printf (\"NO\\n\"); } } return 0; } 然后杭电上讨论板子上提供一种数论题解，但是数据存在一点问题，只不过有些数据好像不对；比如： 10 6 5的结果应该是1而不是9， 也提示我们多维思考同一个问题！ 数论推导 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int s,n,m; while(cin\u003e\u003es\u003e\u003en\u003e\u003em,s+n+m){ s/=__gcd(n,m); if(s\u00261)//奇数 cout\u003c\u003c\"NO\\n\"; else cout\u003c\u003cs-1\u003c\u003cendl; } return 0; } ","date":"2018-07-24","objectID":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/:0:4","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs模拟倒水or数论）","uri":"/posts/hdu-1495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90-bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4-or-%E6%95%B0%E8%AE%BA/"},{"categories":["ACM"],"content":"Find a way 圣诞节要到了，坤神和瑞瑞这对基佬想一起去召唤师大峡谷开开车。百度地图一下，发现周围的召唤师大峡谷还不少，这对基佬纠结着，该去哪一个。。。坤神：我要去左边的这个（因为离自己比较近 哈哈~）。。瑞瑞：我要去右边的这个（因为离自己比较近 嘿嘿~） ……..这对基佬闹矛盾了，开车有危险了！ 为了不让他们去召唤师大峡谷坑人，riot决定让他们去X召唤师大峡谷，保证他俩所走的路程和最短。每走一个点需要花费11分钟，输出他们一共花费多少时间（最短时间噢） ","date":"2018-07-23","objectID":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/:0:1","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双bfs）","uri":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/"},{"categories":["ACM"],"content":"Input 多组测试数据 每组数据，开始一行n，m (2\u003c=n,m\u003c=200) 接下来是个n x m的矩阵 ‘Y’ 表示坤神所在的初始位置 ‘M’ 表示瑞瑞所在的初始位置 ‘#’ 该点禁止通行 ‘.’ 该点可通行 ‘@’ 召唤师大峡谷 ","date":"2018-07-23","objectID":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/:0:2","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双bfs）","uri":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/"},{"categories":["ACM"],"content":"Output 每组测试数据，输出坤神和瑞瑞到达同一个召唤师大峡谷所花费的最短时间。 ","date":"2018-07-23","objectID":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/:0:3","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双bfs）","uri":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/"},{"categories":["ACM"],"content":"Sample Input 4 4 Y.#@ .... .#.. @..M 4 4 Y.#@ .... .#.. @#.M 5 5 Y..@. .#... .#... @..M. `#...#` ","date":"2018-07-23","objectID":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/:0:4","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双bfs）","uri":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/"},{"categories":["ACM"],"content":"Sample Output 66 88 66 ","date":"2018-07-23","objectID":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/:0:5","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双bfs）","uri":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/"},{"categories":["ACM"],"content":"Hint 对于第一组样例，坤神和瑞瑞去矩阵（4,1） 这个召唤师大峡谷，耗费的时间为 3 * 11 + 3 * 11 = 66， 去矩阵（1,4）这个召唤师大峡谷，耗费的时间为 5 * 11 + 3 * 11 = 88 。所以，最终答案：66。思路参考 写代码总是好粗心！！ #include \u003cbits/stdc++.h\u003e#define inf 0x3f3f3f3f //acm中“无穷大”的一般定义 using namespace std; const int M=202; char mp[M][M]; //地图 int a[M][M],b[M][M]; bool vis[M][M]; //标记数组 int n,m; int ans; struct node { int x,y,step; }; void init() //初始化函数 { ans=inf; for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) { a[i][j]=inf; b[i][j]=inf; } } void bfs(int x,int y,bool flag){ int dir[4][2]={-1,0,1,0,0,1,0,-1}; node u,v; queue\u003cnode\u003e q; //初始化队列第一个元素 u.x=x; u.y=y; u.step=0; vis[x][y]=true; q.push(u); while(!q.empty()){ u=q.front(); q.pop(); if(mp[u.x][u.y]=='@'){ if(!flag) a[u.x][u.y]=u.step; else b[u.x][u.y]=u.step; } for(int i=0;i\u003c4;i++){ int tx=u.x+dir[i][0]; int ty=u.y+dir[i][1]; if(tx\u003e=0\u0026\u0026ty\u003e=0\u0026\u0026tx\u003cn\u0026\u0026ty\u003cm\u0026\u0026!vis[tx][ty]\u0026\u0026mp[tx][ty]!='#'){//注意@和M，Y也是可以走的。 v.x=tx; //每次写搜索都忘记vis!!!! v.y=ty; vis[tx][ty]=true; //我总是忘记。。。 v.step=u.step+1; q.push(v); } } } } int main() { while(~scanf(\"%d%d\",\u0026n,\u0026m)) { init(); for(int i=0; i\u003cn; i++) scanf(\"%s\",mp[i]); for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) { if(mp[i][j]=='Y') { memset(vis,false,sizeof(vis)); bfs(i,j,false); } if(mp[i][j]=='M') { memset(vis,false,sizeof(vis)); //记得再次初始化标记数组 bfs(i,j,true); } } for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) if(mp[i][j]=='@') ans=min(ans,a[i][j]+b[i][j]); printf(\"%d\\n\",ans*11); } return 0; } ","date":"2018-07-23","objectID":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/:0:6","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双bfs）","uri":"/posts/hdu-2612-find-a-way%E5%8F%8Cbfs/"},{"categories":["ACM"],"content":"Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X\",“1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute. If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? ","date":"2018-07-22","objectID":"/posts/poj-3278-catch-that-cow-bfs/:0:0","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278-catch-that-cow-bfs/"},{"categories":["ACM"],"content":"Input Line 1: Two space-separated integers: N and K ","date":"2018-07-22","objectID":"/posts/poj-3278-catch-that-cow-bfs/:0:1","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278-catch-that-cow-bfs/"},{"categories":["ACM"],"content":"Output Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. ","date":"2018-07-22","objectID":"/posts/poj-3278-catch-that-cow-bfs/:0:2","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278-catch-that-cow-bfs/"},{"categories":["ACM"],"content":"Sample Input 5 17 ","date":"2018-07-22","objectID":"/posts/poj-3278-catch-that-cow-bfs/:0:3","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278-catch-that-cow-bfs/"},{"categories":["ACM"],"content":"Sample Output 4 ","date":"2018-07-22","objectID":"/posts/poj-3278-catch-that-cow-bfs/:0:4","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278-catch-that-cow-bfs/"},{"categories":["ACM"],"content":"Hint The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. ","date":"2018-07-22","objectID":"/posts/poj-3278-catch-that-cow-bfs/:0:5","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278-catch-that-cow-bfs/"},{"categories":["ACM"],"content":"题意： 农场主的牛不见了，主人和牛在一条直线上，且牛没有新的目标，它不会走动，主人的位置是你n，牛的位置是k，主人可以有三种走路的方法，右左（距离+-1），闪现（距离+x,x为当前位置），每走一步，一分钟，问几分钟主人能找到牛。bfs搜索方向即为三个“方向”。搜索所有走法； #include\"iostream\"#include\u003cqueue\u003e#include\"string.h\"using namespace std; int n,k; bool sign[200007]; struct node{ int x,step; }; bool check(int a) { if(!sign[a]\u0026\u0026a\u003e=0\u0026\u0026a\u003c110000) return true; return false; } void bfs() { node u,v; queue\u003cnode\u003e q; v.x=n;//初始化起点 v.step=0; q.push(v); sign[v.x]=true; while(!q.empty()){ u=q.front(); q.pop(); if(u.x==k){ cout\u003c\u003cu.step\u003c\u003cendl; return ; } //三种前进方向，左右和闪现 v=u; v.x++; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } v=u; v.x--; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } v=u; v.x=2*v.x; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } } } int main() { cin\u003e\u003en\u003e\u003ek; memset(sign,0,sizeof(sign)); bfs(); return 0; } ","date":"2018-07-22","objectID":"/posts/poj-3278-catch-that-cow-bfs/:0:6","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278-catch-that-cow-bfs/"},{"categories":["ACM"],"content":"英文原题链接 ","date":"2018-07-22","objectID":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:0","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维bfs最短路）","uri":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"Description - 题目描述 你被困在一个三维的空间中,现在要寻找最短路径逃生！ 空间由立方体单位构成 你每次向上下前后左右移动一个单位需要一分钟 你不能对角线移动并且四周封闭 是否存在逃出生天的可能性？如果存在，则需要多少时间？ ","date":"2018-07-22","objectID":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:1","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维bfs最短路）","uri":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"Input - 输入 输入第一行是一个数表示空间的数量。 每个空间的描述的第一行为L，R和C（皆不超过30）。 L表示空间的高度。R和C分别表示每层空间的行与列的大小。 随后L层地牢，每层R行，每行C个字符。 每个字符表示空间的一个单元。'#‘表示不可通过单元，’.‘表示空白单元。你的起始位置在’S’，出口为’E'。 每层空间后都有一个空行。L，R和C均为0时输入结束。 ","date":"2018-07-22","objectID":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:2","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维bfs最短路）","uri":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"Output - 输出 每个空间对应一行输出。 如果可以逃生，则输出如下 Escaped in x minute(s). 　x为最短脱离时间。 如果无法逃生，则输出如下 Trapped! ","date":"2018-07-22","objectID":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:3","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维bfs最短路）","uri":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"Sample Input - 输入样例 3 4 5 S.... .###. .##.. ###.# ##### ##### ##.## ##... ##### ##### #.### ####E 1 3 3 S## #E# ### 0 0 0 ","date":"2018-07-22","objectID":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:4","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维bfs最短路）","uri":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"Sample Output - 输出样例 Escaped in 11 minute(s). Trapped! 类似二维四个方向的bfs最短路，改成上下东西南北就行了，三维bfs最短路 #include \u003ciostream\u003e#include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cqueue\u003e#include \u003calgorithm\u003eusing namespace std; char map[35][35][35]; int vis[35][35][35]; int k,n,m,sx,sy,sz,ex,ey,ez; int to[6][3] = {{0,0,1},{0,0,-1},{0,1,0},{0,-1,0},{1,0,0},{-1,0,0}};//上下东西南北 struct node { int x,y,z,step; }; int check(int x,int y,int z)//检查是否可走 { if(x\u003c0 || y\u003c0 || z\u003c0 || x\u003e=k || y\u003e=n || z\u003e=m)//越界判断 return 1; else if(map[x][y][z] == '#') return 1; else if(vis[x][y][z]) return 1; return 0; } int bfs() { int i; node a,next; queue\u003cnode\u003e Q; a.x = sx,a.y = sy,a.z = sz; a.step = 0; vis[sx][sy][sz] = 1; Q.push(a); while(!Q.empty()) { a = Q.front(); Q.pop(); if(a.x == ex \u0026\u0026 a.y == ey \u0026\u0026 a.z == ez) return a.step; for(i = 0; i\u003c6; i++) { next = a; next.x = a.x+to[i][0]; next.y = a.y+to[i][1]; next.z = a.z+to[i][2]; if(check(next.x,next.y,next.z)) continue; vis[next.x][next.y][next.z] = 1; next.step = a.step+1; Q.push(next); } } return 0; } int main() { int i,j,r; while(scanf(\"%d%d%d\",\u0026k,\u0026n,\u0026m),n+m+k) { for(i = 0; i\u003ck; i++) { for(j = 0; j\u003cn; j++) { scanf(\"%s\",map[i][j]); for(r = 0; r\u003cm; r++) { if(map[i][j][r] == 'S') { sx = i,sy = j,sz = r; } else if(map[i][j][r] == 'E') { ex = i,ey = j,ez = r; } } } } memset(vis,0,sizeof(vis)); int ans; ans = bfs(); if(ans) printf(\"Escaped in %d minute(s).\\n\",ans); else printf(\"Trapped!\\n\"); } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:5","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维bfs最短路）","uri":"/posts/poj-2251-dungeon-master%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 63659 Accepted: 30423 ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:0","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:1","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"Input 输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n * n的矩阵内描述棋盘，以及摆放棋子的数目。 n \u003c= 8 , k \u003c= n 当为-1 -1时表示输入结束。 随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:2","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"Output 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C\u003c2^31）。 ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:3","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"Sample Input 2 1 #. .# 4 4 ...# ..#. .#.. #... -1 -1 ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:4","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"Sample Output 2 1 ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:5","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"Source 蔡错@pku ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:6","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"思路 下子方案数就相当于遍历图的不同遍历数，用dfs变形。 理解以下数据还有样例应该差不多了 3 2 #.. .#. ..# 3 3 2 #.. .## ..# 4 ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:7","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"AC代码 #include\u003ciostream\u003e#include\u003ccstdio\u003e#include\u003ccstring\u003e#include\u003calgorithm\u003eusing namespace std; char mp[8][8]; int v[8]; int n,k,w,r;//状态计数器r void dfs(int x)//逐行深搜，x为当前搜索行 { if(w==k)//下子数w { r++;return; } if(x==n)return; for(int i=0;i\u003cn;i++) { if(v[i]!=1\u0026\u0026mp[x][i]=='#') { v[i]=1; w++; dfs(x+1); w--; v[i]=0; } } dfs(x+1);//搜索下一行 } int main() { while(cin\u003e\u003en\u003e\u003ek) { if(n==-1\u0026\u0026k==-1) return 0; memset(mp,0,sizeof(mp)); memset(v,0,sizeof(v)); for(int i=0;i\u003cn;i++) cin\u003e\u003emp[i]; w=0;r=0; dfs(0); cout\u003c\u003cr\u003c\u003cendl; } } 传送门 ","date":"2018-07-22","objectID":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/:0:8","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321-%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98dfs/"},{"categories":["ACM"],"content":"Find The Multiple Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 40713 Accepted: 17088 Special Judge ","date":"2018-07-22","objectID":"/posts/poj-1426-find-the-multipledfs/:1:0","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426-find-the-multipledfs/"},{"categories":["ACM"],"content":"Description Given a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits. ","date":"2018-07-22","objectID":"/posts/poj-1426-find-the-multipledfs/:1:1","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426-find-the-multipledfs/"},{"categories":["ACM"],"content":"Input The input file may contain multiple test cases. Each line contains a value of n (1 \u003c= n \u003c= 200). A line containing a zero terminates the input. ","date":"2018-07-22","objectID":"/posts/poj-1426-find-the-multipledfs/:1:2","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426-find-the-multipledfs/"},{"categories":["ACM"],"content":"Output For each value of n in the input print a line containing the corresponding value of m. The decimal representation of m must not contain more than 100 digits. If there are multiple solutions for a given value of n, any one of them is acceptable. ","date":"2018-07-22","objectID":"/posts/poj-1426-find-the-multipledfs/:1:3","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426-find-the-multipledfs/"},{"categories":["ACM"],"content":"Sample Input 2 6 19 0 ","date":"2018-07-22","objectID":"/posts/poj-1426-find-the-multipledfs/:1:4","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426-find-the-multipledfs/"},{"categories":["ACM"],"content":"Sample Output 10 100100100100100100 111111111111111111 给定一个正整数n，请编写一个程序来寻找n的一个非零的倍数m，这个m应当在十进制表示时每一位上只包含0或者1。你可以假定n不大于200且m不多于100位。 提示：本题采用Special Judge，你无需输出所有符合条件的m，你只需要输出任一符合条件的m即可。 #include\"iostream\"using namespace std; typedef unsigned long long ll; int n; bool sign; void dfs(ll x,int count) { if(sign) return ; if(x%n==0){ sign=true; cout\u003c\u003cx\u003c\u003cendl; return ; } if(count==19)//m最多200位 return ; dfs(x*10,count+1); dfs(x*10+1,count+1); //每两位数后两位有两种情况，10或11，深搜所有情况，找到一种就返回，找不到找另外一颗子树 } int main() { while(cin\u003e\u003en\u0026\u0026n) { sign=false; dfs(1,0); } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-1426-find-the-multipledfs/:1:5","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426-find-the-multipledfs/"},{"categories":["ACM"],"content":"Codeforces Round 498 (Div. 3) A. Adjacent Replacements（水）","date":"2018-07-22","objectID":"/posts/adjacent-replacements/","tags":["Codeforces","ACM","C++"],"title":"Adjacent Replacements","uri":"/posts/adjacent-replacements/"},{"categories":["ACM"],"content":"A. Adjacent Replacements 第一次打cf就做出一道这样的找规律的题，打到自闭。 #include\u003cbits/stdc++.h\u003eusing namespace std; int main(){ int n,a[1001]; cin\u003e\u003en; int i; int flag=0; for(i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; if(!(a[i]\u00261)) a[i]--; if(!flag) {cout\u003c\u003ca[i];flag=1;} else cout\u003c\u003c\" \"\u003c\u003ca[i]; } return 0; } ","date":"2018-07-22","objectID":"/posts/adjacent-replacements/:0:0","tags":["Codeforces","ACM","C++"],"title":"Adjacent Replacements","uri":"/posts/adjacent-replacements/"},{"categories":["ACM"],"content":"迷宫问题 Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 32323 Accepted: 18471 ","date":"2018-07-22","objectID":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/:0:1","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题(bfs路径)","uri":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/"},{"categories":["ACM"],"content":"Description 定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 ","date":"2018-07-22","objectID":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/:0:2","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题(bfs路径)","uri":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/"},{"categories":["ACM"],"content":"Input 一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 ","date":"2018-07-22","objectID":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/:0:3","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题(bfs路径)","uri":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/"},{"categories":["ACM"],"content":"Output 左上角到右下角的最短路径，格式如样例所示。 ","date":"2018-07-22","objectID":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/:0:4","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题(bfs路径)","uri":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/"},{"categories":["ACM"],"content":"Sample Input 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 ","date":"2018-07-22","objectID":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/:0:5","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题(bfs路径)","uri":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/"},{"categories":["ACM"],"content":"Sample Output (0, 0) (1, 0) (2, 0) (2, 1) (2, 2) (2, 3) (2, 4) (3, 4) (4, 4) 对于新手来说，主要是bfs路径的问题有点难度，搞得晕晕的。 #include\u003ciostream\u003e#include\u003ccstring\u003eusing namespace std; int map[5][5]; int visited[5][5]; int dx[4]={0, 1, 0, -1}; int dy[4]={ 1, 0,-1, 0}; int head,tail; struct node{ int xx,yy; int fa;//父节点 }pre[25],way[25]; void BFS(int x,int y) { int x1,y1; head=0,tail=1; visited[x][y]=1; pre[0].xx=x,pre[0].yy=y; while(tail\u003ehead)//栈空 { x=pre[head].xx; y=pre[head].yy; if(x==4\u0026\u0026y==4)//结束标志 return ; for(int i=0;i\u003c4;i++) { x1=x+dx[i];y1=y+dy[i]; if(x1\u003e=0\u0026\u0026x1\u003c=4\u0026\u0026y1\u003e=0\u0026\u0026y1\u003c=4) if(map[x1][y1]==0\u0026\u0026!visited[x1][y1]) { pre[tail].xx=x1; pre[tail].yy=y1; pre[tail].fa=head; visited[x1][y1]=1; tail+=1;//入栈 } } head++;//相当于出栈 } } int main() { int i,j; ios::sync_with_stdio(false); memset(map,0,sizeof(map)); memset(visited,0,sizeof(visited)); for(i=0;i\u003c5;i++) for(j=0;j\u003c5;j++) cin\u003e\u003emap[i][j]; BFS(0,0); i=0; while(head)//逆序进行赋值输出就是通路 { way[i].xx=pre[head].xx; way[i].yy=pre[head].yy; head=pre[head].fa; i++; } //画一下队列 way[i].xx=0;way[i].yy=0; while(i!=-1) { cout\u003c\u003c\"(\"\u003c\u003cway[i].xx\u003c\u003c\", \"\u003c\u003cway[i].yy\u003c\u003c\")\"\u003c\u003cendl; i--; } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/:0:6","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题(bfs路径)","uri":"/posts/poj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98bfs%E8%B7%AF%E5%BE%84/"},{"categories":["ACM"],"content":"链接:https://www.nowcoder.com/acm/contest/133/A 来源:牛客网 ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:0","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"题目描述 现在有一棵被Samsara-Karma染了k种颜色的树，每种颜色有着不同的价值,Applese觉得Samsara-Karma染的太难看了，于是打算把整棵树重新染成同一种颜色，但是，由于一些奥妙重重的原因，每一次染色Applese可以选择两个有边相连的点，将其中一个染成另一个的颜色。而进行一次这样的操作需要付出两种颜色价值和的代价， 现在，Applese的钱要用来买书(game)，所以他想要最小化代价 ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:1","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"输入描述: 输入包括若干行第一行包括一个数n，表示这棵树有n个节点第二行包括n个数，第i个数表示第i个节点的颜色coli 注意：一个颜色的标号即价值接下来的n - 1行，每行包括两个数u, v，表示u节点与v节点之间有一条无向边n ≤ 100000, 1 ≤ coli ≤ 1e9，数据保证是一棵树 ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:2","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"输出描述: 输出包括一行第一行包括一个数，表示最小代价 ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:3","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"示例1 输入 4 2 3 4 3 1 2 2 3 3 4 输出 12 蒟蒻暴力枚举-_-! #include \u003cbits/stdc++.h\u003e using namespace std; const int MAXN=1e5+10; int a[MAXN]; map\u003cint, int \u003ema; set\u003cint\u003ese; int x[MAXN],y[MAXN]; int main() { int n; scanf(\"%d\",\u0026n); for (int i = 1; i \u003c=n ; ++i) { scanf(\"%d\",\u0026a[i]); se.insert(a[i]); } for (int i = 1; i \u003cn ; ++i) { scanf(\"%d%d\",\u0026x[i],\u0026y[i]); } long long ans=1e14,sum=0; set\u003cint\u003e::iterator it; for (it=se.begin(); it !=se.end() ; ++it) { sum=0; for (int j = 1; j \u003c=n ; ++j) { if((*it)!=a[j]) sum+=((*it)+a[j]); } ans=min(sum,ans); } printf(\"%lld\\n\",ans); return 0; } 最后想说这都过了什么鬼，不会数据这么弱吧？？！?我只枚举了最小的价值颜色的情况，唉，不管了不管了。 #include\u003cbits/stdc++.h\u003eusing namespace std; int a[1000000],n,m,k=1,t,ans=0; int main() { scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;++i) scanf(\"%d\",\u0026a[i]); sort(a+1,a+n+1); for(int i=2;i\u003c=n;++i) if(a[i]!=a[1]) ans+=a[i]+a[1]; printf(\"%d\",ans); return 0; } ","date":"2018-07-22","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/:0:4","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛20-染色","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2/"},{"categories":["ACM"],"content":"Oil Deposits 翻译 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 41406 Accepted Submission(s): 23977 Problem Description The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. Input The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 \u003c= m \u003c= 100 and 1 \u003c= n \u003c= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ' * ‘, representing the absence of oil, or ‘@’, representing an oil pocket. Output For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. Sample Input 1 1 * 3 5 *@*@* **@** *@*@* 1 8 @@****@* 5 5 ****@ *@@*@ *@**@ @@@*@ @@**@ 0 0 Sample Output 0 1 2 2 Source Mid-Central USA 1997 Recommend Eddy | We have carefully selected several similar problems for you: 1016 1010 1312 1242 1240 思路 dfs模板题吧，八个方向搜索；（像i，j这样的计数器还是写在局部比较好，我尽然被定义域的问题搞了一晚上醉了醉了。。。） #include\u003cbits/stdc++.h\u003eusing namespace std; int n,m,s; char maze[107][107]; int vx[8]={-1,1,0,0,-1,-1,1,1}; int vy[8]={0,0,-1,1,-1,1,1,-1}; void dfs(int x,int y){ maze[x][y]='*'; for(int i=0;i\u003c8;i++){ int tx=x+vx[i]; int ty=y+vy[i]; if(tx\u003e=0\u0026\u0026tx\u003cm\u0026\u0026ty\u003e=0\u0026\u0026ty\u003cn\u0026\u0026maze[tx][ty]=='@') dfs(tx,ty); } } int main(){ int i,j; while(cin\u003e\u003em\u003e\u003en\u0026\u0026m){ s=0; for(i=0;i\u003cm;i++) cin\u003e\u003emaze[i]; for(i=0;i\u003cm;i++){//相当于不连通的情况 for(j=0;j\u003cn;j++){ if(maze[i][j]=='@'){ dfs(i,j); s++; } } } cout\u003c\u003cs\u003c\u003cendl; } return 0; } ","date":"2018-07-22","objectID":"/posts/hud-1241-oil-deposits-dfs/:1:0","tags":["DFS","搜索","HDU","ACM","C++"],"title":"hud-1241-Oil Deposits (dfs)","uri":"/posts/hud-1241-oil-deposits-dfs/"},{"categories":["ACM"],"content":"假设有一个n行m列的迷宫，每个单位要么是空地(用1表示)要么是障碍物(用0表示). 如和找到从起点到终点的最短路径？利用BFS搜索，逐步计算出每个节点到起点的最短距离， 以及最短路径每个节点的前一个节点。最终将生成一颗以起点为根的BFS树。此时BFS可以求出任意一点到起点的距离。 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"图 1 3 0 21 23 2 0 17 20 22 4 0 14 0 0 5 0 12 15 18 6 8 10 0 19 7 9 11 13 16 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:1:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"输入 6 5 1 1 0 1 1 1 0 1 1 1 1 0 1 0 0 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:2:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"输出 1 2 4 5 6 8 10 12 14 17 20 21 23 12//最短距离 ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:3:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"代码 #include\u003ciostream\u003e#include\u003cqueue\u003e#include\u003ccstdio\u003e#include\u003ccstring\u003e#include\u003cvector\u003eusing namespace std; const int maxn=100+5; int G[maxn][maxn]; //存图的d=id int path[maxn]; //存每个节点的父节点，即路径 int n,m; //n行 m列 int k=1;//记录编号 int end_num; int vx[5] = {-1,1,0,0}; //vx vy用来计算一个节点周围上下左右4个节点 int vy[5] = {0,0,-1,1}; bool vis[maxn][maxn]; //判断某节点是否已经被访问过 struct node { int x; int y; int id; int parent=0; node(int a,int b,int c) { x=a; y=b; id=c; } }; int main() { //freopen(\"in.txt\",\"r\",stdin); memset(G,0,sizeof(G)); memset(vis,0,sizeof(vis)); memset(path,0,sizeof(path)); cin\u003e\u003en\u003e\u003em; for(int i=1; i\u003c=n; i++) for(int j=1; j\u003c=m; j++) { cin\u003e\u003eG[i][j]; } queue\u003cnode\u003e q; node v=node(1,1,1); q.push(v); vis[1][1]=1; while(!q.empty()) { node u=q.front(); q.pop(); path[u.id]=u.parent;//记录每个点的父节点 for(int i=0; i\u003c4; i++) { int tx=u.x+vx[i]; int ty=u.y+vy[i]; if(G[tx][ty]\u0026\u0026!vis[tx][ty])//有路可走且未访问 { vis[tx][ty]=1; //cout\u003c\u003ctx\u003c\u003cty\u003c\u003cendl; node v=node(tx,ty,++k); end_num=k; v.parent=u.id; q.push(v); } } } vector\u003cint\u003e ans; //cout\u003c\u003cend_num\u003c\u003cendl; while(end_num)//从后面开始找父亲节点 { ans.push_back(end_num); end_num=path[end_num]; } int s=0; while(!ans.empty()) { s++; cout\u003c\u003c*(ans.end()-1)\u003c\u003c' ';//ans最后一个元素是0 ans.pop_back(); } cout\u003c\u003cendl\u003c\u003cs-1; return 0; } ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:4:0","tags":["BFS","搜索","C++"],"title":"BFS求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"那天晚上报名了没打，第二天早上打的，也只出了两题。 ","date":"2018-07-22","objectID":"/posts/educational-codeforces-round-47-rated-for-div.-2/:0:0","tags":["Codeforces","ACM","C++","C"],"title":"Educational Codeforces Round 47 (Rated for Div. 2)","uri":"/posts/educational-codeforces-round-47-rated-for-div.-2/"},{"categories":["ACM"],"content":"A. Game Shopping #include\u003ciostream\u003eusing namespace std; int main(){ int n,m,s=0; cin\u003e\u003en\u003e\u003em; int i,j; int c[1000],a[1000]; for(i=0;i\u003cn;i++) cin\u003e\u003ec[i]; for(i=0;i\u003cm;i++) cin\u003e\u003ea[i]; for(i=0,j=0;i\u003cn;){ if(j==m) break; if(c[i]\u003c=a[j]){ s++; j++; i++; } else i++; } if(i==n\u0026\u0026s==0) cout\u003c\u003c\"0\\n\"; else cout\u003c\u003cs\u003c\u003cendl; return 0; } ","date":"2018-07-22","objectID":"/posts/educational-codeforces-round-47-rated-for-div.-2/:1:0","tags":["Codeforces","ACM","C++","C"],"title":"Educational Codeforces Round 47 (Rated for Div. 2)","uri":"/posts/educational-codeforces-round-47-rated-for-div.-2/"},{"categories":["ACM"],"content":"B. Minimum Ternary String #include \u003cbits/stdc++.h\u003eusing namespace std; string s, ans; int main(){ cin \u003e\u003e s; int one = 0; for (int i = 0; i \u003c s.size(); i++){ if (s[i] == '0') ans += \"0\"; if (s[i] == '1') one++; if (s[i] == '2') ans += \"2\"; } bool flag = false; for (int i = 0; i \u003c ans.size(); i++){ if (ans[i] == '2' \u0026\u0026 !flag) flag = true, cout \u003c\u003c string(one, '1'); cout \u003c\u003c ans[i]; } if (!flag) cout \u003c\u003c string(one, '1'); return 0; } /* 100210 11222121 20 2001 020201 2012101 111 000 */ ","date":"2018-07-22","objectID":"/posts/educational-codeforces-round-47-rated-for-div.-2/:2:0","tags":["Codeforces","ACM","C++","C"],"title":"Educational Codeforces Round 47 (Rated for Div. 2)","uri":"/posts/educational-codeforces-round-47-rated-for-div.-2/"},{"categories":["ACM"],"content":" 2018年全国多校算法寒假训练营练习比赛（第二场）B(0 1背包变化 特殊处理一个物品) 链接：https://www.nowcoder.com/acm/contest/74/B 来源：牛客网 ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:0","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"题目描述 Taotao的电脑带不动绝地求生，所以taotao只能去玩pc版的荒野行动了， 和绝地求生一样，游戏人物本身可以携带一定重量m的物品，装备背包 之后可以多携带h（h为0代表没有装备背包）重量的东西。玩了几天 taotao发现了一个BUG，当装备背包之后，如果可携带重量没有满，就 可以拿一个任意重的东西。（解释看样例）有一天taotao空降到了一个 奇怪的岛上，岛上有n件装备，每个装备都有重量Wi和威力值Vi,但taotao 不认识这些装备，所以他来求助你，挑选威力最大的装备，帮助他吃鸡。 ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:1","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"输入描述: 本题有多组输入（小于10），当n=0时结束输入。第一行输入n,m,h。n，m，h为整数，并且0\u003c=n,m,h\u003c=100，接下来n行，每行输入第i个物品的物品的重量Wi和威力值Vi。0\u003c=Wi,Vi\u003c=100. ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:2","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"输出描述: 输出最大威力值，每组输出一行。 ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:3","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"示例1 输入 3 3 3 2 3 3 2 2 3 0 输出 8 ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:4","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"说明 可携带的总重量为6，当拿了前两件装备，此时容量为5/6，还可以再拿第三件物品。 思路：0-1背包的变形题目，h=0的时候为背包的模板，h！=0的时候枚举每一个需要特殊处理的物品再背包 #include \u003cbits/stdc++.h\u003eusing namespace std; int v[105]; int w[105]; int n,m,h; int dp[205]; int main() { while(scanf(\"%d\",\u0026n)==1\u0026\u0026n!=0){ int sum=0; scanf(\"%d%d\",\u0026m,\u0026h); for(int i=1;i\u003c=n;i++) scanf(\"%d%d\",\u0026w[i],\u0026v[i]); if(h==0){ memset(dp,0,sizeof(dp)); for(int i=1;i\u003c=n;i++) //前i个物品 for(int j=m;j\u003e=w[i];j--) //枚举背包重量 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); // sum=dp[m]; } else{ m+=h for(int k=1;k\u003c=n;k++) //枚举可以被剩下的物品 { memset(dp,0,sizeof(dp)); for(int i=1;i\u003c=n;i++){ //前i个物品 if(i!=k){ for(int j=m;j\u003e=w[i];j--) //枚举背包重量 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); } } //留下来一个重量，即初始化威力为那个重量的威力 for(int j=m-1;j\u003e=m-w[k];j--) //枚举背包重量+剩下物品 dp[m]=max(dp[m],dp[j]+v[k]); // printf(\"%d\\n\",dp[m]); sum=max(sum,dp[m]); } } printf(\"%d\\n\",sum); } return 0; } ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:5","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"百度知道 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1、每行数字左右对称，由1开始逐渐变大，然后变小，回到1。 2、第n行的数字个数为n个。 3、第n行数字和为2^(n－1)。 4、每个数字等于上一行的左右两个数字之和。可用此性质写出整个帕斯卡三角形。 5、将第2n+1行第1个数，跟第2n+2行第3个数、第2n+3行第5个数……连成一线，这些数的和是第2n个斐波那契数。将第2n行第2个数，跟第2n+1行第4个数、第2n+2行第6个数……这些数之和是第2n-1个斐波那契数。 6、第n行的第1个数为1，第二个数为1×(n-1)，第三个数为1×(n-1)×（n-2）/2，第四个数为1×(n-1)×（n-2）/2×（n-3）/3…依此类推。 此数列中各行中的数字正好是二项式a+b乘方后，展开始终各项的系数。如： (a+b)^1=a^1+b^1 (a+b)^2=a^2+2ab+b^2 (a+b)^3=a^3+3a^2b+3ab^2+b^3 …… (a+b)^6=a^6+6a^5b+15a^4b^2+20a^3b^3+15a^2b^4+6ab^5+b^6（注意发现规律） …… 二项式展开式：","date":"2018-07-22","objectID":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/:0:0","tags":["数学","杨辉三角"],"title":"杨辉三角","uri":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"},{"categories":["ACM"],"content":"广度优先搜索（BFS） 广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。访问了就入队。 ","date":"2018-07-22","objectID":"/posts/dfs_bfs/:0:1","tags":["ACM","BFS","DFS","搜索","C","C++"],"title":"深搜广搜","uri":"/posts/dfs_bfs/"},{"categories":["ACM"],"content":"深度优先搜索（DFS） 深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。 #include \u003cbits/stdc++.h\u003e#define N 5 using namespace std; int maze[N][N] = {//无权有向图邻接矩阵 { 0, 1, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 0 } }; int visited[N]; void DFS(int start) { cout \u003c\u003c start\u003c\u003c \" \"; visited[start] = 1; for (int i = 0; i \u003c N; i++) { if (!visited[i] \u0026\u0026 maze[start][i] == 1)//没访问过且为邻居节点 DFS(i); } } void BFS(int start){ queue\u003cint\u003e Q;//队列 Q.push(start); visited[start] = 1; while (!Q.empty()) { int front = Q.front();//头 cout \u003c\u003c front \u003c\u003c \" \"; Q.pop(); for (int i = 0; i \u003cN; i++) { if (!visited[i] \u0026\u0026 maze[front][i] == 1) { visited[i] = 1; Q.push(i); } } } } int main() { memset(visited,0,sizeof(visited)); for (int i = 0; i \u003c N; i++)//不连通的情况 { if (visited[i] == 1)//访问过 continue; DFS(i); } cout\u003c\u003cendl; memset(visited,0,sizeof(visited)); for (int i = 0; i \u003c N; i++)//不连通的情况 { if (visited[i] == 1)//访问过 continue; BFS(i); } return 0; } 传送门 ","date":"2018-07-22","objectID":"/posts/dfs_bfs/:0:2","tags":["ACM","BFS","DFS","搜索","C","C++"],"title":"深搜广搜","uri":"/posts/dfs_bfs/"},{"categories":["ACM"],"content":"时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld 题目描述 有一个长度为n的序列a，已知a[1]=a[n]=1，且对于2 \u003c= x \u003c= n，a[x] / a[x-1]是以下三个数字之一 [ 1，-2，0.5 ],问有多少种不同的序列满足题意。 两个序列不同当且仅当它们有至少一个位置上的数字不同，序列a可以为任何实数。 输入描述: 一个整数 表示n (1\u003c= n \u003c= 1e3) 输出描述: 一个整数 表示答案模109+7 示例1 输入 5 输出 7 解题思路： 整体来看，a[x] = a[x-1] * [1, -2, 0.5]，那么等于从n-1个[1,-2,0.5]中选出n-1个数值相乘（a[x-1]=a[x-2] * [1,-2,0.5]同理化简式子）， 最后答案要是1，所以-2就必须有偶数个，同理0.5的个数要等于-2.顺序无关. 那所有的转换中，就只要保证有若干组(-2,-2,0.5,0.5)存在 表示偶数个2的个数与偶数个0.5的个数组合；组合数用二项式系数，杨辉三角来求。 #include \u003cbits/stdc++.h\u003eusing namespace std; const int maxn = 1e3 + 5; const int mod = 1e9 + 7; long long c[maxn][maxn]; int main(){ for(int i = 0; i \u003c maxn; i++){//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(int j = 1; j \u003c i; j++) c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod; } int n; while(~scanf(\"%d\", \u0026n)){ n--; long long ans = 0; for(int i = 0; i*2 \u003c= n; i += 2){ ans = (ans%mod + (c[n][i]*c[n-i][i])%mod)%mod; } printf(\"%lld\\n\", ans); } return 0; } ","date":"2018-07-18","objectID":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B18-%E5%BA%8F%E5%88%97/:0:0","tags":["组合数学","ACM","Nowcoder","C++","C"],"title":"Wannafly挑战赛18-序列","uri":"/posts/wannafly%E6%8C%91%E6%88%98%E8%B5%9B18-%E5%BA%8F%E5%88%97/"},{"categories":["ACM"],"content":"弱鸡还是弱鸡啊最简单的背包问题——。——！ ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:0:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["ACM"],"content":"1) 问题描述: 假设有一个能装入总体积为T的背包和n件体积分别为W1，W2，···，Wn的物品，能否从n件物品中挑选若干件恰好装满背包，即使W1+W2+···+Wn=T，要求找出所有满足上述条件的解。例如：当T=10，共6件物品，物品的体积为{1，2，3，4，5，8}，那么可找到下列4组解：（1，2，3，4）、（1，4，5）、（2，3，5）、（2、8）。 ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:1:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["ACM"],"content":"2) 实现提示： 可利用回溯法的设计思想来解决背包问题。首先，将物品排成一列，然后顺序选取物品装入背包，假设已选取了前i件物品之后背包还没有装满，则继续选取第i+1件物品，若该件物品“太大”不能装入，则丢弃而继续选取下一件，直至背包装满为止。但如果在剩余的物品中找不到合适的物品以填满背包，则说明“刚刚”装入背包的那件物品“不合适”，应将它取出“丢弃一边”，继续再从“它之后”的物品中选取，如此重复，直至求得满足条件的解，或者无解。由于回溯求解的规则是“后进先出”，因此要用到栈。 使用栈作为该程序的数据结构，利用栈进行语法检查，以深度优先的搜索方式解空间，实现递归过程和函数的调用，在设计时还使用C语言的数组及其循环语言来实现程序。 运用回溯法解题，在搜索解空间树时，只要其左儿子节点是一个可行结点，搜索就进入左子树，在右子树中有可能包含最优解是才进入右子树搜索。否则将右子树剪去。 #include \u003cstdio.h\u003e#include \u003cwindows.h\u003e#define size 50 struct stacks { int data[size]; int top; } stack; void backpack(int number,int V,int w[]){ int i,j=1,k=0; int flag=0; do { while (V \u003e 0 \u0026\u0026 k \u003c= number) { if (V \u003e= w[k]) { stack.data[stack.top] = k;//第k个物品的体积下标 stack.top++; V -= w[k]; } k++; } if (V == 0) { flag=1; printf(\"第%d个符合条件的解：\", j); for (i = 0; i \u003c stack.top; i++) { printf(\"%d \", w[stack.data[i]]); } j++; printf(\"\\n\"); } //k满时回溯 k = stack.data[--stack.top]; stack.data[stack.top] = 0; V += w[k]; k++; } while (!(stack.top == 0 \u0026\u0026 k == number)); if(!flag){ printf(\"背包无解！\\n\"); } } void judge(int number,int V,int w[]){ int i,s = 0; for (i = 0; i \u003c number; i++) s = s + w[i]; if(V \u003e s){ printf(\"背包无解！\\n\"); exit(0); } if(V==s){ printf(\"只有一个符合条件的解：%d\\n\", V); exit(0); } } int main() { int w[size]; int V; int i = 0; int j = 0; int number; printf(\"\\t**简单背包问题**\\n\\n\"); printf(\"\\n请输入可供选择装入物品的个数：\\n\"); scanf(\"%d\", \u0026number); printf(\"\\n请输入各件物品的体积：\\n\"); for (i = 0; i \u003c number; i++) scanf(\"%d\", \u0026w[i]); //排序 for(i=0;i\u003cnumber;i++) for(j=i+1;j\u003cnumber;j++) if(w[i]\u003ew[j]){ w[i]=w[i]^w[j]; w[j]=w[i]^w[j]; w[i]=w[i]^w[j]; } printf(\"\\n请输入背包的总体积：\\n\"); scanf(\"%d\", \u0026V); while(V \u003c 0){ printf(\"输入背包体积错误！重新输入！\\n\"); scanf(\"%d\",\u0026V); } judge(number,V,w); //初始化栈 for (i = 0; i \u003c number; i++) stack.data[i] = 0; stack.top = 0; backpack(number,V,w); return 0; } --这么简单的问题我都费力，太辣鸡了 ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:2:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["生活随笔"],"content":"呃呃呃呃呃，今天四六级考试我昨天才知道，而就在昨天做计算机组成原理的课设接线的时候，我买了一个域名lruihao.cn 做完后实验后开开心心回到宿舍解析域名，实名认证什么，coding和github双部署什么的，在一切都完成后本打算享受地躺在床上欣赏一下自己的“杰作”的， 可是最后部署失败，作为小白的我，当然看不懂，然后又各种百度谷歌，翻博客，还是没有解决，于是乎我刚刚搞好的www.lruihao.cn 强势的显示出404错误， 额，因为我不知道原因的情况下一激动把coding托管的代码删除了，还好github上还有个备份，被自己的操作蠢哭。 搞到晚上11多还是没有解决，介于第二天四级考试，不舍地睡着了，当然也睡得很快hhhhh，确实有点累，中午没午休。。。今天7:30醒来准备好考试相关工具后，又搞了一下，还是无果，考试完，和女朋友吃了个饭，送到亲民后，我很快回到寝室继续研究，实在不懂，我做出一个大胆的决定，我打算重新搭hexo，然后我git，node，hexo 所有的东西都删了，简单暴力，重新来了一遍。。。 最后，写这篇流水账不是想说我有多牛逼，多无聊（不过好像是有点。。。），我只是想试试重装后能不能部署，这篇博客能不能发出去。。。。唉ε=(´ο｀* ))) ","date":"2018-06-16","objectID":"/posts/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%80%83%E8%AF%95/:0:0","tags":["生活随笔"],"title":"四六级考试","uri":"/posts/%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%80%83%E8%AF%95/"},{"categories":["ACM"],"content":" 来自一位大佬的演讲 尊敬的领导、教练，亲爱的参赛选手们： 大家好，我是来自广东工业大学的tmk。今天很荣幸能够站在这里代表全体参赛选手发言，与大家分享我的经历和感受。 刚开始来到大学的时候，我一心向学，本着“好好学习，天天向上，为校争光，不搞对象”的信念，想在大学一展宏图。因为高中OI的挫败，我在刚上大学的时候就选择了ACM这条“不归路”。一开始是因为高中的遗憾，到后来就完全是因为信念和兴趣慢慢一直搞到现在。当时的我还不知道踏上ACM这条路的苦，而如今的我却也尝到了ACM带给我的乐。 在这三年里，有数不清的夜晚，我的舍友们在寝室里开黑，而我和我的队友在机房里开黑；在这三年里，有数不清的周末，我的舍友们在校园里驰骋，而我和我的队友在题库里驰骋；在这三年里，有数不清的假期，我的舍友们在召唤师峡谷里征战，而我和我的队友在中国各省市征战。三年过去了，我的舍友们成为了offer收割机，而我和我的队友成为了气球收割机。 为了变强是一个痛苦且漫长的过程，只有耐得住寂寞，才能守得住繁华。我的一位队友为了变强甚至牺牲了自己的头发，仅仅是因为他担心他的头发阻碍了他思维的发散。他变秃了也变强了。 三年的 ACM 让我成长很多，收获很多。我也从一个“好好学习天天向上为校争光不搞对象”的无知青年变成了一个写的了工程查得出异常的准程序员。我觉得三年献身于ACM的日子是值得的，和一大堆萌萌的男孩子们在屋子里面一个又一个通宵奋斗的酣畅淋漓的日子是值得的，看着谈恋爱的大家一会儿哀伤一会儿忧愁而我与代码自得其乐矢志不渝的日子是值得的。此外他还给我带来两个最好的小伙伴，是他们的一路陪伴，让我有勇气一直走下去。我和他们走过的地方，比我和女朋友去过的地方还要多。噢，对了，我好像没有女朋友。总而言之，请珍惜你们的队友，他们是你们在大学里为数不多一起奋斗的小伙伴。希望大家像我一样，也爱着ACM，为自己心爱的努力。 最后预祝各位参赛选手们取得理想的成绩，也预祝本次大赛圆满成功。谢谢大家。 ","date":"2018-06-15","objectID":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80/:0:0","tags":["ACM","2018湘潭邀请赛"],"title":"18湘潭邀请赛参赛队员代表发言","uri":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80/"},{"categories":["ACM"],"content":"题目链接（hdu复赛） 2018年湘潭邀请赛，在湘大举行，当时一起打的过去的，因为没出市就方便点。第一次参加现场赛，首先反省一下自己，比赛前算法先不说(没有好好搞过)，就连普通的题，数学性质的题都很少刷，什么都不会，然后英语不说四六级的东西，很多专业英语词汇都没有好好了解过，主要的原因还是刷题刷少了，英文题刷少了。理所当然，成功拿下一铁，湘潭赛打铁告终。 比赛开始，这次是三个人没人一份纸质题目，拿到题目，看最后一题，k.2018发现可以做，(事实证明确实是一道水题)，我就在做这题，他们看了a题，好像是k题一顿操作后提交，错了，一直到比赛结束都没做出来，后来回去看别人的题解，发现自己情况没有分析全面，其实是完全可以解出来的，真的做的太少太少了。a题最后也是没过，还有一个f题，sort，我最初的想法是用stl里的那个sort排序，只要对sort的compare函数做处理应该可以完成排序，比赛之前我看过，但是不熟悉，zxm她也看了我就交给她了，最后好像因为爆long double的问题也没做出来。 哎，菜还是菜，很多算法都不懂，数据结构也没学好，很有一段时间我都特别头疼算法，不想学，费劲，觉得自己不适合学计算机，更不适合ACM。有时候又想，不适合好像总是loser的借口！总是在后悔和偷懒的矛盾中！ 最后，放上，“参赛奖\"羞辱自己，也是鞭策！ ","date":"2018-06-14","objectID":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93/:0:0","tags":["ACM","2018湘潭邀请赛","总结"],"title":"18湘潭邀请赛总结","uri":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93/"},{"categories":["ACM"],"content":"Sample Input 2 1 1 1 1 1 2 2 1 1 2 1 1 1 3 1 3 1 2 2 1 3 1 1 ","date":"2018-06-14","objectID":"/posts/f-sorting/:1:0","tags":["2018湘潭邀请赛","ACM"],"title":"F.sorting","uri":"/posts/f-sorting/"},{"categories":["ACM"],"content":"Sample Output 2 1 1 2 1 2 3 题意：给定n个元组(a1,b1,c1),(a2,b2,c2),…,(an,bn,cn)，将其按(ai+bi)/(ai+bi+ci)的值从小到大排序，输出排序后的n个元组的原序号； 思路：编写sort里的cmp函数(形参为元组结构体元素，设为Tuple x,Tuple y)，若直接算出(x.a+x.b)(y.a+y.b+y.c)和(y.a+y.b)(x.a+x.b+x.c)再比较大小，这两个结果会爆unsigned long long； 可以把因式乘积展开成多项式的和，约去两式中相同的项，得到x.ay.c+x.by.c和y.ax.c+y.bx.c，因此只需计算它俩再比较即可，结果不会爆unsigned long long 后AC代码 #include \"bits/stdc++.h\"using namespace std; struct node{ long double a,b,c; int numb; }ss[1005]; bool cmp(const node \u0026a,const node \u0026b){ long double suma,sumb; //suma=a.a*b.c+a.b*b.c; //sumb=b.a*a.c+b.b*a.c; suma=(a.a+a.b)/(a.a+a.b+a.c); sumb=(b.a+b.b)/(b.a+b.b+b.c); if(suma!=sumb)return suma\u003csumb; return a.numb\u003cb.numb; } int main(){ int n; while(cin\u003e\u003en){ for(int i=0;i\u003cn;i++){ cin\u003e\u003ess[i].a\u003e\u003ess[i].b\u003e\u003ess[i].c; ss[i].numb=i+1; } stable_sort(ss,ss+n,cmp); int i; for(i=0;i\u003cn-1;i++) cout\u003c\u003css[i].numb\u003c\u003c\" \"; cout\u003c\u003css[i].numb\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/f-sorting/:2:0","tags":["2018湘潭邀请赛","ACM"],"title":"F.sorting","uri":"/posts/f-sorting/"},{"categories":["ACM"],"content":"K. 2018 Given a,b,c,d, ﬁnd out the number of pairs of integers (x,y) where a ≤ x ≤ b,c ≤ y ≤ d and x·y is a multiple of 2018. ","date":"2018-06-14","objectID":"/posts/k-2018/:0:0","tags":["2018湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Input The input consists of several test cases and is terminated by end-of-ﬁle. Each test case contains four integers a,b,c,d. ","date":"2018-06-14","objectID":"/posts/k-2018/:1:0","tags":["2018湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Output For each test case, print an integer which denotes the result. ","date":"2018-06-14","objectID":"/posts/k-2018/:2:0","tags":["2018湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Constraint • 1≤ a ≤ b ≤109,1≤ c ≤ d ≤109 • The number of tests cases does not exceed 104. ","date":"2018-06-14","objectID":"/posts/k-2018/:3:0","tags":["2018湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Sample Input 1 2 1 2018 1 2018 1 2018 1 1000000000 1 1000000000 ","date":"2018-06-14","objectID":"/posts/k-2018/:4:0","tags":["2018湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"Sample Output 3 6051 1485883320325200 题意：给定区间[a,b]、[c,d]，问有多少对有序数组(x,y)(x∈[a,b],y∈[c,d])使得xy是2018的倍数 思路：2018=21009(分解质因数)，则对x分类讨论:1)仅为2的倍数；2）仅为1009的倍数；3）即为2又为1009的倍数；4）既不为2又不为1009的倍数 等价于如下分类讨论： 若x是偶数：1）若x是1009的倍数，则y可为[c,d]中任意数； 2）若x不是1009的倍数，则y必定为[c,d]中1009的倍数 若x是奇数：1）若x是1009的倍数，则y必定为[c,d]中2的倍数； 2）若x不是1009的倍数，则y必定为[c,d]中2018的倍数 后AC代码 #include\u003ccstdio\u003e#include\u003ciostream\u003etypedef unsigned long long ll; using namespace std; int main(){ ll a,b,c,d; while(cin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed){ ll num1_all_1009=b/1009-(a-1)/1009; ll num1_even=b/2-(a-1)/2; ll num1_1009_in_even=b/2018-(a-1)/2018; ll num1_rest_in_even=num1_even-num1_1009_in_even; ll num1_odd=(b-a+1)-num1_even; ll num1_1009_in_odd=num1_all_1009-num1_1009_in_even; ll num1_rest_in_odd=num1_odd-num1_1009_in_odd; ll ans=0; ans+=num1_1009_in_even*(d-c+1); ll num2_all_1009=d/1009-(c-1)/1009; ans+=num1_rest_in_even*num2_all_1009; ll num2_even=d/2-(c-1)/2; ans+=num1_1009_in_odd*num2_even; ll num2_all_2018=d/2018-(c-1)/2018; ans+=num1_rest_in_odd*num2_all_2018; cout\u003c\u003cans\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/k-2018/:5:0","tags":["2018湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"B. Higher h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has no papers and he is going to publish some subsequently. If he works on a paper for x hours, the paper will get (a·x) citations, where a is a known constant. It’s clear that x should be a positive integer. There is also a trick – one can cite his own papers published earlier. Given Bobo has n working hours, ﬁnd the maximum h-index of him. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:0","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Input The input consists of several test cases and is terminated by end-of-ﬁle. Each test case contains two integers n and a. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:1","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Output For each test case, print an integer which denotes the maximum h-index. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:2","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Constraint • 1≤ n ≤109 • 0≤ a ≤ n • The number of test cases does not exceed 104. ","date":"2018-06-14","objectID":"/posts/b-higher/:1:3","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Sample Input 3 0 3 1 1000000000 1000000000 ","date":"2018-06-14","objectID":"/posts/b-higher/:1:4","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Sample Output 1 2 1000000000 ","date":"2018-06-14","objectID":"/posts/b-higher/:1:5","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"Note For the ﬁrst sample, Bobo can work 3 papers for 1 hour each. With the trick mentioned, he will get papers with citations 2,1,0. Thus, his h-index is 1. For the second sample, Bobo can work 2 papers for 1 and 2 hours respectively. He will get papers with citations 1+1,2+0. Thus, his h-index is 2. 题意：给定n个小时，可以用其中x(1\u003c=x\u003c=n)个小时写一篇论文，那么这篇论文的\"既定\"引用数将会是x*a(a为给定正整数)；此外，已经写好的论文将会被其后写成的论文所引用，也就是说，这篇论文的总引用数将会是\"既定\"引用数+其后论文篇数；问在所有的写论文方案中(例如一种方案就是用n个小时写n篇论文，每篇论文各花1小时(可以得到这n篇论文的引用数))，h最大为多少(h的含义同上题)(每一种方案都对应着一个h，求这些h中的最大者) 思路：最优方案(即对应h值最大的方案)是平摊n小时写成n篇论文(证明未知)；此时n篇论文的引用数为a,a+1,a+2,…,a+n-1，引用数为a+i时，引用数大于等于它的论文有n-i篇，令a+i=n-i得i=(n-a)/2,所以h=a+(n-a)/2; 后AC代码 #include\u003ccstdio\u003e int main(){ int n,a; while(scanf(\"%d%d\",\u0026n,\u0026a)!=EOF){ printf(\"%d\\n\",a+(n-a)/2); } return 0; } ","date":"2018-06-14","objectID":"/posts/b-higher/:1:6","tags":["ACM","2018湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"A. Easy h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has published many papers. Given a0,a1,a2,…,an which means Bobo has published ai papers with itations exactly i, ﬁnd the h-index of Bobo. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:0","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Input The input consists of several test cases and is terminated by end-of-ﬁle. The ﬁrst line of each test case contains an integer n. The second line contains (n+1) integers a0,a1,…,an. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:1","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Output For each test case, print an integer which denotes the result. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:2","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Constraint • 1≤ n ≤2·105 • 0≤ ai ≤109 • The sum of n does not exceed 250,000. ","date":"2018-06-14","objectID":"/posts/a-easy/:1:3","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Sample Input 1 1 2 2 1 2 3 3 0 0 0 0 ","date":"2018-06-14","objectID":"/posts/a-easy/:1:4","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"Sample Output 1 2 0 题意：给定被引用次数为0~n的论文分别有几张，找到最大的h，满足被引用次数大于等于h的论文至少有h张 思路：在区间[0,n]内二分答案；或直接从n~0遍历找到第一个满足条件的h 后AC代码 #include \"bits/stdc++.h\"using namespace std; int main(){ int a[200005]; int n; int i; while(cin\u003e\u003en){ for(i=0;i\u003c=n;i++) cin\u003e\u003ea[i]; int sum=a[n]; for(i=n;i\u003e=0;){ if(sum\u003e=i){ cout\u003c\u003ci\u003c\u003cendl; break; } else sum+=a[--i]; } if(i\u003c0) cout\u003c\u003c\"0\"\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/a-easy/:1:5","tags":["2018湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"sort使用#include\u003calgorithm\u003e头文件， sort(开始地址，结束地址，排序方式)，其中第三参数可以没有，则默认为升序排序。 或者简单的用 less\u003c参数类型\u003e()表示升序 greater\u003c参数类型\u003e()表示降序 也可以用一个bool型函数，比如： bool cmp(int a,int b){ return a\u003eb;//表从大到小，即降序 } 假设自己定义了一个结构体node typedef struct node { int a; int b; double c; }note; 有一个node类型的数组node arr[100]，想对它进行排序：先按a值升序排列，如果a值相同，再按b值降序排列，如果b还相同，就按c降序排列。就可以写这样一个比较函数： 以下是代码片段： bool cmp(node x,node y) { if(x.a!=y.a) return x.a\u003cy.a; if(x.b!=y.b) return x.b\u003ey.b; return x.c\u003ey.c; } sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组，数组类型可以是int,char等。 实例:先降序再升序 #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; typedef struct data{ int a; double b; }date; bool cmp(date a,date b){ if(a.b!=b.b) return a.b\u003eb.b; return a.a\u003cb.a; } int main(){ date a[3]={{5,56.5},{4,56.5},{8,85}}; sort(a,a+3,cmp); for(int i=0;i\u003c3;i++) cout\u003c\u003ca[i].a\u003c\u003c\"-\"\u003c\u003ca[i].b\u003c\u003cendl; cout\u003c\u003cendl; return 0; } 传送门 ","date":"2018-06-14","objectID":"/posts/sort%E6%8E%92%E5%BA%8F/:0:0","tags":["C++","sort","STL","ACM"],"title":"sort排序","uri":"/posts/sort%E6%8E%92%E5%BA%8F/"},{"categories":["ACM"],"content":"1.swap（交换两元素值，在algorithm下，用法：swap(a,b);） 交换两元素的值在C语言课上作为指针讲解的典例。 int a=1,b=2; swap(a,b); //此时a=2,b=1 (可以是其他类型) ","date":"2018-06-14","objectID":"/posts/c-with-stl/:1:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"2.sort(,,) sort排序是不稳定的，stl中的stable_sort才是稳定的 inta[10]={1,6,2,3,5,4,3,8,9,7}; stable_sort(a,a+10,greater\u003cint\u003e()); for(int i=0;i\u003c10;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; ","date":"2018-06-14","objectID":"/posts/c-with-stl/:2:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"3.reverse（翻转序列，在algorithm下） //常用在字符串上 int a[5]={1,2,3,4,5}; reverse(a,a+5); //序列现在是 5 4 3 2 1 char s[]=“ericxie”; reverse(s,s+strlen(s)); //序列现在是 “eixcire” //同样适用于string string s=“qwer”; reverse(s.begin(),s.end()); ","date":"2018-06-14","objectID":"/posts/c-with-stl/:3:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"4.min，max（取大，取小） int a=1,b=2,c; c=min(a,b); //此时c等于1 c=max(a,b); //此时c等于2 string s=“qwer”,d=“asjk”,c; c=min(s,d); //c=“asjk” ","date":"2018-06-14","objectID":"/posts/c-with-stl/:4:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"5.__gcd（最大公约数） 手写gcd函数也行，辗转相除，辗转相减； int gcd(int a,int b){ return a%b ? b : gcd(b,a%b); } //直接用 int a=4,b=6; int c=__gcd(a,b); //注意下划线，此时c等于2 ","date":"2018-06-14","objectID":"/posts/c-with-stl/:5:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"6.lower_bound和upper_bound（二分查找） lower_bound意思就是：找到第一个位置，使得：如果在这个位置插入value后，原有序序列依旧有序。 upper_bound是找到最后一个符合数位置后一个位置，使得：如果在这个位置插入value后，原有序序列依旧有序。 //数组 int a[8]={1,2,4,4,9,12,12,15}; int pos1 = lower_bound(a,a+8,4)-a; int pos2 = upper_bound(a,a+8,4)-a-1; //在这个样例下pos1!=pos2;pos1=2;pos2=3; 根据我的理解lower_bound(a,a+8,value) 得到的是一个地址，拿这个地址减去数组首地址a[0]，那么刚好就是value应该放入的位置。 //vector vector\u003cint\u003e a; 若a中目前的元素也是{1,2,4,4,9,12,12,15}; 那么这里用lower_bound得到的应该也是一个类似于指针的东西，为什么不叫它指针呢？因为他有了一个名字，叫做迭代器。 vector\u003cint\u003e::iterator it; it = lower_bound(a.begin(),a.end(),4); //这里的it就是迭代器，那么* it就是该下标对应的value了。 //set集合 set\u003cint\u003e a; set\u003cint\u003e::iterator it; it = a.lower_bound(value); ","date":"2018-06-14","objectID":"/posts/c-with-stl/:6:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"7.next_permutation （排列） bool next_permutation( iterator start, iterator end );通常用于生成序列的全排列。用之前先保证有序； int a[]={1,2,3}; do{ for(int i=0;i\u003c3;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; cout\u003c\u003cendl; }while(next_permutation(a,a+3)); 结果为： 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 string str=\"STL\"; sort(str.begin(), str.end()); do{ cout \u003c\u003c str \u003c\u003c endl; }while (next_permutation(str.begin(),str.end()))； 结果： LST LTS SLT STL TLS TSL 大数据c比c++效率高 int length; char str[MAX]; gets(str); length = strlen(str); sort(str, str + length); do{ puts(str); }while(next_permutation(str, str+length))； ","date":"2018-06-14","objectID":"/posts/c-with-stl/:7:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["ACM"],"content":"8.unique （去重） 如何把序列 a 中的重复元素去除呢？首先需要对原序列 a 进行排序，保证有序后，调用unique(a.head , a.tail )就可以了。unique会返回一个类似指针的东西（和lower_bound有点像），-a后表示去重之后序列的长度。 下面是实例。 int a[]={1,3,5,7,9,2,2,2,1,1,1}; sort(a,a+11); int len = unique(a,a+11)-a; for(int i=0;i\u003clen;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; 输出结果为：1 2 3 5 7 9 传送门 ","date":"2018-06-14","objectID":"/posts/c-with-stl/:8:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["others"],"content":"1. \u0026运算 \u0026运算通常用于二进制取位操作，例如一个数 \u0026 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数. ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:1:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"2. |运算 |运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数| 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:2:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"3. ^运算 ^运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：异或0都不变，异或1则取反。 ^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即a ^ b ^ b = a。^运算可以用于简单的加密，比如你想对你MM说1314520，但怕别人知道，于是双方约定拿你的生日19880516作为密钥。1314520^19880516 = 20665500，你就把20665500告诉MM。MM再次计算20665500 ^ 19880516的值，得到1314520，于是她就明白了你的企图。 还可以用异或来进行快速地交换数据， a=2;b=3;//先转化成二进制 a=a^b; b=a^b; a=a^b; 操作后a=3;b=2; ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:3:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"4. ~ 运算 ~运算的定义是把内存中的0和1全部取反。使用~运算时要格外小心，你需要注意整数类型有没有符号。如果~的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000到$FFFF依次表示的。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:4:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"5. «运算 a « b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 «2 = 400。可以看出，a « b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。 通常认为a « 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。 定义一些常量可能会用到«运算。你可以方便地用1 «16 – 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用«来定义Max_N等常量。 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:5:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":"6. »运算 和«相似，a » b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们也经常用» 1来代替div 2，比如二分查找、堆的插入操作等等。想办法用»代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60% 传送门 原文:http://www.matrix67.com/blog/archives/263 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:6:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["others"],"content":" 本文来自kio对Markdown的基础教程 其他推荐参考：https://segmentfault.com/markdown Markdown主张使用最简单的符号来控制格式，兼顾易读易写特性，让你可以专注在文本创作上。 这篇文章旨在让你通过大约三分钟来快速掌握Markdown的基本用法。 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:0:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"在开始之前，需要特别注意的点 通常，格式控制符号与文本内容需要保留一个空格 段落之间需要空格一行 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:1:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"标题 在书写中，标题是最常用的格式，Markdown中，通过在文本前加上 # 即可，同时，根据#的数量可以可以划分为二级标题、三级标题、四级标题…一共六级。 一级标题 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:2:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"二级标题 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:3:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"三级标题 四级标题 五级标题 六级标题 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:3:1","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"列表 列表分为无序列表和有序列表，无序列表在文本前面加上 - 即可： 无序列表一 无序列表二 无序列表三 而有序列表仅需要在文本前面加上 1. 即可： 1. 有序列表一 2. 有序列表二 3. 有序列表三 有序列表一 有序列表二 有序列表三 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:4:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"引用 文本经常需要引入一些内容，包括他人的话等等。仅需要在文本前面加上 \u003e 即可： Kio•纯粹写字 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:5:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"文字修饰 为了表达的抑扬顿挫，需要使用到粗体、斜体、删减体等来表明重点，其中用一个 * 号包围起来的文字为斜体，用 ** 包围起来的文字为粗体，而使用 ~~ 包围起来的文字为删减体： 斜体 粗体 删减体 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:6:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"段落分隔符 通过 --- 即可以添加段落分割线： ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:7:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"链接及图片 另外一篇博文 链接和图片可以为文章润色不少，通过 [描述](地址)既可以添加链接，而在其前面添加一个 ! 号即为添加图片， 具体为: [百度](https://www.baidu.com) ![Kio Logo](http://oss.blurme.idik.net/artemis/image/logo.png) ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:8:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"表格 |英文|解释|备注| |:-:|:--|--:| |Book|书| | |Hello|你好| | |World|世界|world| 英文 解释 备注 Book 书 Hello 你好 World 世界 world 这样即可自动生成表格，第二行为内容对准格式，第一格表示内容居中，第二格表示居左，第三格表示居右。 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:9:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"插入高亮代码 如果你需要插入一些代码，Markdown也可以帮你自动高亮，包括行内高亮和代码块高亮，行内高亮仅需要使用 内容 包围起来即可。 代码块高亮 至此，写作中需要用到的控制符已经介绍完毕了，Kio提供的所见即所得Markdown支持和便捷的输入辅助能帮助你快速掌握这一密术 :] ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:10:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":"移动端写作工具 Kio：密码99o4可以导出PDF，md文件 markdownx：密码a5n4 SM.MS图床：密码ch0v 若链接失效还可以去酷安上下载。 ","date":"2018-06-10","objectID":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:11:0","tags":["Markdown"],"title":"Markdown基础教程","uri":"/posts/markdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["others"],"content":" 2021/10/1 更新 使用 Chrome 等浏览器管理书签是更好更方便的方式，登陆 google 账号，或者导出 html 书签文件都挺方便。 我们在平时学习生活总会遇到很多很多有用的网站，也许我们收藏在了浏览器书签里，可过久了，不做说明，这些链接的价值就被时间淹没了，我们自己都记不起来了，所以这篇文章因此而生。对自己收藏的链接做些简单的说明(第一次编写用了我一个下午)；也相当于我的链接收藏夹，分享一些有趣的网站， ACM相关 链接 描述 各大OJ题目分类 各种算法分类，对应OJ题号超链接 ACM题目分类 codeforces 俄国CF在线编程，一般比赛在晚上9:30和11：00 牛客网 国内求职学习网，有很多程序设计比赛 vjudge 这个不用说了吧 hihocoder 打得少，感觉好多数据结构的题 百练 OpenJudge的一个小组，很多题目来自POJ；也是我ACM启蒙地 HDUOJ 杭州电子科技大学OJ POJ 北京大学OJ 洛谷 lintcode 领扣（国外） leedcode 力扣 codewar 国外 更多OJ，在线刷题网站… 编程,学习 链接 描述 visualgo 算法学习，数据结构和算法动态可视化 c,c++学习 很详细的知识讲解 Tomcat下载 Tomcat各版本下载，Tomcat解压即安装；\\bin下可以启动和关闭服务器；可手动在\\webapps里创建web应用，也可以配合Eclisp IDE for Java EE Developers等Java IDE工具创建 w3school 可在线测试,Web技术教程,HTML,浏览器脚本,服务器脚本,xml教程等 w3cschool 和上面不同哦，是不是和上面的很像哈哈哈！我估计是上一个网站的新版，功能更强大，内容更丰富，还有微信小程序教程等 菜鸟教程 和上面两个差不多，还有一些数据库、安卓的东西，git学习 python学习 Python库安装包下载,python,Django,HTML,ACM学习 python123 Python123 是专注于为中国高等院校教学 Python 语言的而开发的一款学习工具网站python学习 pypi Find, install and publish Python packages with the Python Package Index 优矿 python在线测试，笔记 阮一峰的网络日志 开发者手册，JavaScript等等 廖雪峰 git,python,javascript学习 新晴网 PS学习，摄影教程等 实验楼 在线做实验,高效学编程 慕课网 在线学习，免费，付费视频 wxpy 一个python关于微信的库 So1n python学习 云服务及站长工具 链接 描述 腾讯云 dnspod解析新版入口，腾讯云控制台 dnspod解析 域名解析，其他：阿里云等 cloudflare解析 域名解析，https解析，介绍 cloud studio 这是腾讯云和coding合作后的一个东西，简单来说就是云端开发环境。试了一下完全可以把hexo博客源码挂上面编辑。这也就不用只局限于一台电脑发布博客了。 腾讯云大学开放实验室 可以在线进行一些云服务应用搭建等的实验。与之对应的还有阿里云开放实验室 宝塔面板 宝塔面板是一款使用方便、功能强大且终身免费的服务器管理软件，支持Linux与Windows系统。一键配置：LAMP/LNMP、网站、数据库、FTP、SSL，通过Web端轻松管理服务器。 leancloud 一站式后端云服务 daovoice 网站在线客服 百度网站收录 网站seo Bing 站长 Bing 网站管理员工具 站长工具 网站信息查询，权重，seo，网站速度查询，ping等 站长工具大全 各种seo优化，工具等 前端工具 链接 描述 全栈开发者 顾名思义，有很多web开发的教程，也可以在线执行代码 JSFuck JSFuck是一种基于JavaScript原子部分的深奥教育编程风格。它只使用六个不同的字符来编写和执行代码。(代码极丑化) BootCDN 稳定、快速、免费的前端开源项目CDN加速服务，共收录了 3441 个前端开源项目。比如vue,fancybox等 bootstrap中文网 简洁、直观、强悍的前端开发框架，让web开发更迅速、简单。还有一些基于bootstrap开发或扩充的项目的cdn，BootCDN也是在该网站旗下 Font Awesome图标库 hexo指定图标库 iconfont 阿里巴巴矢量图标库 easyicon图标库 图标下载，格式转换，可外链 semantic-ui.com图标库 semantic-ui.com还有很多前端样式对应代码 colorhunt 配色方案推荐，调试 grabient渐变色 渐变色调色 gradient渐变色调色 渐变色调色，获取代码 encycolorpedia encycolorpedia取色器 优酷视频上传 获取视频外链，其他：腾讯视频 sm.ms 非常好用的图床 imgURL 一个开源的图床，很不错，有兴趣的可以自己尝试搭建,比如img.lruihao.cn 现实君外链 支持多种文件外链，唯一不好的是http PEXELS美图 文章配图，无版权美图网，避免配图侵权 unsplash美图 API还可以获取随机图 图标工厂 移动应用图标生成工具，一键生成所有尺寸的应用图标 emoji在线复制 Simple emoji copy and paste HTML字符实体 网页特殊符号大全 特效字转换工具集 各种特效字转换工具,彩虹字生成器,RGB转16进制颜色等 压缩图 在线ps，图片去底，证件照换底等操作很方便的web图片处理工具 改图宝 在线改图压缩，加水印，生成二维码，印章制作等 GIF之家 一个压缩效果很好且免费的gif压缩工具 二维码解码器 草料二维码 https://cli.im 联图二维码 第九工厂 死磕艺术二维码 模板码 动态二维码等 实用工具 链接 描述 Gearn Git Branching 通过游戏闯关的方式学习git！ PicGo 一个很好的开源的图床管理桌面程序，图床神器支持微博图床、七牛图床、腾讯云COS、又拍云、GitHub图床、阿里云OSS、Imgur图床等等 Proxyee Down 百度云下载解决方案，满速下载，但不限于百度云的下载，感觉比迅雷还好用！ PanDownload 这是pandownload网页版，把需要下载的百度网盘链接baidu改成baiduwp即可加速，也有桌面版。 ubuntu pastebin 代码展示托管，生成分享网址，防止代码直接分享缩进消失 图片转字符工具 Img–\u003eString everyfont 中文字库在线压缩 字蛛 font-spider中文字库压缩 mdtr2pdf markdown转pdf AD’s API 包括动态签名，网易音乐等 在线工具 w3cschool的在线工具集合 在线工具 开源中国社区 菜鸟工具 菜鸟教程在线工具，编译，加密，压缩代码等 msdn windows系统上office等软件下载(备用) 老殁科技 Adobe等各种绿色破解软件 百度接口 百度搜索关键词接口 在线短信 不想泄露个人的电话号码，注册一些一次性网站可以用到 配音阁 文字转换语音/语音合成广告_叫卖录音_在线配音网络软件_促销宣传片配音-配音阁-配音阁,国内专业的广告配音平台 hacknical 在线个性简历，个人Github总结分析 其他 链接 描述 俄罗斯方块 这是一个开源的游戏，小白的我看来简直牛逼爆了，好逼真，刷新都不会打断游戏进度！！ 网址迷宫nazo_game 一个程序员的网页游戏，我只玩到12关。。。 无损音乐下载 手写体制作 北京大学计算机科学技术研究所的一个项目59.108.48.27 （我的字体至今还未完成） 大象代理 收费，口碑不错 蒲公英 应用内测发布平台 博客文章 文章 概括 Web笔记 记录一下自己web相关学习的笔记 Git常用指令汇总 可能用到按需自查 hexo 插件及 next 内置样式集 让文章写的好看又简洁又好用的插件！hexo更多请看分类 hexo-theme-next @modified LRH 对next主题的DIY设计记录日志 一款自己写的字体 - 沐目体 沐目体–release ","date":"2018-06-07","objectID":"/posts/links/:0:0","tags":["总结","ACM"],"title":"各种Links汇总与分享","uri":"/posts/links/"},{"categories":["生活随笔"],"content":"从此故乡只有冬夏，再无春秋。","date":"2018-06-03","objectID":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/","tags":["生活随笔"],"title":"戏子春秋","uri":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/"},{"categories":["生活随笔"],"content":" 从此故乡只有冬夏，再无春秋。  时间急促得仿佛还在昨天，还没有清楚地认识到这句话的其中含义时，我早已离开它，远去。 　自此，一江绿水东去，桃花竞开，春洒满园；瑟瑟秋风里，稻谷黄时，落木萧萧；故乡的春秋成为回忆尘封在我的脑海深处。 　三月，这里和故乡一样雨下得缠绵，却尽带着他乡的味道。在不是滋润自己的那方水土上，哪怕是喜雨之人，亦只有料峭的寒意。雨下到这里才懂得，为何古来才子佳人逢阴雨连绵天总是带着一股莫名的惆怅。原是这般由头！我与他们，并无二般，想起故乡来。 　故乡的春是在牛耕上的。太爷说，老牛伏在岸边饮水时节就是春耕了。到那时，耕牛头角披红挂彩，鼻挂铜色大铃，以祈愿今年平安，田地丰收；当耕牛喘着鼻息，缓缓地哞哞叫着走下田，是其在田地里大展身手的机会。故而，二月春耕总是会见到红布条装扮的水牛在田间劳作，彩带飘逸，好生招摇，尤其是农夫哼起那极具故乡气息的耕牛民歌，如高山流水般，伴着清脆的铜铃声隐隐飘去……在春末，三月桃花尽开，漫山望去，粉红红一片，甚是好看。小时看到总以为身处仙山，而后来，陶渊明一篇《桃花源记》就以为自己是那秦时避乱而住在桃花源中的后人。每每与外人谈起家乡的桃花山时，必然是一副神气十足的傲气样子。我想，这也是自己不知不觉中受家人影响，又倾心桃花的缘故吧。 　印象中，家里人都爱这漫山遍野的桃花。太爷爱赏花，山上桃花开得极好的时候，便移栽了数株桃花留在了院子里，天好天坏，都能观赏上好一会儿。太婆还在的时候，桃花次第开，她就会拾掇许多桃花下来做成桃花糕，那桃花糕香香糯糯的味道飘散四周，总能把我馋来。后来，太婆故去，奶奶学着太婆开始做起了桃花糕，却总是没有太婆做的如意。但奶奶的桃花酒，受到父辈们的一致好评。每当酒坛从土里挖出，揭开红布，酒气便带着桃花的香甜扑鼻而来。父辈们在太爷种的桃花树下把酒话桑麻，颇有一副桃花坞里桃花庵，桃花庵里桃花仙的样子。现如今记忆远去，酒香却长留下来，记起时，那酒酣甜得喜人。 　故乡的秋从九月农收渐起，那时候一家老小在浓浓的秋意里忙忙碌碌，直至十月方才得些许闲暇日子。 　稻谷黄时，是秋最盛的时候。父辈们清晨便出发去地里收稻谷。晌午，我兴起与祖母前去送饭。正午的太阳烈得很，父辈们大颗大颗的汗直往下掉，稻谷机嘈杂得很。这才想起太爷教我的诗，“妇姑荷箪食，童稚携壶浆”，就是这样的情景无差。那时候不懂得父辈的辛苦，只知奔入山间，捕捉蚱蜢，蛐蛐等趣物。等傍晚将近，坐在板车谷袋上，兴尽而回，一天就算结束。渐渐长大，再也不敢胡闹，不知是童趣少了还是知了人事愈发迷惘了？ 　窗外又下起雨，心里竟也惆怅起来。并非是洗过的衣服久晾未干，而是伴着那股湿意而来，藏在雨里的那点点乡愁。这边的桃花也开得好，往窗外，密密一片，不免想起了太爷书房里的书画：花是春时花，却非故乡花。人是故乡人，却是他乡客。所见时，不过是从戏子变成看客了罢。 ","date":"2018-06-03","objectID":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/:0:0","tags":["生活随笔"],"title":"戏子春秋","uri":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/"},{"categories":["hexo"],"content":"更多关于hexo 首先 官方文档是我们的第一手资料，也是最好的。 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git hexo安装 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 npm install -g hexo-cli 建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 hexo init \u003cfolder\u003e cd \u003cfolder\u003e npm install 为一个文件夹的名字 新建完成后，指定文件夹的目录如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 安装hexo插件 全装上吧，没事。。。 npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked@0.2 --save npm install hexo-renderer-stylus@0.2 --save npm install hexo-generator-feed@1 --save npm install hexo-generator-sitemap@1 --save 本地查看效果 执行下面语句，执行完再登录localhost:4000查看效果（执行完不要按Ctrl+C，不然就停止了） hexo g hexo s 其他步骤在这里不赘述，参见超详细教程 安卓上搭建hexo博客 部署 hexo g -d 部署后我们可以浏览器搜 username.github.io 查看自己的博客效果，，比如我的lruihao.github.io 美化 这些美化都写的很详细，我建议你们自己好好看看吧，我也是在这里看到的，如果问我和这里说的是一样的。 hexo个性化教程 valine特别鸣谢赵俊👍 asdfv1929 hexo官方主题集合，我用的是aloha主题，该主题官方文档，后改用next主题next主题 hexo官方插件 说说我的主题遇到的一些问题，由于这个主题用的人少，所以作者优化的不是很好（next使用最多），当然也可以反过来说，所以自己美化了一点 ","date":"2018-06-01","objectID":"/posts/hexobuild/:0:0","tags":["hexo","Nodejs","Frontend"],"title":"hexo+github搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["hexo"],"content":"博文置顶 修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 'use strict'; var pagination = require('hexo-pagination'); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top \u0026\u0026 b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top \u0026\u0026 !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.top \u0026\u0026 b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } }); }; ","date":"2018-06-01","objectID":"/posts/hexobuild/:1:0","tags":["hexo","Nodejs","Frontend"],"title":"hexo+github搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["hexo"],"content":"about页面 about页面可以用HTML写，你想怎么写都行，我用的最简单的方法，直接hexo n page \"about\"后，会生成一个md文件，也就是后面说的文章，直接写文章就行了。 ","date":"2018-06-01","objectID":"/posts/hexobuild/:2:0","tags":["hexo","Nodejs","Frontend"],"title":"hexo+github搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["hexo"],"content":"添加搜索，评论，分享 搜索功能真心好用，当文章多起来的时候，标签提供的作用已经很少了，只能简单索引，搜索却能精确查找，这里我用的依旧是最简单的本地站内搜索。 安装hexo-generator-searchdb 在站点的根目录下执行以下命令： npm install hexo-generator-searchdb --save 配置站点配置文件 新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 配置主题配置文件 # Local search local_search: enable: true algolia参考文件 让搜索引擎找到你的博客，还是看到邱承佳学长博文有写到传送门 ","date":"2018-06-01","objectID":"/posts/hexobuild/:3:0","tags":["hexo","Nodejs","Frontend"],"title":"hexo+github搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["hexo"],"content":"添加访客数，阅读量等 评论有多说（多说好像挂了），计数有不蒜，我用的不蒜子，还有其他的。。。 ","date":"2018-06-01","objectID":"/posts/hexobuild/:4:0","tags":["hexo","Nodejs","Frontend"],"title":"hexo+github搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["hexo"],"content":"文章阅读量 以下适合非next主题的部分主题，next 主题已经自带，到主题配置文件修改就好了。 打开以下路径在你喜欢的地方添加代码，\\blog\\hexo\\themes\\主题名字\\layout\\_partial，找到 article.ejs文件 \u003cdiv align=\"left\"\u003e\u003cspan id=\"busuanzi_container_page_pv\"\u003e 本文总阅读量\u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e次 \u003c/span\u003e \u003c/div\u003e ","date":"2018-06-01","objectID":"/posts/hexobuild/:4:1","tags":["hexo","Nodejs","Frontend"],"title":"hexo+github搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["hexo"],"content":"站点访问量，访客数 打开以下路径在你喜欢的地方添加代码，\\blog\\hexo\\themes\\主题名字\\layout\\_partial，找到 footer.ejs文件 \u003cscript async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e \u003c/script\u003e \u003cspan id=\"busuanzi_container_page_pv\"\u003e 本站总访问量\u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e次 | \u003c/span\u003e \u003cspan id=\"busuanzi_container_site_uv\"\u003e 本站访客数\u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e人次 \u003c/span\u003e 2018.10.08更新 不蒜子官网说七牛强制过期域名dn-lbstatics.qbox.me,所以js文件位置发生改变，改为busuanzi.ibruce.info 写文章 hexo文章用轻量型标签语言Markdown编写 markdown入门 繁体原始文件 繁体原始文件github ","date":"2018-06-01","objectID":"/posts/hexobuild/:4:2","tags":["hexo","Nodejs","Frontend"],"title":"hexo+github搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["hexo"],"content":" 如果实在搞得头晕直接去简书写文章，再把简书生成的md文章复制过来就好了（简书是个不错的Markdown在线编辑器），还可以去马克飞象，专为印象笔记打造的 Markdown 编辑器，typora 也是不错的，突然发现csdn也支持Markdown编译器了 1.首先 刚刚搭博客，很多都不懂，就连插入图片的路径问题都把我整的要命。。。（我用的Sublime Text 3编译器） 下面讲讲： ","date":"2018-05-31","objectID":"/posts/hexowrite/:0:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["hexo"],"content":"1.1 设置站点配置_config.yml post_asset_folder: true ","date":"2018-05-31","objectID":"/posts/hexowrite/:1:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["hexo"],"content":"1.2 安装插件 npm install https://github.com/CodeFalling/hexo-asset-image -- save ","date":"2018-05-31","objectID":"/posts/hexowrite/:2:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["hexo"],"content":"1.3 下次再运行hexo n “xxxx\"来生成md博文时，下路径 /source/_posts 文件夹内除了xxxx.md文件还有一个同名的文件夹，在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片。 2.添加图片 首先大家可以查看hexo官方文档资源文件夹章节 ","date":"2018-05-31","objectID":"/posts/hexowrite/:3:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["hexo"],"content":"2.1 markdown添加 相对路径添加（我被这个相对路径搞得要死，前面各种出错，大家可以对照我的来插入图片…） #直接写图片名就好了，图片实例见下 ![kyrie irving](294136.jpg) #如果改了Permalink就要加上文章名，即同名文件夹名 ![kyrie irving](hexo-添加图片，音乐，链接，视频/294136.jpg) #代码压缩后前面还要加一个/ ![kyrie irving](/hexo-添加图片，音乐，链接，视频/294136.jpg) ","date":"2018-05-31","objectID":"/posts/hexowrite/:4:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["hexo"],"content":"2.2 插件添加 传送门 这种方式被很多人诟病，但有时候也不失一种好方式，简单快捷。 还有图片名字显示，不错的。 {% asset_img 297787.jpg kyrie irving %} 3.音乐 大家可以看网易云音乐的官网，播放音乐可以生成外链，直接拿来用就行了。iframe插件可以在代码中设置宽高等参数，auto为自动播放。flash不可以自己设置参数。看喜好，随便你。 其他音乐，把插件中的链接替换成要播放的链接就可以了 #iframe插件 \u003ciframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2\u0026id=66651\u0026auto=0\u0026height=66\"\u003e \u003c/iframe\u003e #flash插件 \u003cembed src=\"//music.163.com/style/swf/widget.swf?sid=40249713\u0026type=2\u0026auto=0\u0026width=320\u0026height=66\" width=\"340\" height=\"86\" allowNetworking=\"all\"\u003e \u003c/embed\u003e 4.添加链接 [我的微博](https://weibo.com/liahao) {% link text url title %} 5.添加视频 视频链接最好是打开就是视频的链接（youku，YouTube，抖音等） 可以把视频上传到优酷，抖音等生成外链再拿来用。（优酷上传需要注册和实名认证） 插件参考资料 自拍手写视频（优酷） 实验室无聊拍的 \u003ciframe height=500 width=100% src=\"https://player.youku.com/embed/XMzY0MzgxNDMyOA==\" frameborder=0 allowfullscreen\u003e \u003c/iframe\u003e 工具集合 Picgo 马克飞象、CSDN、简书 SM.MS图床 ","date":"2018-05-31","objectID":"/posts/hexowrite/:5:0","tags":["hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["生活随笔"],"content":"一直觉得中国古代神话 能称得上传奇的只有两个人物： 一是猴子 一是哪吒 百世蕴灵育出只石猴 大闹天宫腾云驾雾 三年怀胎生了个哪吒 东海屠龙翻江倒海 可以说 除了这两人 没人再能当得起离经放纵四个字的 但称得上悲剧的 约摸也只有这两个 一个五行山下压五百年 揭了封印 戴上金箍无悲无喜 拜佛西天 唤孙悟空 一个削肉还母剔骨还父 塑了莲身 站上火轮无怨无恨 封神南门 号三太子 这尘世最擅长的事 大抵就是抹杀疏狂者的落拓 磨平豪纵者的傲骨 斩灭叛世者的孤妄 ","date":"2018-05-31","objectID":"/posts/%E7%8C%B4%E5%AD%90%E4%B8%8E%E5%93%AA%E5%90%92/:0:0","tags":["生活随笔"],"title":"猴子与哪吒","uri":"/posts/%E7%8C%B4%E5%AD%90%E4%B8%8E%E5%93%AA%E5%90%92/"},{"categories":["生活随笔"],"content":" “每天早晨叫醒你的不是鬧鐘，而是你的夢想。” Loading... 我有過靠著這種信念撐下來的日子，我見過自己努力的樣子，至於現在的自己配不配得上當初努力的自己， 其實也不重要了，還望披荊斬棘，不改初心。 不怕萬人阻擋，只怕自己投降。你如何回憶，決定你是一個怎樣的人！ 從大一伊始，打 ACM 比賽，訓練刷題，再到毅然決然離開實驗室，選擇陌生的 Web 開發，從工作前的一無所知到，到前端開發，後端開發，到教實習生，到面試新人，到開始乏味。這一路走來，好奇心，探索欲，瞎擇騰，或許還有愛意，都是支撐我的動力。 時間並不會因為你的迷茫和遲疑而停留，就像你在看到這篇博客的時候，不知道有多少人正風雨兼程趕赴夢想。沒有誰生來就是神牛，千裏之行，始於足下！比自己優秀的人有很多，永遠不要感動自己，保持謙遜，沉澱自己，感謝每一個曾經努力的自己。不必執著於過去，也不必過度擔憂未來，望披荊斬棘，不忘初心。 最開始寫博客，是在打 ACM 的時候，深受一個學長的博客影響，他的博客是 hexo 搭建的，ID 是 [戎碼一生]，所以我也照葫蘆畫瓢用 hexo 搭建了一個，一用就是 3 年，博客名字原 “博採眾長” 改为 “菠菜眾長”，因為不能用成語作為網站名字，就這個原因。 直到 21 年下半年，升級 windows 11, 系統出了 BUG, 整理磁盤不小心把代碼刪掉了，就乾脆換成 hugo 了。 逝者如斯乎，不舍昼夜現在並沒有刀槍入庫，馬放南山，衹是在奔赴另一片山海 \" 逝者如斯乎，不舍昼夜 ","date":"2018-05-28","objectID":"/posts/hello-world/:0:0","tags":["生活随笔"],"title":"Hello World","uri":"/posts/hello-world/"}]