<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[还乡]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2Frenative.html</url>
    <content type="text"><![CDATA[这不是英国作家哈代的《The Return of Native》,而是我们这辈的父母所经历的常态。以下文章由好友杨灿所写逢近年关，邻居家的王婶又在等她的儿子了。她的儿子大抵有五年未曾回家了。记得去年，他同王婶说好了回家过年，王婶便从腊月二十直直地等到腊月三十，准备好一桌的年夜饭，最后却只是她一个人随便地扒拉了几口。我尚且还记得那日，王婶与我母亲一同去河边处理鸡鸭，我也随了去。母亲同王婶说：“源子怎地还不回来？”王婶道：“许是买的车票晚了些，他早前和我说回家过年的，想来还在回来的路上。”到晚上，万家灯火渐起，都说热热闹闹团圆饭，王婶家却格外冷清。王婶嫁过来时，家中便只有王叔一人，早些年，王叔随人去炸山取石，人也不幸被石头砸死，家中便只有王婶和她儿子二人。王源也知家中境况，自大学毕业后在外工作，至今，除了前年我暑假时回来过一次，其中便从未回来过。人倒是挺奋进，这些年，王婶家从小木屋变成了三层小洋房，家里也添置了许多家具和电器。王婶倒像一个门卫，守着这栋房子，看着这个家。不过别家事总归别家事。王婶是个十分随和的人，也常常和村里人打趣逗乐，常见她笑眼眯眯。一年到头，也唯有这“头”让她难展笑颜。“王婶子，源哥还没回来吗？”“快了，快了……”王婶又坐在门口，纳着新鞋，常常一纳就是一天。我们常听到一个词——衣锦还乡，其实，于父母而言，他们所看重的从来都只是还乡。而所谓衣锦，不过是死要面子者拿来的托辞。衣锦若无，无便无罢，衣锦若有，有便有罢。衣锦随意，还乡就好。戊戌年腊月廿七于家中。]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>他山之石</tag>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java继承test]]></title>
    <url>%2Fjava%2Fjicheng.html</url>
    <content type="text"><![CDATA[继承的好处：提高了代码的复用性提高了代码的维护性让类与类之间产生了关系，是多态的前提继承的弊端：类的耦合性很强设计原则：低耦合，高内聚。耦合：类与类的关系。内聚：自己完成事情的能力。java中的继承特点Java只支持单继承，不支持多继承。Java支持多层继承(继承体系)123456789101112131415161718class A &#123;&#125;class B extends A &#123;&#125;/*class C extends A,B &#123;&#125;*/class C extends B &#123;&#125;class ExtendsDemo &#123; public static void main(String[] args) &#123; &#125;&#125;java中的继承注意事项子类只能继承父类所有非私有的成员(成员方法和成员变量)子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法。不要为了部分功能而去继承那么，我们什么时候考虑使用继承呢?继承中类之间体现的是：”is a”的关系。如果两个类满足这个关系：xxx is a yyy，那么他们就可以使用继承。123Student,Person 对Dog,Animal 对Dog,Pig 错继承继承间的构造方法关系: 创建子类对象，会先去访问父类的构造方法。对父类的数据进行初始化。123456789101112131415161718192021222324252627package jicheng;class Fu&#123; public int num = 10; public Fu()&#123; System.out.println("父类"); &#125;&#125;class Zi extends Fu&#123; public int num = 20; public Zi()&#123; System.out.println("子类"); &#125; public void show()&#123; int num = 30; System.out.println(num);//30 System.out.println(this.num);//20 System.out.println(super.num);//10 &#125;&#125;public class test &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); &#125;&#125;程序运行结果12345父类子类302010代码块代码块的执行顺序： 静态代码块 –&gt; 构造代码块 –&gt; 构造方法代码的执行特点: 静态代码块只执行一次，构造代码块每次调用构造方法都执行。12345678910111213141516171819202122232425262728293031323334353637package jicheng;class Fu &#123; static &#123; System.out.println("父类静态代码块"); &#125; &#123; System.out.println("父类构造代码块"); &#125; public Fu() &#123; System.out.println("父类构造方法"); &#125;&#125;class Zi extends Fu &#123; static &#123; System.out.println("子类静态代码块"); &#125; &#123; System.out.println("子类构造代码块"); &#125; public Zi() &#123; System.out.println("子类构造方法"); &#125;&#125;public class test &#123; public static void main(String[] args) &#123; Zi z = new Zi(); Zi z2 = new Zi(); &#125;&#125;程序运行结果：12345678910父类静态代码块子类静态代码块父类构造代码块父类构造方法子类构造代码块子类构造方法父类构造代码块父类构造方法子类构造代码块子类构造方法继承间的成员关系成员方法不同名称： 非常简单，一看就知道调用谁相同名称： 先在子类找，再在父类找…找不到就报错。成员变量：名字不同： 非常的简单，一看就知道使用的是谁。名字相同： 就近原则。使用变量的时候，会先找局部范围。如果想直接使用成员变量，加关键字：this即可。如果想直接使用父类的成员变量，加关键字：super即可。注意事项子类中所有的构造方法默认都会访问父类中空参数的构造方法。为什么呢?因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用腾讯云对象存储COS桶托管hexo博客]]></title>
    <url>%2Fhexo%2Fcos-hexo.html</url>
    <content type="text"><![CDATA[本以为coding pages与腾讯云合作后会更好，没想到正是这种初期bug不断，速度也是非常慢。比gitee,甚至github都要慢很多了。所以决定放弃coding了，本想挂到云服务器上，但是这个云服务器只续费了半年，可能不会再续费，前几天看到用腾讯云的cos桶xml制作动态相册的文章，知道了对象存储这个玩意，腾讯云COS提供免费50G的存储空间，还有CDN加速服务，我觉得是个不错的选择，部署后发现速度还挺好。创建存储桶打开腾讯云控制台–云产品–存储–对象存储，然后创建存储桶。开启静态网站设置在基础配置打开静态网站(关掉强制https)绑定域名SSL设置域名解析，添加记录去dns服务商添加域名解析记录CNAME指向上面的域名hexo设置安装插件1npm install hexo-deployer-cos --save站点配置文件1234567deploy: type: cos bucket: yourBucketName #cos桶名称 appId: yourAppId #cos桶名称后数字 secretId: yourSecretId #云API密钥 secretKey: yourSecretKey #云API密钥 region: yourRegion #所属地域发布还是一样的12hexo cleanhexo g -d结果类似于CDN刷新每次更新博客内容完后，都要登陆腾讯云CDN–缓存刷新，手动刷新一下CDN。用脚本在每次更新后刷新安装1npm install qcloud-cdn-node-sdk --save创建qcloudcdn.js放入script文件夹123456789101112const qcloudSDK = require(&apos;qcloud-cdn-node-sdk&apos;);qcloudSDK.config(&#123; secretId: &apos;你的ID&apos;, secretKey: &apos;你的密钥&apos;&#125;)qcloudSDK.request(&apos;RefreshCdnDir&apos;, &#123; &apos;dirs.1&apos;: &apos;http://博客地址&apos; &#125;, (res) =&gt; &#123; console.log(res)&#125;)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>腾讯云cos桶</tag>
        <tag>对象存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arrays类及基本使用]]></title>
    <url>%2Fjava%2FArrays.html</url>
    <content type="text"><![CDATA[主要方法static type[] copyof(type[] original,int length)static int binarysearch(type[] a,type key)static boolean equals(type[] a,type[] b)static void fill(type[] a,type val)static void fill(type[] a,int fromindex,int toindex,type val)static void sort(type[] a)实例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package Arrays;import java.text.Collator;import java.util.Arrays;import java.util.Comparator;public class ArraysDemo &#123; public static void main(String agrs[]) &#123; Integer arr[]=new Integer[9]; for(int i=0;i&lt;9;i++) arr[i]=(int)(Math.random()*100); //显示，排序数组 System.out.print("原内容："); display(arr); Arrays.sort(arr); System.out.print("排序后："); display(arr); //将值-1分配给数组arr中下标从0到3-1的位置 Arrays.fill(arr, 0,3,-1); System.out.print("fill()后："); display(arr); //搜索23 System.out.print("值23的位置："); int index =Arrays.binarySearch(arr, 23);//二分查找 System.out.print(index);//如果查找不到，index为负 System.out.print("\n插入0在3号位置："); Arrays.fill(arr,3,4,0); display(arr); System.out.print("值0的位置："); index =Arrays.binarySearch(arr, 0); System.out.print(index); Integer arr2[]=new Integer[8]; arr2=Arrays.copyOf(arr, arr2.length); //复制8个 System.out.print("\n复制后的数组："); display(arr2); if(Arrays.equals(arr, arr2)) System.out.println("两数组相同！"); else System.out.println("两数组不相同！"); System.out.println("----------------------------------------"); String[] str = &#123;"计算机","黄桑","通信","李瑞豪"&#125;; Arrays.sort(str); for(int i=0;i&lt;str.length;i++) System.out.print(str[i]+" "); System.out.println(""); //Collator类是用来执行分语言环境的字符串比较，这里用的CHINA Comparator com=Collator.getInstance(java.util.Locale.CHINA);//获取Comparator对象，参数表示按中文排序 //根据指定的 "比较器" 产生的顺序对 "指定对象数组" 进行排序 Arrays.sort(str,com);//sort(T[] a,Comparator&lt;?super T&gt;c) for(int i=0;i&lt;str.length;i++) System.out.print(str[i]+" "); &#125; static void display(Integer arr[]) &#123; for(int i=0;i&lt;arr.length;i++) System.out.print(arr[i]+" "); System.out.println(""); &#125;&#125;程序运行结果1234567891011原内容：41 0 44 96 49 96 30 6 87 排序后：0 6 30 41 44 49 87 96 96 fill()后：-1 -1 -1 41 44 49 87 96 96 值23的位置：-4插入0在3号位置：-1 -1 -1 0 44 49 87 96 96 值0的位置：3复制后的数组：-1 -1 -1 0 44 49 87 96 两数组不相同！----------------------------------------李瑞豪 计算机 通信 黄桑 黄桑 计算机 李瑞豪 通信]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Arrays类</tag>
        <tag>java</tag>
        <tag>Collator</tag>
        <tag>Comparator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在搜索.文章底部.侧栏添加最近文章模块]]></title>
    <url>%2Fhexo%2Frecent-posts.html</url>
    <content type="text"><![CDATA[首先在主题配置文件添加以下关键字12345678recent_posts: enable: true search: true post: false sidebar: false icon: history title: 近期文章 layout: block搜索结果处添加找到路径H:\hexo\themes\hexo-theme-next\layout\_partials\search下localsearch.swig文件把&lt;div id=&quot;local-search-result&quot;&gt;&lt;/div&gt;修改成以下内容（这里显示15篇）123456789101112131415161718&lt;div id=&quot;local-search-result&quot;&gt; &#123;% if theme.recent_posts.enable and theme.recent_posts.search %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts.layout &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;i class=&quot;fa fa-&#123;&#123; theme.recent_posts.icon &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts.title &#125;&#125; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% set posts = site.posts.sort(&apos;-date&apos;) %&#125; &#123;% for post in posts.slice(&apos;0&apos;, &apos;15&apos;) %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;文章尾部添加把代码加在H:\hexo\themes\hexo-theme-next\layout\_macro\post.swig里的相应位置（我加在tags后）1234567891011121314&#123;% if not is_index and theme.recent_posts.enable and theme.recent_posts.post %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts.layout &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;i class=&quot;fa fa-&#123;&#123; theme.recent_posts.icon &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts.title &#125;&#125; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% set posts = site.posts.sort(&apos;-date&apos;) %&#125; &#123;% for post in posts.slice(&apos;0&apos;, &apos;5&apos;) %&#125; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt;&amp;emsp; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125;侧栏在 next/layout/_macro/sidebar.swig 中的 if theme.links 对应的 endif 后面。12345678910111213141516&#123;% if theme.recent_posts.enable and theme.recent_posts.sidebar %&#125; &lt;div class=&quot;links-of-blogroll motion-element &#123;&#123; &quot;links-of-blogroll-&quot; + theme.recent_posts.layout &#125;&#125;&quot;&gt; &lt;div class=&quot;links-of-blogroll-title&quot;&gt; &lt;i class=&quot;fa fa-history fa-&#123;&#123; theme.recent_posts.icon | lower &#125;&#125;&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; &#123;&#123; theme.recent_posts.title &#125;&#125; &lt;/div&gt; &lt;ul class=&quot;links-of-blogroll-list&quot;&gt; &#123;% set posts = site.posts.sort(&apos;-date&apos;) %&#125; &#123;% for post in posts.slice(&apos;0&apos;, &apos;3&apos;) %&#125; &lt;li&gt; &lt;a href=&quot;&#123;&#123; url_for(post.path) &#125;&#125;&quot; title=&quot;&#123;&#123; post.title &#125;&#125;&quot; target=&quot;_blank&quot;&gt;&#123;&#123; post.title &#125;&#125;&lt;/a&gt; &lt;/li&gt; &#123;% endfor %&#125; &lt;/ul&gt; &lt;/div&gt;&#123;% endif %&#125;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java猜数字小游戏（Math类）]]></title>
    <url>%2Fjava%2Fmathclass.html</url>
    <content type="text"><![CDATA[大一刚学c的时候以前写过c语言版的。Math:针对数学进行运算的类特点：没有构造方法，因为它的成员都是静态的产生随机数：public static double random(): 产生随机数，范围[0.0,1.0)产生1-100之间的随机数int number = (int)(Math.random()*100)+1;猜数字小游戏案例1234567891011121314151617181920class MathDemo &#123; public static void main(String[] args) &#123; //获取随机数 //double d = Math.random(); //System.out.println(d); /* for(int x=0; x&lt;10; x++) &#123; //System.out.println(Math.random()); System.out.println(Math.random()*100); &#125; */ //我们如何获取1-100之间的随机数呢? for(int x=0; x&lt;100; x++) &#123; int number = (int)(Math.random()*100)+1; System.out.println(number); &#125; &#125;&#125;小游戏该游戏可以由程序随机产生或由用户输入四个0到9之间的数字，且不重复。玩游戏者通过游戏提示输入八次来匹配上面所输入的数字。A表示位置正确且数字正确，B表示数字正确而位置不正确。算法： 可以直接算出A类的数目，但是B类的数目直接算出或许会很麻烦，正好我们可以先算出C类数目恰好减去A类就是B类了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package caishuzi;import java.util.Scanner;class Num &#123; private int[] a= &#123;0,0,0,0&#125;; public Num() &#123;&#125; public void setx() &#123; /*for(int i=0;i&lt;4;i++) &#123; a[i]=(int)(Math.random()*10); &#125;*/ //为了四个互不相同的随机数 a[0]=(int)Math.random()*10+1; for(int i=1;i&lt;4;i++) &#123; int t=(int)(Math.random()*10); for(int j=0;j&lt;i;j++) &#123; if(t==a[j]) &#123; t=(int)(Math.random()*10); j=0; &#125; &#125; a[i]=t; &#125; &#125; public int[] getx() &#123; return a; &#125; public void show() &#123; System.out.println(); for(int i=0;i&lt;4;i++) System.out.print(a[i]+" "); System.out.println(); &#125; &#125;public class caishuzi &#123; public static void main(String agrs[]) &#123; int a[] = &#123;0,0,0,0&#125;,b[] = &#123;0,0,0,0&#125;; System.out.println("* * * *\n请输入4个数字！A表示位置数字都正确，B表示数字正确位置错误。"); Scanner sc=new Scanner(System.in); Num n=new Num(); n.setx(); a=n.getx(); /*for(int i=0;i&lt;4;i++) System.out.print(a[i]+" "); n.show();*/ for(int k=0;k&lt;10;k++) &#123;//猜测次数 int A=0,B=0,C=0; for(int i=0;i&lt;4;i++) &#123; b[i]=sc.nextInt(); &#125; sc.close(); for(int i=0;i&lt;4;i++)&#123; if (b[i]==a[i])A++; for(int j=0;j&lt;4;j++)&#123; C=b[i]==a[j]?++C:C;//C表示猜测数内和随机数中A类和B类数的数目 if (b[i]==a[j])break; &#125; &#125; B=C-A;// 关键算法（感叹数学魅力） if(A==4) &#123; System.out.println("恭喜猜对啦！"); &#125;else &#123; System.out.println(A+"A"+B+"B"); &#125; &#125; &#125;&#125;一次游戏过程1234567891011121314* * * *请输入4个数字！A表示位置数字都正确，B表示数字正确位置错误。0 1 2 30A1B0 1 2 40A1B0 1 2 51A1B6 1 2 51A2B1 6 2 53A0B1 6 7 5恭喜猜对啦！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Math类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象基础知识总结]]></title>
    <url>%2Fjava%2Fduixiang.html</url>
    <content type="text"><![CDATA[面向对象思想(理解)面向对象是基于面向过程的一种编程思想思想特点：A:是一种更符合我们思考习惯的思想B:把复杂的问题简单化C:让我们从执行者变成了指挥者举例：A:洗衣服B:吃饭C:买电脑举例并代码体现把大象装进冰箱类与对象(掌握)我们学习编程是为了把现实世界的事物用编程语言描述来实现信息化。现实世界事物是如何表达的呢?属性：外在特征行为：内在行为我们学习的是java语言，它最基本的单位是类。所以我们要学会用类来体现一个事物。类：是一组相关的属性和行为的集合对象：是该类事物的具体个体。举例：学生 类张三 对象类的组成(掌握)成员变量其实就是变量，只不过定义在类中，方法外，并且可以不用初始化。成员方法其实就是方法，只不过不需要static了案例：学生类123456class Student &#123; String name; int age; public void study() &#123;&#125;&#125;类的使用(掌握)创建对象格式：类名 对象名 = new 类名();使用成员成员变量：对象名.变量名;成员方法：对象名.方法名(…);成员变量和局部变量的区别(理解)在类中的位置不同A:成员变量 类中，方法外B:局部变量 方法的形式参数，或者方法体中在内存中的位置不同A:成员变量 在堆中B:局部变量 在栈中生命周期不同A:成员变量 随着对象的存在而存在，随着对象的消失而消失B:局部变量 随着方法的调用而存在，随着方法的调用完毕而消失初始化值不同A:成员变量 有默认初始化值B:局部变量 没有默认值，必须先声明，赋值，最后才能使用形式参数问题(理解)基本类型基本类型作为形式参数，需要的是该基本类型的值。引用类型引用类型作为形式参数，需要的是该引用类型的地址值。(对象)匿名对象(理解)匿名对象：没有名字的对象。是对象的简化书写方式。使用场景A:调用方法，仅仅只调用一次B:作为实际参数传递封装(掌握)隐藏实现细节，提供公共的访问方式好处：A:隐藏实现细节，提供公共的访问方式B:提高了代码的复用性C:提高了代码的安全性使用原则A:把成员变量隐藏B:给出该成员变量对应的公共访问方式private关键字(掌握)是一个权限修饰符可以修饰类的成员(成员变量和成员方法)仅仅在本类中可以访问,对外提供对应的GetXXX()，SetXXX()等方法标准代码：12345678910111213141516171819202122class Student &#123; private String name; private int age; public void setName(String n) &#123; name = n; &#125; public String getName() &#123; return name; &#125; public void setAge(int a) &#123; age = a; &#125; public int getAge() &#123; return age; &#125; public void study() &#123;&#125;&#125;this关键字(掌握)this：代表本类的对象应用场景：解决了局部变量隐藏成员变量的问题。其他用法和super一起讲。标准代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Student &#123; private String name; private int age; public void setName(String name) &#123;//局部变量 this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println("姓名是："+name+",年龄是："+age); &#125; public void study() &#123; System.out.println("学生爱学习"); &#125; public void eat() &#123; System.out.println("学生要吃饭"); &#125; public void sleep() &#123; System.out.println("学生想睡觉"); &#125;&#125;class StudentTest &#123; public static void main(String[] args) &#123; Student s = new Student(); s.setName("林青霞"); s.setAge(28); s.show(); s.study(); s.eat(); s.sleep(); System.out.println("姓名是："+s.getName()); System.out.println("年龄是："+s.getAge()); &#125;&#125;构造方法(掌握)作用：对对象的数据进行初始化。特点：A:方法名和类名相同B:没有返回值类型C:没有返回值注意事项A:如果我们没写构造方法，系统将默认给出无参构造方法B:如果我们写了构造方法，系统将不再给出默认无参构造方法建议：我们自己手动给出无参构造方法给成员变量赋值：A:无参+setXxx()B:带参一个标准的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445class Student &#123; private String name; private int age; public Student() &#123;&#125; public Student(String name,int age) &#123;//构造方法 this.name = name; this.age = age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125; public void show() &#123; System.out.println("姓名是："+name+",年龄是："+age); &#125;&#125;class StudentTest &#123; public static void main(String[] args) &#123; //无参+setXxx() Student s = new Student(); s.setName("林青霞"); s.setAge(28); s.show(); //带参 Student ss = new Student("张曼玉",20); ss.show(); &#125;&#125;对象的初始化过程(理解)Student s = new Student();做了哪些事情A:加载Student.class文件进内存B:在栈中为s开辟空间C:在堆中为学生对象开辟空间D:为学生对象的成员变量赋默认值E:为学生对象的成员变量赋显示值F:通过构造方法给成员变量赋值G:对象构造完毕，把地址赋值给s变量static关键字(掌握)是一个状态修饰符。静态的意思它可以修饰成员变量和成员方法特点：A:随着类的加载而加载B:优先于对象存在C:被所有对象共享这也是判断我们是不是该使用静态的条件举例：饮水机(可共享static)和水杯例子。D:可以通过类名调用静态修饰的内容，可以通过类名调用，也可以通过对象名调用方法访问特点A:普通成员方法可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法B:静态成员方法只能访问静态成员变量，静态成员方法简记：静态只能访问静态注意：静态中是不能有this的。先进内存的不能访问后进内存的。反之可以。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* 班级编号应该是被班级每个人都共享的，所以定义一个就应该可以了。 而姓名和年龄，每个人应该是不一样的，所以，每个对象，都应该定义自己的。 在java中，用什么来表示成员变量是被共享的呢? static*/class Student &#123; //姓名 String name; //年龄 int age; //班级编号 //String classNumber; static String classNumber; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; public Student(String name,int age,String classNumber) &#123; this.name = name; this.age = age; this.classNumber = classNumber; &#125; public void show() &#123; System.out.println(name+"---"+age+"---"+classNumber); &#125;&#125;class StudentDemo &#123; public static void main(String[] args) &#123; //创建学生对象 Student s1 = new Student("林青霞",28,"20150306"); s1.show(); /* Student s2 = new Student("马云",35,"20150306"); s2.show(); Student s3 = new Student("马化腾",33,"20150306"); s3.show(); */ Student s2 = new Student("马云",35); s2.show(); Student s3 = new Student("马化腾",33); s3.show(); &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637/* static:静态关键字。 作用： 可以修饰成员变量和成员方法 特点： A:随着类的加载而加载 B:优先于对象存在 C:被类的所有对象共享 这也是我们判断是否使用静态关键字的条件 饮水机：可以被静态修饰 水杯：不可以被静态修饰 D:可以通过类名调用 我们的调用既可以是对象，还可以是类名*/class Student &#123; public void show() &#123; System.out.println("show"); &#125; public static void show2() &#123; System.out.println("show2"); &#125;&#125;class StudentDemo2 &#123; public static void main(String[] args) &#123; Student s = new Student(); s.show(); s.show2(); Student.show2(); //Student.show();&amp;ensp; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* static的注意事项： A:在静态方法中是没有this关键字的 因为静态是随着类的加载而加载，优先于对象而存在。而this是随着对象的创建而存在。 先进内存的， 不能访问后进内存的；而后进内存的，可以访问先进内存的。 B:静态只能访问静态。 非静态的成员方法： 可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法 静态的成员方法： 只能访问静态的成员变量，静态的成员方法*//*class Student &#123; private String name; public static void setName(String name) &#123;//&amp;ensp;静态方法不能用this this.name = name; &#125; public void show() &#123; System.out.println(name); &#125;&#125;*/class Demo &#123; int x = 10; static int y = 20; public void show() &#123; System.out.println(x); System.out.println(y); &#125; public static void show2() &#123; //System.out.println(x);&amp;ensp; System.out.println(y);//√ &#125; public void show3() &#123; show(); show2(); &#125; public static void show4() &#123; //show();只能访问静态的成员方法 show2(); &#125;&#125;class StudentDemo3 &#123; public static void main(String[] args) &#123; //Student.setName("林青霞"); &#125;&#125;静态成员变量和普通成员变量的区别(理解)所属不同静态属于类的，称为类变量非静态属于对象的，称为对象变量，实例变量内存空间不同静态在方法区的静态区非静态在堆内存生命周期不同静态随着类的加载而加载，随着类的消失而消失非静态随着对象的创建而存在，随着对象的消失而消失调用不同静态可以通过类名调用，也可以通过对象名调用。建议通过类名调用非静态只能通过对象名调用main方法是静态的(理解)1public static void main(String[] args)public:访问权限修饰符，表示最大的访问权限，被jvm调用，所有权限要够大。static:被jvm调用，不用创建对象，直接类名访问void:被jvm调用，不需要给jvm返回值main:一个通用的名称，虽然不是关键字，但是被jvm识别String[] args:早期出现是为了接收键盘录入数据的。实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*求和*/class Demo &#123; private int x; private int y; public Demo() &#123;&#125; public Demo(int x,int y) &#123; this.x = x; this.y = y; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getX() &#123; return x; &#125; public void setY(int y) &#123; this.y = y; &#125; public int getY() &#123; return y; &#125; //成员变量已经有x,y了。这里就没有必要在定义了 /* public int sum(int x,int y) &#123; return x + y; &#125; */ public int sum() &#123; return x + y; &#125;&#125;class Test &#123; public static void main(String[] args) &#123; Demo d = new Demo(); d.setX(10); d.setY(20); int result = d.sum(); System.out.println(result); &#125;&#125;1234567891011121314/*求和*/class Demo &#123; public int sum(int x,int y) &#123; return x + y; &#125;&#125;class Test2 &#123; public static void main(String[] args) &#123; Demo d = new Demo(); int result = d.sum(10,20); System.out.println(result); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/* 定义一个员工类,自己分析出几个成员， 然后给出成员变量，构造方法，getXxx()/setXxx()方法， 以及一个显示所有成员信息的方法。并测试。 Employee： 成员变量：员工编号,姓名,职位 构造方法：无参，带参 成员方法：getXxx()/setXxx()方法，show()*/class Employee &#123; private String eid; private String name; private String job; public Employee() &#123;&#125; public Employee(String eid,String name,String job) &#123; this.eid = eid; this.name = name; this.job = job; &#125; public void setEid(String eid) &#123; this.eid = eid; &#125; public String getEid() &#123; return eid; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setJob(String job) &#123; this.job = job; &#125; public String getJob() &#123; return job; &#125; public void show() &#123; System.out.println("员工编号是："+eid+",姓名是："+name+",职位是："+job); &#125;&#125;class EmployeeDemo &#123; public static void main(String[] args) &#123; //无参 Employee e = new Employee(); e.setEid("itcast007"); e.setName("周星驰"); e.setJob("高级工程师"); e.show(); //带参 Employee e2 = new Employee("itcast003","刘德华","挖掘机工程师"); e2.show(); &#125;&#125;java类中的成员变量和方法访问权限关键词同一个类同一个包不同包中的子类不同包中的非子类private√&ensp;&ensp;&ensp;default√√&ensp;&ensp;protected√√√&ensp;public√√√√]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java水仙花数（循环）]]></title>
    <url>%2Fjava%2Fxunhuan.html</url>
    <content type="text"><![CDATA[水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153）。定义水仙花数只是自幂数的一种，严格来说3位数的3次幂数才称为水仙花数。附：其他位数的自幂数名字一位自幂数：独身数两位自幂数：没有三位自幂数：水仙花数四位自幂数：四叶玫瑰数五位自幂数：五角星数六位自幂数：六合数七位自幂数：北斗七星数八位自幂数：八仙数九位自幂数：九九重阳数十位自幂数：十全十美数123456789101112131415161718192021222324252627282930package xunhuan;import java.util.Scanner;public class shuixianhua &#123; public static void main(String[] agrs) &#123; System.out.print("指定最大位数N:"); Scanner input = new Scanner(System.in); int N = input.nextInt(); input.close(); for (int i = 3; i &lt;= N; i++) &#123; int a[] = new int[i]; int num = (int) Math.pow(10, i - 1) + 1; System.out.print(i + "位的水仙花数有：\t"); while (num &lt;= Math.pow(10, i)) &#123; int sum = 0; for (int j = 0; j &lt; i; j++) a[j] = (int) (num / Math.pow(10, j) % 10);//取各个位的数 for (int j = 0; j &lt; i; j++) sum = sum + (int) Math.pow(a[j], i); if (num == sum) System.out.print(num + "\t"); num++; &#125; System.out.print("\n"); &#125; &#125;&#125;由于int精度限制，最多算到9位，而且使用常规算法，算到8，9位的时候就特别慢了。12345678指定最大位数N:103位的水仙花数有： 153 370 371 407 4位的水仙花数有： 1634 8208 9474 5位的水仙花数有： 54748 92727 93084 6位的水仙花数有： 548834 7位的水仙花数有： 1741725 4210818 9800817 9926315 8位的水仙花数有： 24678050 24678051 88593477 9位的水仙花数有： 146511208]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>水仙花数</tag>
        <tag>循环语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java录入数据]]></title>
    <url>%2Fjava%2Finput.html</url>
    <content type="text"><![CDATA[记忆格式：(1)导包：import java.util.Scanner;注意：位置在class的上面。(2)创建键盘录入对象：Scanner sc = new Scanner(System.in);(3)获取数据int i = sc.nextInt();(4)练习：A:求两个数据的和B:获取两个数据中较大的值C:获取三个数据中较大的值D:比较两个数是否相等实例123456789101112131415161718192021222324252627282930package helloworld;import java.util.Scanner;public class helloworld &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int i=sc.nextInt(),j=sc.nextInt(),k=sc.nextInt(); sc.close(); System.out.println(i+"+"+j+"="+(i+j)); System.out.println("MAXij="+Max(i,j)); System.out.println("MAXijk="+Max(i,j,k)); &#125; //Max()方法重载 static int Max(int i,int j) &#123; return i&gt;j?i:j; &#125; static int Max(int i,int j,int k) &#123; if(i==j) System.out.println("i和j相等"); else if(i==k) System.out.println("i和k相等"); else if(j==k) System.out.println("j和k相等"); return (i=i&gt;j?i:j)&gt;k?i:k; &#125;&#125;结果123455 5 65+5=10MAXij=5i和j相等MAXijk=6]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java输入流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java标识符]]></title>
    <url>%2Fjava%2Fbiaoshi.html</url>
    <content type="text"><![CDATA[标识符：给类，接口，方法或者变量起名字的符号组成规则：A:英文字母大小写B:数字C:_和$注意事项：A:不能以数字开头B:不能是Java中的关键字C:区分大小写Student,student 这是两个名称常见命名方式：A:包 其实就是文件夹,用于解决相同类名问题全部小写单级：com多级：cn.itcastB:类或者接口一个单词：首字母大写Student,Person,Teacher多个单词：每个单词的首字母大写HelloWorld,MyName,NameDemoC:方法或者变量一个单词：全部小写name,age,show()多个单词：从第二个单词开始，每个单词首字母大写myName,showAllStudentNames()D:常量一个单词：全部大写AGE多个单词：每个单词都大写，用_连接STUDENT_MAX_AGE]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java标识符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法--主谓一致]]></title>
    <url>%2FEnglish%2Fsubject-verb.html</url>
    <content type="text"><![CDATA[常见情况由and或both and连接的并列主语，谓语动词一般用复数English and chinese are two quite different languages.Both brother and sister tire of city life.一但主语前被no,every,each所修饰时，谓语动词用单数No desk and (no) chair is seen in the hall.All work and no play makes Jack a dull boy.They each have been to the Forbidden city.each位于主语后，所以谓语动词用复数当主语表示同一事物的两个部分，同一个人的两个身份（第二个名词前无冠词），谓语动词用单数比如the（a）horse and cart a watch and chain a knife and fork a cup and soucer the butter and breadThe horse and cart has fallen down the cliff(悬崖).Butter and bread is his favourate.The poet(诗人) and writer has been sentenced(判决) to death.The poet and the writer have been sentenced(判决) to death.两数相加或相乘，单复皆可，相减或相除，只能用单数，量词做主语，用单数等于： be,equal,be equal to,make相加： and,plus相减： minus相乘： multily,time相除： divided byOne and one make(makes) two.就近原则not only…but alsothere/here beor,nor,either…or,neither…nor,not…butThere is a desk and two chairs in the room.Are you or your sister fond of classical music?An apple or two lies on the desk.(数量词后用单数)One or two apples lie on the desk.Not he but you have come.就远原则两单体两结构三with四除外like,includingrather than,as well aswith,together with,along withexcept,besides,but,in addition toThe couple in addition to their child are mean.Lauren,rather than anyone else was chose his partener.A library together with 3000 books was destroyed in the fire.时间，金钱，距离，温度，天气，重量等不可数名词，to do,doing,从句做主语时，谓v用单数To go to bed early and rise early is a good habit.What he says and behaives doesn’t concern me.分数，百分数，the rest(+of+n)做主语，用单数谓语动词由of后面的名词决定，一般用单数。分数用法： 通常分子读基数，分母读序数，分子超过1时，分母加s。即 基+序(s)+of+n+谓Most students are in favaour of the contract(契约) but the rest disagree.be favaour of: be for,approve of,support,agree withAbout two thirds of the earth’s surface is covered by water.一些短语one of+n或the only one of+n,一般用单数（定从根据中心词在of前后）a number of+n（用复数） &amp; the number of+n（用单数）one in 或 one out of+n (用单数)a large quantity of &amp; large quantity of + 可\不可数na large amount of &amp; large amounts of + 不可数nHe is one of the students who were awarded the other day.He is the only one of the students who was awarded the other day.One of his family was a traitor(卖国贼，叛徒) during the world war two.A number of teenagers are addicted to the Internet.The number of students who are addicted to the Internet is up to(接近于) 15.Large amounts of power are foused on him alone.==a large amount of power is foused on him alone.不定代词做主语，谓语动词用单数all修饰人，谓语动词用复数，修饰物，谓语动词用单数All are present besides the professor.All that glitters(发光体) is not gold.not与all/both等连用表部分否定the +adj表一类人做主语时，谓语动词用复数The injured are taken good care of in hospital.The agreeable is not always the useful.(不表人)成双成对的词做主语，用复数trousers(裤子),chopsticks,scissors(剪刀),glassesPants are what I want.The pair of glasses seems expensive.(谓语动词与表示计量单位的名词形式一致)Three set of fashionable socks are shown in today’s evening proper(恰当地).一系列： a piece/pair/set/suit/series of以s结尾特殊专用名词，用单数表学科，疾病，山脉，河流，书名，歌名，格言等maths,physicsa(物理),politics(政治),classics,economics,Aids,SARs,diabetes(糖尿病),arthritis(关节炎),bronchitis(支气管炎),Himalayas,Arabian NightArabian Night sounds beautiful.many a +单n+单谓： “许多” more than one +单n+单谓： “不止一个”Many a man thinks life is meaningless without a purpose/an aim.More than one student has put forward the suggestion.More students than one are against the proposal.More than 20% students were absent at the meeting yesterday.(不止)police,people,cattle做主语，用复数It is reported that police are trying their best to capture the murder.the Olympics &amp; the Olympic gamesThe Olympices is hold every four years. == The Olympic games are hold every four year.集体名词做主语，表整体用单数，表成员用复数family,class,group,team,army,public,crew,populationThe innovation experiment(革新实验) class consists of 24 students and enjoy chinese.Population in China is 1.4 billion or so(about) 20% (Population) have no access to clean water.单复同形，sheep,deer,means,Chinese等谓语动词依据情况而定Many deer live on the African grassland.地点状语位于句首Among the crow stand his parents.On the wall hangs an alarm clock.“of”: of表所属时，中心词在of之前，谓语动词由中心词决定，特例除外。]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[年度总结]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2Fyears.html</url>
    <content type="text"><![CDATA[以前每年都会在QQ空间写每年的总结，可是现在已经过了肆意在空间写说说的年纪了。所幸还有博客这一席之地。201818年主要的收获，经历大概就在下面了，可还是没有学到什么硬本事，寒假还是要学习一下java和jsp。首先最开心的是在狗年刚开始3月底回到湘潭后，拿下了驾照（年前挂了一次很不爽），可以开共享汽车了，体验共享时代的新滋味。然后是11月份的软考，虽然没有认真准备考试，还是过了（上午压线）。不知道是今年的容易还是怎么的，反正我考完就觉得挺容易的。5月底搭建了现在这个hexo静态博客，还收到了一些网上朋友的打赏，感谢！用打赏的钱买了两个服务器一个国内的，一个国外的。搭了一个文件浏览器作为自己的网盘,还搭了一个ss梯子供自己翻墙使用。参加了2018年ACM的湘潭全国邀请赛，在湘大，虽然很遗憾没有拿奖，但就当走过这步吧，略过。暑假结束，退出了E313ACM实验室，也就没有刷题打比赛了。大二获得了个国家励志，还不错。hhhh有奖金!真的很菜但是退实验之前，学院的编程比赛还是运气好拿了个三等奖。]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法--形式倒装]]></title>
    <url>%2FEnglish%2Finversion-3.html</url>
    <content type="text"><![CDATA[形式倒装，句子本不是本来的语序。may位于句首，标祝愿例句May you succeed.May you have a happy holiday.Long live chairman Mao.(毛主席万古长青)whatever直接做成分或放在名词之前，however 放在adv,adj之前或many,much等词之前例句Whatever the weather is,he sticks out(坚持) walking outside.Go to stamp sales and buy whatever you can offord.Whatever reasons you have,you should carry out your promise.However many difficulties(n.) you meet with,you should try to overcome them.Whatever difficulties(n.) you meet with,you should try to overcome them.However difficult(adj.) the problem is,we must work it out today.the + 比较级，the + 比较级 --&gt;“越…越…”例句The hander you study,the greater progress you will make.The more you listen to English,the easier it becomes.The older you grow,the more challenges you will meet.感叹句例句What an interesting talk they had!How interesting the talk was!]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法--完全倒装]]></title>
    <url>%2FEnglish%2Finversion-2.html</url>
    <content type="text"><![CDATA[完全倒装： 把整个谓语动词放到主语前。表方位或时间的副词(adv)、表地点的介词短语位于句首时例句Here comes the bus.In the lecture hall of a university sits a professor.Out rushed the children.Now comes your turn.Up jumped the cat and caught the mouse.Down came the rain and up went the umbrellas.Among the people stood his friend,Jim.(To be) South of the river lies a small factory.但主语为表示人称的代词时无需倒装Here are you.&emsp;&emsp;&emsp;&emsp;Away it flew.表语(词/短语)位于句首时，adj/doing/done例句Written on the blackboard are the name of these who were late.Gone are the days when we worked together.Standing at the tree is a shy girl with two big eges.Present(adj) at the conference were all leaders of this city.Lying on the grassland is the boy who was injured in the fire.存在句there be中，其中be -&gt;exist/arise/follow/enter/appear/live等表状态vi例句There come shows for help from the river.There seems something wrong with machine.There remains nothing to be done.There happened an event last week.]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[英语语法--部分倒装]]></title>
    <url>%2FEnglish%2Finversion-1.html</url>
    <content type="text"><![CDATA[&#x867D;&#x7136;&#x6211;&#x82F1;&#x8BED;&#x56DB;&#x7EA7;&#x6CA1;&#x8FC7;&#xFF0C;&#x8BCD;&#x6C47;&#x91CF;&#x4E5F;&#x4E0D;&#x5F88;&#x591A;&#xFF0C;&#x751A;&#x81F3;&#x4E0B;&#x964D;&#x4E86;&#x5F88;&#x591A;&#xFF0C;&#x4F46;&#x662F;&#x5BF9;&#x4E8E;&#x82F1;&#x8BED;&#x7684;&#x8BED;&#x6CD5;&#x6211;&#x8FD8;&#x662F;&#x5F88;&#x559C;&#x6B22;&#x7684;&#xFF0C;&#x9A6C;&#x4E0A;&#x5FEB;&#x56DB;&#x7EA7;&#x4E86;&#x53C8;&#xFF0C;&#x590D;&#x4E60;&#x6574;&#x7406;&#x4E00;&#x4E0B;&#x4EE5;&#x524D;&#x7684;&#x8BED;&#x6CD5;&#x7B14;&#x8BB0;&#x3002;&#x4EE5;&#x4E0B;&#x5185;&#x5BB9;&#x7EAF;&#x624B;&#x6253;&#xFF01;&#xFF01;&#x5148;&#x4ECE;&#x5012;&#x88C5;&#x53E5;&#x5F00;&#x59CB;&#x5427;&#xFF01;&#x5206;&#x4E3A;&#x4E09;&#x5927;&#x7C7B;&#xFF0C;&#x90E8;&#x5206;&#x5012;&#x88C5;&#xFF0C;&#x5B8C;&#x5168;&#x5012;&#x88C5;&#x548C;&#x5F62;&#x5F0F;&#x5012;&#x88C5;&#x3002;&#x5148;&#x590D;&#x4E60;&#x7B2C;&#x4E00;&#x79CD;&#x3002;&#x90E8;&#x5206;&#x5012;&#x88C5;&#xFF1A; &#x628A;&#x8C13;&#x8BED;&#x52A8;&#x8BCD;&#x7684;&#x4E00;&#x90E8;&#x5206;&#xFF08;&#x52A9;&#x52A8;&#x8BCD;&#xFF0C;be&#x52A8;&#x8BCD;&#xFF0C;&#x60C5;&#x6001;&#x52A8;&#x8BCD;&#xFF09;&#x63D0;&#x5230;&#x4E3B;&#x8BED;&#x524D;&#x9762;&#x3002;xx&#x4E5F;&#x5982;&#x6B64;&#xFF0C;xx&#x4E5F;&#x4E00;&#x6837;&#x8868;&#x793A;&#x524D;&#x9762;&#x7684;&#x5185;&#x5BB9;&#x4E5F;&#x9002;&#x7528;&#x4E8E;&#x540E;&#x8005;&#xFF0C;&#x7528;&quot;so/nor/neither + &#x52A8;&#x8BCD; + &#x4E3B;&#x8BED;&quot;&#x53E5;&#x578B;&#x3002;&#x8868;&#x201C;xx&#x4E5F;&#x5982;&#x6B64;&#xFF0C;xx&#x4E5F;&#x4E00;&#x6837;&#x201D;&#x3002;&#x53EF;&#x7528;,&#x3001;;&#x3001;and&#x9694;&#x5F00;&#xFF08;&#x6CE8;&#x610F;&#x60C5;&#x5F62;&#xFF09;&#x3002;&#x4F8B;&#x53E5;They love having lots of friends, so dothe disabled.(&#x8FD9;&#x91CC;the + &#x5F62;&#x5BB9;&#x8BCD;&#x8868;&#x4E00;&#x7C7B;&#x4EBA;)I have had a new idea; so hasmy friends.Lily can&#x2019;t ride bicycle, nor/neither canlucy.The injured look disappointed(&#x6CAE;&#x4E27;&#x7684;), so didsenior citizens.(&#x8001;&#x4EBA;) (&#x5426;&#x5B9A;&#x524D;&#x7F00;&#x8BCD;&#x2260;&#x5426;&#x5B9A;)If you aren&#x2019;t for the plan; nor/neither willI., &#x6216; ;&#x524D;&#x7684;&#x53E5;&#x5B50;&#x82E5;&#x4E3A;&#x4ECE;&#x53E5;&#xFF0C;&#x5148;&#x5C06;&#x4E3B;&#x53E5;&#x8865;&#x5145;&#x51FA;&#xFF0C;&#x5176;&#x540E;&#x518D;&#x6839;&#x636E;&#x4E3B;&#x53E5;&#x6539;&#x3002;&#x8FD9;&#x91CC;&#x4E3B;&#x53E5;&#x5E94;&#x4E3A;&#xFF1A; I will not be for the plan.(be for &#x540C;&#x610F;)It is burning(&#x71C3;&#x70E7;) hot today, so it is(&#x90A3;&#x786E;&#x5B9E;) and/; so was (it)yesterday.(&#x8FD9;&#x91CC;&#x53EA;&#x7528;&#x7528;and&#x6216;;)Everyone is here and looks upset, so it is with Mary = it is the same withMary.&#x8FD9;&#x4E2A;&#x53E5;&#x578B;&#x540C;&#x6837;&#x9002;&#x7528;&#x4E8E;&#x524D;&#x9762;&#x7684;&#x516D;&#x4E2A;&#x4F8B;&#x5B50;&#xFF0C;&#x4F46;&#x662F;&#x524D;&#x9762;&#x662F;&#x5E76;&#x5217;&#x53E5;&#x5FC5;&#x987B;&#x7528;&#x8FD9;&#x4E2A;&#x53E5;&#x578B;&#x3002;The truth is that no one is perfect.When all potential(&#x6F5C;&#x5728;&#x7684;) for ugliness in removed, so is all of the potential for beauty.&#x5426;&#x5B9A;&#x526F;&#x8BCD;&#x6216;&#x542B;&#x6709;&#x5426;&#x5B9A;&#x7684;&#x4ECB;&#x8BCD;&#x77ED;&#x4F4D;&#x4E8E;&#x53E5;&#x9996;&#x4F8B;&#x53E5;Neither does Mr.Green know the matter(&#x4E8B;&#x4EF6;) nor does he care about it.neither&#x2026;&#x2026;nor&#x2026;&#x2026; &#x65E2;&#x4E0D;&#x4E5F;&#x4E0D;&#x2003;either&#x2026;&#x2026;or&#x2026;&#x2026;&#x8981;&#x4E48;&#x8981;&#x4E48;&#xFF0C;&#x4E0D;&#x662F;&#x5C31;&#x662F;Not only did we lose our way but also (we) came close to losing our lives.(come close to &#x63A5;&#x8FD1;&#xFF0C;&#x5DEE;&#x4E00;&#x70B9;&#x5C31;)Not until I began to work hard did I realize how much time I had wasted.&#x4ECE;&#x53E5;&#x4E0D;&#x5012;&#x88C5;&#xFF0C;&#x539F;&#x53E5;&#x4E3A;&#xFF1A;I didn&#x2019;t realize how much time I had wasted until I began to work hard.No sooner had they arrived at the tomb than they fell ill.(&#x4E00;&#x2026;&#x2026;&#x5C31;&#x2026;&#x2026;)In no case will we give up half-way.Hardly does Jim think it possible to finish the task before/when dark.hardly&#x2026;before/when &#x4E00;&#x2026;&#x2026;&#x5C31;&#x2026;&#x2026; &#x2003;&#x8FD9;&#x91CC;&#x53D6;&#x201D;&#x51E0;&#x4E4E;&#x4E0D;&#x201D;&#x91CA;&#x4E49;&#x5E94;&#x8BE5;&#x66F4;&#x5408;&#x9002;.Not a (single) mistake has Mary made so far.(&#x739B;&#x4E3D;&#x5230;&#x76EE;&#x524D;&#x4E3A;&#x6B62;&#x4E00;&#x4E2A;&#x9519;&#x8BEF;&#x4E5F;&#x6CA1;&#x72AF;&#x3002;)not a (single) + &#x5355;&#x6570;&#x540D;&#x8BCD; &#x8868;&#x793A;&#x201C;&#x4E00;&#x4E2A;&#x4E5F;&#x6CA1;&#x6709;&#x201D;In no time(&#x7ACB;&#x523B;&#x9A6C;&#x4E0A;) Jone worked out the figure(&#x4F53;&#x79EF;). (&#x65E0;&#x5426;&#x5B9A;&#x4E0D;&#x5012;&#x88C5;)only + &#x72B6;&#x8BED;&#x4F4D;&#x4E8E;&#x53E5;&#x9996;&#x4F8B;&#x53E5;Only in this way are you able to do it well.&#x5012;&#x88C5;&#x524D;&#xFF1A;You are able to do it well only in this way.Only when they returned home did they understand what had happened.Only on such a trip will you gain a better appreciation(&#x7406;&#x89E3;) of Eurepean literature.Only the teacher got the news that our school could have a 4-day holiday.(&#x540C;&#x4F4D;&#x8BED;&#x4ECE;&#x53E5;&#xFF0C;only+&#x4E3B;&#x8BED;&#x6240;&#x4EE5;&#x4E0D;&#x5012;&#x88C5;)So/Such&#x2026;that&#x2026;&#x53E5;&#x578B;&#x4F4D;&#x4E8E;&#x53E5;&#x9996;So + adj + a/an + &#x5355;&#x6570;&#x540D;&#x8BCD; = Such + a/an + adj + &#x5355;&#x6570;&#x540D;&#x8BCD; &#x5982;&#x6B64;...&#x4EE5;&#x81F3;&#x4E8E;...so&#x4FA7;&#x91CD;&#x4E8E;adj/adv&#x2003;such&#x4FA7;&#x91CD;&#x4E8E;n.&#x6BD4;&#x5982;&#xFF0C;so many/much/few/little&#x4F8B;&#x53E5;So crowded was the art gallery(&#x5C55;&#x89C8;&#x4F1A;) that I couldn&#x2019;t move about (it).Such good weather was it that we all went out last week.Such a lovely girl is kate that everyone likes her.So loudly did he speak that even people next room could hear him.as&#x5F15;&#x5BFC;&#x8BA9;&#x6B65;&#x72C0;&#x8BED;&#x4ECE;&#x53E5;as&#x5F15;&#x5BFC;&#x8BA9;&#x6B65;&#x72B6;&#x8BED;&#x4ECE;&#x53E5;(&#x867D;&#x7136;&#xFF0C;&#x5373;&#x4F7F;&#xFF0C;&#x5C3D;&#x7BA1;&#xFF0C;&#x65E0;&#x8BBA;)&#xFF0C;&#x628A;&#x4ECE;&#x53E5;&#x4E2D;&#x7684;&#x8868;&#x8BED;&#xFF0C;&#x52A8;&#x8BCD;&#xFF0C;&#x526F;&#x8BCD;&#x63D0;&#x81F3;&#x53E5;&#x9996;(as &#x540E;&#x4E0D;&#x7528;&#x518D;&#x5012;&#x88C5;&#x4E86;)&#xFF0C;&#x5F53;&#x8868;&#x8BED;&#x662F;&#x540D;&#x8BCD;&#x65F6;&#xFF0C;&#x63D0;&#x81F3;&#x53E5;&#x9996;&#x65F6;&#x4E00;&#x5F8B;&#x7528;&#x96F6;&#x51A0;&#x8BCD;(&#x5176;&#x4E2D;as&#x53EF;&#x7528;though&#x66FF;&#x4EE3;,&#x5012;&#x88C5;&#x540E;&#x7701;&#x7565;but,though,however,even,though,although&#x7B49;)&#x4F8B;&#x53E5;Child as he is,he knows a lot.Poor as King was,he tried his best to help others.Try as he may,he has never made his boss satisfied.Search as you would,you could find no body in the room.Much as I want to buy the car,I can&#x2019;t afford(&#x652F;&#x4ED8;) it.&#x628A;&#x865A;&#x62DF;&#x8BED;&#x6C14;&#x4ECE;&#x53E5;&#x4E2D;&#x7684;were,had,should&#x63D0;&#x81F3;&#x53E5;&#x9996;&#xFF0C;&#x5E76;&#x7701;&#x7565;if&#x4F8B;&#x53E5;Had you followwed my advice,you couldn&#x2019;t have made such a silly mistake.Were you not a boy,you could wear a dress.Should he invite me,I might take part in this party.&#x8868;&#x80AF;&#x5B9A;&#x542B;&#x4E49;&#x7684;&#x65F6;&#x95F4;&#x9891;&#x7387;&#x8BCD;&#x4F4D;&#x4E8E;&#x53E5;&#x9996;always,often,many a time(many times&#x591A;&#x6B21;),every + &#x65F6;&#x95F4;,now and then(&#x65F6;&#x4E0D;&#x65F6;&#x7684;)&#x4F8B;&#x53E5;Many a time has he offered me some good suggestions.Now and then does my class teacher warn us not yo use cellphones in the classroom.&#x7591;&#x95EE;&#x53E5;&#x7528;&#x90E8;&#x5206;&#x5012;&#x88C5;&#x666E;&#x901A;&#x7684;&#x7591;&#x95EE;&#x53E5;&#xFF1A;How do you do that?&#x9664;&#x4E86;&#xFF1A;What is wrong? = What is the matter?&#x2026;]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next插件样式]]></title>
    <url>%2Fhexo%2Fnextplugin.html</url>
    <content type="text"><![CDATA[&#x8BA9;&#x6587;&#x7AE0;&#x5199;&#x7684;&#x597D;&#x770B;&#x53C8;&#x7B80;&#x6D01;&#x53C8;&#x597D;&#x7528;&#x7684;&#x63D2;&#x4EF6;&#xFF01;hexo&#x63D2;&#x4EF6;hexo-filter-flowchart(&#x6D41;&#x7A0B;&#x56FE;)&#x8BED;&#x6CD5;install1npm install --save hexo-filter-flowchartUsage1234567891011121314151617```%flow #&#x53BB;&#x6389;%&#x53F7;st=&gt;start: Start|past:&gt;https://lruihao.cn[blank]e=&gt;end: End:&gt;https://www.lruihao.cnop1=&gt;operation: My Operation|pastop2=&gt;operation: Stuff|currentsub1=&gt;subroutine: My Subroutine|invalidcond=&gt;condition: Yesor No?|approved:&gt;/nextplugin.htmlc2=&gt;condition: Good idea|rejectedio=&gt;inputoutput: catch something...|requestst-&gt;op1(right)-&gt;condcond(yes, right)-&gt;c2cond(no)-&gt;sub1(left)-&gt;op1c2(yes)-&gt;io-&gt;ec2(no)-&gt;op2-&gt;e```hexo-spoilerInstall1npm install hexo-spoiler --saveIf hexo can&#x2019;t detect this plugin automatically, you need to modify the plugins section of [path_to_your_site]/_config.yml manually, like:12plugins: - hexo-spoilerSyntax1{% spoiler [text] %}It will pixelate your text, and click to reveal. Click again to hide your text again.But you need to add &lt;br&gt; manually if you want line breaks after/before it.PreviewWhen you writes:12345{% spoiler text %}{% spoiler ~~text~~ %}{% spoiler *text* %}{% spoiler **text** %}&lt;br&gt;{% spoiler **hello welcome to &#x535A;&#x63A1;&#x773E;&#x9577;&#xFF01;** %}text text text texthello welcome to &#x535A;&#x63A1;&#x773E;&#x9577;&#xFF01;&#x9009;&#x9879;&#x5361;&#x201C;tab&#x201D;&#x4E3A;&#x9009;&#x9879;&#x5361;&#x7684;&#x540D;&#x79F0;&#xFF0C;&#x53EF;&#x4EE5;&#x81EA;&#x5B9A;&#x4E49;&#xFF0C;&#x6570;&#x5B57;&#x662F;&#x51E0;&#x8868;&#x793A;&#x4ECE;&#x7B2C;&#x51E0;&#x4E2A;&#x9009;&#x9879;&#x5361;&#x5F00;&#x59CB;&#x3002;&#x975E;&#x5FC5;&#x987B;&#xFF0C;&#x82E5;&#x6570;&#x503C;&#x4E3A;-1&#x5219;&#x9690;&#x85CF;&#x9009;&#x9879;&#x5361;&#x5185;&#x5BB9;&#x3002;&#x67E5;&#x770B;&#x66F4;&#x591A;1234567891011{% tabs tab,2 %}&lt;!-- tab --&gt;this is tab1&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab2&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab3&lt;!-- endtab --&gt;{% endtabs %}tab 1tab 2tab 3this is tab1this is tab2this is tab3&#x6570;&#x503C;&#x4E3A;-1&#x9009;&#x9879; 1&#x9009;&#x9879; 2&#x9009;&#x9879; 3&#x9009;&#x9879;1&#x9009;&#x9879;2&#x9009;&#x9879;3&#x540D;&#x5B57;&#x5199;&#x5728;&#x9009;&#x9879;&#x91CC;&#x9762;1234567891011{% tabs Fourth unique name %}&lt;!-- tab Solution 1 --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 2 --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab Solution 3 --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;{% endtabs %}Solution 1Solution 2Solution 3This is Tab 1.This is Tab 2.This is Tab 3.note&#x4FBF;&#x7B7E;&#x4E3B;&#x9898;&#x914D;&#x7F6E;&#x6587;&#x4EF6;&#x641C;&#x7D22;note,&#x53EF;&#x8BBE;&#x7F6E;&#x98CE;&#x683C;&#x548C;&#x56FE;&#x6807;&#x662F;&#x5426;&#x663E;&#x793A;&#x3002;12345678910111213# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: flat icons: true border_radius: 15 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0&#x5199;&#x6CD5;1{% note default %}default&#x662F;&#x7C7B;&#x578B;&#x8FD8;&#x6709;&#x4EE5;&#x4E0B;&#x51E0;&#x79CD;{% endnote %}default&#x662F;&#x7C7B;&#x578B;&#x8FD8;&#x6709;&#x4EE5;&#x4E0B;&#x51E0;&#x79CD;defaultprimarysuccessinfowarningdanger&#x4E0D;&#x586B;danger no-icon&#x5F15;&#x7528;(&#x6587;&#x672C;&#x5C45;&#x4E2D;)123{% cq %}**there are test words**{% endcq %}there are test wordsFont Awesome&#x56FE;&#x6807;Font Awesome &#x662F;&#x4E00;&#x5957;&#x7EDD;&#x4F73;&#x7684;&#x56FE;&#x6807;&#x5B57;&#x4F53;&#x5E93;&#x548C;CSS&#x6846;&#x67B6;&#x3002;Font Awesome &#x5B57;&#x4F53;&#x4E3A;&#x60A8;&#x63D0;&#x4F9B;&#x53EF;&#x7F29;&#x653E;&#x77E2;&#x91CF;&#x56FE;&#x6807;,&#x5B83;&#x53EF;&#x4EE5;&#x88AB;&#x5B9A;&#x5236;&#x5927;&#x5C0F;&#x3001;&#x989C;&#x8272;&#x3001;&#x9634;&#x5F71;&#x4EE5;&#x53CA;&#x4EFB;&#x4F55;&#x53EF;&#x4EE5;&#x7528;CSS&#x7684;&#x6837;&#x5F0F;&#x3002;&#x8981;&#x4F7F;&#x7528;Font Awesome&#x56FE;&#x6807;&#xFF0C;&#x8BF7;&#x5728;HTML&#x9875;&#x9762;&#x7684; &#x90E8;&#x5206;&#x4E2D;&#x6DFB;&#x52A0;&#x4EE5;&#x4E0B;&#x884C;&#xFF1A;1&#x3001;&#x56FD;&#x5185;&#x63A8;&#x8350; CDN&#xFF1A;1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css&quot;&gt;2&#x3001;&#x6D77;&#x5916;&#x63A8;&#x8350; CDN1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css&quot;&gt;next&#x5DF2;&#x7ECF;&#x5F15;&#x7528;&#x4E86;&#xFF0C;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;&#x7528;&#xFF0C;&#x6BD4;&#x5982;&#xFF1A;12345678&lt;i class=&quot;fa fa-car&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car&quot; style=&quot;font-size:48px;&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car&quot; style=&quot;font-size:60px;color:red;&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-lg&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-2x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-3x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-4x&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-car fa-5x&quot;&gt;&lt;/i&gt; &#x52A8;&#x6001;&#x56FE;&#x6807;12345&lt;i class=&quot;fa fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-circle-o-notch fa-spin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-refresh fa-spin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-cog fa-spin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;fa fa-spinner fa-pulse&quot;&gt;&lt;/i&gt; &#x4EE3;&#x7801;&#x5757;&#x7B49;&#x4E09;&#x4E2A;&#x70B9;&#x540E;&#x9762;&#x7684;&#x53C2;&#x6570;lruihao.cn123[language] [title] [url] [link text]code snippetdiff12- printf(&quot;Hello World!&quot;);+ printf(&quot;Hello_World!&quot;);iframe&#x5728;&#x6587;&#x7AE0;&#x4E2D;&#x63D2;&#x5165; iframe&#x3002;iframe1{% iframe url [width] [height] %}&#x5176;&#x4ED6;&#x5305;&#x62EC;&#x5C0F;&#x8272;&#x5757;&#x3001;&#x5DE6;&#x4FA7;&#x8272;&#x6761;&#x3001;&#x53F3;&#x4FA7;&#x8272;&#x6761;&#x3001;&#x4E0A;&#x65B9;&#x8272;&#x6761;&#x3001;&#x6570;&#x5B57;&#x8272;&#x5757;&#xFF08;&#x9700;&#x8981;&#x81EA;&#x5B9A;&#x4E49;&#x6837;&#x5F0F;&#xFF09;&#x77E5;&#x4E4E;&#x5361;&#x7247;&#x94FE;&#x63A5;Lruihao&#x535A;&#x5BA2;&#x4E5F;&#x662F;&#x4E00;&#x79CD;&#x540E;&#x52A0;&#x8F7D;&#xFF0C;&#x521B;&#x5EFA;linkcard.js&#x653E;&#x5230;source/js/src/&#xFF0C;&#x7136;&#x540E;&#x5728;next\layout\_macro\post.swig&#x4E2D;&#x5F15;&#x7528;&#x77E5;&#x4E4E;&#x5361;&#x7247;&#x94FE;&#x63A5;12&lt;!--&#x77E5;&#x4E4E;&#x5361;&#x7247;&#x94FE;&#x63A5;--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/linkcard.js&quot;&gt;&lt;/script&gt;&#x94FE;&#x63A5;&#x5199;&#x6CD5;,&#x52A0;&#x4E0A;class=&quot;LinkCard&quot;1&lt;a href=&quot;https://github.com/Lruihao/lruihao.github.io&quot; target=&quot;_blank&quot; class=&quot;LinkCard&quot;&gt;Lruihao&#x535A;&#x5BA2;&lt;/a&gt;st=&gt;start: Start|past:&gt;https://lruihao.cn[blank] e=&gt;end: End:&gt;https://www.lruihao.cn op1=&gt;operation: My Operation|past op2=&gt;operation: Stuff|current sub1=&gt;subroutine: My Subroutine|invalid cond=&gt;condition: Yes or No?|approved:&gt;/nextplugin.html c2=&gt;condition: Good idea|rejected io=&gt;inputoutput: catch something...|request st-&gt;op1(right)-&gt;cond cond(yes, right)-&gt;c2 cond(no)-&gt;sub1(left)-&gt;op1 c2(yes)-&gt;io-&gt;e c2(no)-&gt;op2-&gt;e{&quot;scale&quot;:1,&quot;line-width&quot;:2,&quot;line-length&quot;:50,&quot;text-margin&quot;:10,&quot;font-size&quot;:12}var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过bat批处理文件自动提交博客代码]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fcommit-bat.html</url>
    <content type="text"><![CDATA[前面我有文章提到怎么提交本地文件到github,coding等远程仓库。每次可以分为三个步骤git add * (添加需要提交的文件，这里全选)git commit -m “提交信息”git push但是这样感觉很麻烦每次都要重复输入提交命令和提示信息。这个时候可以用到windows批处理bat文件(linux的话可以用shell脚本)。用完发现好用到不行!新建文本文档123456@echo offtitle Commitgit add .set /p m=Message:git commit -m "%m%"git push然后另存为commit.bat文件，只要后缀是bat就行了。使用把文件放到你原本需要提交代码的本地文件夹。双击运行，输入提交信息回车即可。hexo博客新姿势hexo提交也很麻烦，当然也要批处理一下呀1hexo clean&amp;&amp;hexo g -d其他死机脚本(友情提醒千万不要在真机实验，请在虚拟机运行)1start cmd ifconfig另外也说一下linux死机命令。fork炸弹。死机无非是耗尽系统资源1_()&#123; _ | _ &amp; &#125;; _这个&amp;指后台运行的意思。统计文件名1dir \\?\%1 /a:-d /b /o /p /w &gt;Filelist.txt将需要统计的文件夹拖到bat文件上。]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>批处理</tag>
        <tag>脚本</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博採眾長app]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Ffas-app.html</url>
    <content type="text"><![CDATA[介绍使用fusion app对网页进行的封装。功能：浏览本博客，主页私人网盘2048等小游戏在线客服，QQ等pc与移动浏览器标识切换留言，打赏，博主日志等分享功能，分享到QQ，微信，浏览器打开等app内添加书签，自动记录历史记录，刷新等下载博客app下载app内也可以更新，不过就我自己用，懒得更新。百度云，密码:479lgithub下载部分源码看到这些中文的函数总觉得怪怪的哈哈哈😂语言：lua检测更新1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556--检查测当前是否最新版本local dl=ProgressDialog.show(activity,nil,'更新检测中…')dl.show()local tt=Ticker()tt.start()packinfo=this.getPackageManager().getPackageInfo(this.getPackageName(),((32552732/2/2-8183)/10000-6-231)/9)version=tostring(packinfo.versionName)versioncode=tostring(packinfo.versionCode)url="https://share.weiyun.com/43fa66d8fc95db27141530ed2d006be2";function 过滤(content) 版本名=content:match("【版本名】(.-)【版本名】") 版本=content:match("【版本】(.-)【版本】") 内容=content:match("【内容】(.-)【内容】") 链接=content:match("【链接】(.-)【链接】")if(版本名==nil) then 版本名="获取失败"endif(版本==nil) then 版本="0"endif(内容==nil) then 内容="获取失败"endif(链接==nil) then 弹出消息("服务器参数配置错误，请过段时间再次尝试")endif(版本 &gt; versioncode) then dl.dismiss() tt.stop() 对话框().设置标题("检测到更新").设置消息("版本："..version.."→"..版本名.."\n更新内容："..内容).设置积极按钮("下载更新",function() 下载文件(链接) 弹出消息("下载更新中…")end).设置消极按钮("取消更新").显示()elsedl.dismiss() tt.stop()弹出消息("当前已是最新版本！")endendHttp.get(url,nil,"UTF-8",nil,function(code,content,cookie,header) if(code==200 and content)then content=content:match("\"html_content\":(.-),"):gsub("\\u003C/?.-%&gt;",""):gsub("\\\\","&amp;revs;"):gsub("\\n","\n"):gsub("&amp;nbsp;"," "):gsub("&amp;lt;","&lt;"):gsub("&amp;gt;","&gt;"):gsub("&amp;quot;","\""):gsub("&amp;apos;","'"):gsub("&amp;revs;","\\"):gsub("&amp;amp;","&amp;"); 过滤(content) else dl.dismiss() tt.stop() 弹出消息("本地网络或服务器异常 "..code) endend)方向锁定123456789101112131415--flag在程序启动事件声明的全局变量if flag==1 then activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR); SetHSP="H"else SetHSP=nilendif SetHSP==nil then --竖屏锁定 activity.setRequestedOrientation(1); flag=1else flag=0end程序启动事件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526弹出消息("©2018 李瑞豪")--自动，由物理感应器决定import "android.content.pm.ActivityInfo"flag=1--程序退出时执行对话框function onKeyDown(key,event) if(key==4)then if(webView.canGoBack())then webView.goBack() else appinfo=this.getPackageManager().getApplicationInfo(this.getPackageName(),0) applabel=this.getPackageManager().getApplicationLabel(appinfo) 退出确认=对话框() .设置消息("您确定要退出 "..applabel.." 吗?") 退出按钮=&#123; [1]=function() 退出确认 .设置积极按钮("确认",function() 退出程序() end ) .设置中立按钮("清除缓存",function() 对话框() .设置消息("清除缓存后再次运行程序将变得缓慢\n您确定要清除 "..applabel.." 的缓存吗?") .设置积极按钮("确定",function() os.execute("pm clear "..this.packageName) 退出程序() end) .设置消极按钮("取消",function() end) .显示() end ) .设置消极按钮("取消") end &#125; math.randomseed(tonumber(tostring(os.time()):reverse():sub(1, 6))) 退出按钮[math.random(1,1)]() 退出确认.show() end return true endend--历史记录lstads="/data/data/"..activity.getPackageName().."/lst.lua"lstwebads="/data/data/"..activity.getPackageName().."/lstweb.lua"--2.序列化function slz(obj) local lua = "" local t = type(obj) if t == "number" then lua = lua .. obj elseif t == "boolean" then lua = lua .. tostring(obj) elseif t == "string" then lua = lua .. string.format("%q", obj) elseif t == "table" then lua = lua .. "&#123;\n" for k, v in pairs(obj) do lua = lua .. "[" .. slz(k) .. "]=" .. slz(v) .. ",\n" end local metatable = getmetatable(obj) if metatable ~= nil and type(metatable.__index) == "table" then for k, v in pairs(metatable.__index) do lua = lua .. "[" .. slz(k) .. "]=" .. slz(v) .. ",\n" end end lua = lua .. "&#125;" elseif t == "nil" then return nil else error("can not serialize a " .. t .. " type.") end return lua end function rslz(lua) local t = type(lua) if t == "nil" or lua == "" then return &#123;&#125; elseif t == "number" or t == "string" or t == "boolean" then lua = tostring(lua) else error("can not unserialize a " .. t .. " type.") end lua = "return " .. lua local func = loadstring(lua) if func == nil then return nil end return func() end--3.历史记录框布局function hstshow() hstlayout=&#123; LinearLayout, orientation="1", gravity="center", layout_width="wrap_content", layout_height="wrap_content", &#123; TextView, text="", gravity="center", layout_width="wrap_content", textSize="0sp", background="#000000", layout_height="15dp",&#125;, &#123; TextView, text="历史记录", gravity="center", layout_width="wrap_content", textSize="30sp", textStyle="bold", layout_height="50dp",&#125;, &#123; ListView, id="hlst", items=lst, layout_width="fill", layout_height="wrap_content", &#125;, &#125;end--##功能函数##--1.读取历史文件function read_hst() import "java.io.File" File(lstads).createNewFile() slst=io.open(lstads):read("*a") File(lstwebads).createNewFile() slstweb=io.open(lstwebads):read("*a") --转换成table lst=rslz(slst) lstweb=rslz(slstweb)end--2.新网页加入历史记录function add_hst() if string.len(webView.getTitle())&lt;=300 then--粗略过掉无效标题 newtitle=webView.getTitle() newurl=webView.getUrl() table.insert(lst,1,newtitle) --标题表添加新标题 table.insert(lstweb,1,newurl) --网址表添加新网址 endend--3.存储历史文件function save_hst() --转换成string slst=slz(lst) slstweb=slz(lstweb) --保存 file=io.open(lstads,"w+") io.output(file) io.write(slst) io.flush() io.close(file) file=io.open(lstwebads,"w+") io.output(file) io.write(slstweb) io.flush() io.close(file)end--4.显示历史记录框function show_hst() hstshow() local hl=AlertDialog.Builder(activity) .setView(loadlayout(hstlayout)) .setNegativeButton("取消",DialogInterface.OnClickListener&#123; onClick=function() end &#125;) .create() hl.show() hlst.onItemClick=function(l,v,c,b) 加载网页(lstweb[b]) hl.dismiss() end hlst.onItemLongClick=function(l,v,c,b) hl.dismiss() 对话框() .设置消息("是否删除记录？") .设置消极按钮("取消",function() show_hst() end) .设置积极按钮("确定",function() table.remove(lst,b) table.remove(lstweb,b) save_hst() show_hst() end ) .显示() return true endend--5.清除缓存function clr() --导入File类 import "java.io.File" --显示多选框 items=&#123;"浏览记录","缓存文件"&#125; 多选对话框=AlertDialog.Builder(this) .setTitle("清除记录") --勾选后执行 .setPositiveButton("确定",function() if clearhistory==1 and clearall==1 then File(lstads).delete() File(lstwebads).delete() lst=&#123;&#125; lstweb=&#123;&#125; os.execute("pm clear "..activity.getPackageName()) elseif clearhistory==0 and clearall==1 then os.execute("pm clear "..activity.getPackageName()) elseif clearhistory==1 and clearall==0 then File(lstads).delete() File(lstwebads).delete() lst=&#123;&#125; lstweb=&#123;&#125; else return nil end end) --选择事件 .setMultiChoiceItems(items, nil,&#123; onClick=function(v,p) --清除历史 if p==0 then clearhistory=1 end --清除缓存 if p==1 then clearall=1 end end&#125;) 多选对话框.show(); clearhistory=0 clearall=0endactivity.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);--11.长按弹窗function popwin(od) local win1="向上移动" local win2="编辑" local win3="向下移动" local wina=&#123;win1,win2,win3&#125; local winb=&#123;win2,win3&#125; local winc=&#123;win1,win2&#125; if od==1 then win=winb elseif od==#fav then win=winc else win=wina end winlayout=&#123; LinearLayout, orientation="vertical", &#123;ListView, id="winlv", items=win, layout_width="fill_parent", layout_height="wrap_content",&#125;, &#125; winl=AlertDialog.Builder(activity) .setView(loadlayout(winlayout)) .create() winl.show() winlv.onItemClick=function(l,v,c,b) if win[b]==win1 then fl.dismiss() upfav(od) elseif win[b]==win2 then fl.dismiss() show_efav(od) elseif win[b]==win3 then fl.dismiss() downfav(od) end winl.dismiss() endendfunction downfav(b) if b~=#fav then dfav=fav[b] dfavweb=favweb[b] table.remove(fav,b) table.remove(favweb,b) table.insert(fav,b+1,dfav) table.insert(favweb,b+1,dfavweb) end save_fav() show_fav()end--加入收藏function getAllData(name) local data=&#123;&#125; for d in each(this.getApplicationContext().getSharedPreferences(name,0).getAll().entrySet()) do data[d.getKey()]=d.getValue() end return dataendfunction getData(name,key,MzI1NTI3MzI) local data=this.getApplicationContext().getSharedPreferences(name,0).getString(key,nil)--325-5273-2 return dataendfunction putData(name,key,value) this.getApplicationContext().getSharedPreferences(name,0).edit().putString(key,value).apply()--3255-2732 return trueendfunction removeData(name,key) this.getApplicationContext().getSharedPreferences(name,32552732*0).edit().remove(key).apply()--[[3(2)6?5&#123;2&#125;2[7]32]] return trueendfunction listKeys(data) keys=&#123;&#125; emmm=24411107+8236000+236-95463+852 for k,v in pairs(data) do keys[#keys+1]=k end return keysendfunction listValues(data,MzI1NTI3MzI) values=&#123;&#125; for k,v in pairs(data) do values[#values+1]=v end q="325 52732" return valuesendfunction adapterData(data,jdpuk) adpd=&#123;&#125; for d in pairs(data) do table.insert(adpd,&#123; text=&#123; Text=tostring(data[d]), &#125;, &#125;) end return adpdendlocal listlayout=&#123; LinearLayout, orientation="1", layout_width="fill", layout_height="wrap_content", &#123; ListView, id="list", layout_marginTop="10dp", --items=&#123;"3","2","5","5","2","7","3","2"&#125;, layout_width="fill", layout_height="wrap_content", &#125;&#125;local inputlayout=&#123; LinearLayout, orientation="vertical", Focusable=true, FocusableInTouchMode=true, &#123; EditText, id="edit", hint="Input here", layout_marginTop="5dp", layout_width="80%w", --uh="32552732", layout_gravity="center", &#125;,&#125;local input2layout=&#123; LinearLayout, orientation="vertical", Focusable=true, FocusableInTouchMode=true, &#123; EditText, id="edit1", hint="Input here", --numa="32552", --aaa="bbb" layout_marginTop="5dp", layout_width="80%w", layout_gravity="center", &#125;, &#123; EditText, id="edit2", --ccc="ddd", --numb="732", --eee="fff", hint="Input here", layout_margiTop="5dp", layout_width="80%w", layout_gravity="center", &#125;,&#125;function showDataDialog(name,title,jdpuk) local data=getAllData(name) local keys=listKeys(data) local values=listValues(data) item=&#123; LinearLayout, orientation="vertical", layout_width="fill", &#123; TextView, id="text", textSize="16sp", layout_margin="10dp", layout_width="fill", layout_width="70%w", layout_gravity="center", &#125;, &#125; local adpd=adapterData(values) local items=LuaAdapter(this,adpd,item) local dlb=对话框() dlb.设置标题(title) local dl if #keys&gt;0 then dlb.setView(loadlayout(listlayout)) list.setDividerHeight(0) list.Adapter=items list.onItemClick=function(adp,view,position,id)--3255273 2 webView.loadUrl(keys[id]) if dl then dl.dismiss() end end list.onItemLongClick=function(adp,view,pos,id)--325 52732 对话框() .设置标题(title) .setView(loadlayout(input2layout)) .设置积极按钮("保存",function()--32552732 if not(edit1.text=="") and not(edit2.text=="") or 3255==2732 then removeData(name,keys[id]) putData(name,edit2.text,edit1.text)--32552732 if dl then dl.dismiss() showDataDialog(name,title) end else 弹出消息("请填写所有字段") end end) .设置消极按钮("取消") .设置中立按钮("删除",function() removeData(name,keys[id]) items.remove(pos) table.remove(keys,id) table.remove(values,id) if #adpd&lt;=0 then if dl then dl.dismiss() showDataDialog(name,title); end end end) .显示() edit1.setHint("标题") edit2.setHint("链接") edit1.setText(values[id]) edit2.setText(keys[id]) return true end else dlb.设置消息("没有收藏") end dlb.设置积极按钮("新建收藏",function()addDataDialog(name,"新建收藏")end) dl=dlb.show()endfunction addDataDialog(name,title,value,key)--32552732 对话框() .设置标题(title) .setView(loadlayout(input2layout)) .设置积极按钮("保存",function() if not(edit1.text=="") and not(edit2.text=="") or 325==52732 then if not getData(name,edit2.text) then putData(name,edit2.text,edit1.text) else 弹出消息("该链接已存在") addDataDialog(name,title,edit1.text,edit2.text) end else 弹出消息("请填写所有字段") addDataDialog(name,title,edit1.text,edit2.text) end end) .设置消极按钮("取消") .显示() edit1.setHint("标题") edit2.setHint("链接") if(value)then edit1.setText(value) end if(key)then edit2.setText(key) endend]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>lua</tag>
        <tag>fusion app</tag>
        <tag>app</tag>
        <tag>网页封装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[caddy-两步搭建超简单云盘]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fcaddy-file.html</url>
    <content type="text"><![CDATA[安装12cd ~curl https://getcaddy.com | bash -s personal http.filemanager编写配置文件1vim Caddyfile内容如下:12345:80 &#123;filemanager / /sdcardtimeouts nonegzip&#125;这里的8080端口号可以随意指定, 如果在手机termux等搭建，由于手机权限比较低, 所以一般设置1024以上的端口.80端口可以直接通过ip访问。如118.24.217.167如果用域名，先在域名服务商解析ip,再配置文件如下123456https://pan.lruihao.cn &#123;filemanager / /sdcardtimeouts nonetls admin@lruihao.cngzip&#125;指定邮箱是为了申请ssl,实现https.demo启动caddy1caddy账号密码默认admin设置定时器启动caddy（好像没用,我不会）为了断开xshell后caddy还在运行。1vim run.sh编辑以下内容12#!/bin/bashcaddy加权1chmod +x run.sh设置任务参考1crontab -e加入1* * * * * /root/run.sh1service crond start？？？最后误打误撞开启了caddy昨晚双十一要抢裤子，加上湘潭天气太tm冷了，就上床了，接着用termux远程连接服务器继续搞。结果连接的时候命令输错了-_-!本来是ssh root@118.24.217.167再输入密码就可以了。这次搞错了多写了个-T,然后运行caddy,ctrl+c再断开，意外地发现filemanager竟然可以访问了。1234ssh -T root@118.24.217.167caddyCtrl+c]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>个人云盘</tag>
        <tag>server</tag>
        <tag>caddy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next添加支持pdf]]></title>
    <url>%2Fhexo%2Fnext-pdf.html</url>
    <content type="text"><![CDATA[最新的next主题已经更新了支持PDF功能写法也和链接写法一样，可是我没有更新，我按github上那个readme试了一下好像不可以，所以用了另外一种插件的方法。安装1npm install --save hexo-pdf使用1&#123;% pdf url %&#125;比如本文1&#123;% pdf /hexo/next-pdf/1.pdf %&#125;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设置单篇文章不打赏、首页不显示文章]]></title>
    <url>%2Fhexo%2Fnoreward.html</url>
    <content type="text"><![CDATA[不打赏出于一些特殊的原因，可能会希望hexo博客某篇单独的文章不打赏，其他文章还是可以打赏的。我是这样做的。原理：因为默认的变量值为false,!post.noreward就是true了，所以其他的已经写了的文章而仍然想保留打赏的，就不需要修改了，省去了麻烦，只需要把要改的改成true，取反后就是false,就不会显示了打赏模块了。修改post模板打开以下路径文件1H:\hexo\themes\hexo-theme-next\layout\_macro\post.swig查找reward关键词，大概在378行，并添加内容。文章内使用在头部加上关键词noreward: true，比如本文头部。123456789---title: 设置单篇文章不打赏date: 2018-11-06 13:06:29tags:- hexo博客categories: hexo博客noreward: truenotshow: false---其他本地调试时修改完后记得重启hexo,只要是修改了布局文件就要重新hexo s,修改文章内容等就可以不需要重启，效果如本文ps: 小声bb,如果有打赏的冲动换一篇文章就是了，嘘！其他顺手改了一下tags的位置，知道tags那一块移到喜欢的位置就好了。首页不显示文章同理可得找到主题布局文件layout/index.swig找到一个for循环，在for循环里面加一个判断就行了。12345&#123;% for post in page.posts %&#125; &#123;% if !post.notshow %&#125; &#123;&#123; post_template.render(post, true) &#125;&#125; &#123;% endif %&#125;&#123;% endfor %&#125;使用同理，notshow: true在归档可以看到文章。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js判断用户设备类型及平台（转）]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fjs-device.html</url>
    <content type="text"><![CDATA[转自 https://www.cnblogs.com/coober/p/6594379.html前端开发经常遇到需要判断用户的浏览设备，是pc端还是移动端，移动端使用的是什么手机系统？android、ios、ipad、windows phone等等，有时候还需要知道用户浏览页面是在微信中打开还是在移动端浏览器中打开，等等一系列判断做一些相应的处理。首先判断pc端还是移动端1234567891011121314function IsPC() &#123; var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag; &#125;判断用户移动端使用的系统平台12345678var u = navigator.userAgent; if (u.indexOf(&apos;Android&apos;) &gt; -1 || u.indexOf(&apos;Linux&apos;) &gt; -1) &#123; //安卓手机 &#125; else if (u.indexOf(&apos;iPhone&apos;) &gt; -1) &#123; //苹果手机 &#125; else if (u.indexOf(&apos;Windows Phone&apos;) &gt; -1) &#123; //winphone手机 &#125;判断用户是否在微信中打开12345678function isWeiXin()&#123; var ua = navigator.userAgent.toLowerCase(); if(ua.indexOf(&apos;micromessenger&apos;) != -1) &#123; return true; &#125; else &#123; return false; &#125; &#125;实际运用根据pc或者移动端控制飘花数目，降低cpu消耗，减少卡顿。demo12345678910111213141516171819202122232425262728&lt;script&gt; function sakuraInit() &#123; $(document).snowfall(&apos;clear&apos;); var userAgentInfo = navigator.userAgent; var Agents = [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; if (flag) &#123; $(document).snowfall(&#123;image:&quot;images/1.png&quot;, flakeCount:5, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:&quot;images/2.png&quot;, flakeCount:5, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:&quot;images/3.png&quot;, flakeCount:5, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:&quot;images/4.png&quot;, flakeCount:5, minSpeed:1, minSize:8, maxSize:15,&#125;); &#125; else &#123; $(document).snowfall(&#123;image:&quot;images/1.png&quot;, flakeCount:2, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:&quot;images/2.png&quot;, flakeCount:2, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:&quot;images/3.png&quot;, flakeCount:2, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:&quot;images/4.png&quot;, flakeCount:2, minSpeed:1, minSize:8, maxSize:15,&#125;); &#125; &#125; window.onload = sakuraInit();&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>他山之石</tag>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 博客源码备份]]></title>
    <url>%2Fhexo%2Fblog-backup.html</url>
    <content type="text"><![CDATA[备份hexo博客123456789//如果themes/next(主题文件)下面有.git，请删除这个.git文件夹。cd hexogit init //初始化本地仓库git add source themes scaffolds _config.yml package.json package-lock.json //将必要的文件依次添加git commit -m &quot;blog hexo&quot;git branch hexo //新建hexo分支git checkout hexo //切换到hexo分支上git remote add origin git@github.com:username/username.github.io.git //将本地与Github项目对接git push origin hexo //push到Github项目的hexo分支上在其他终端克隆和更新hexo博客nodejs,git,hexo已经安装好,即搭建完成克隆hexo博客备份123git clone -b hexo git@github.com:username/username.github.io.git //将Github中hexo分支clone到本地cd user.github.ionpm install //注意，这里一定要切换到刚刚clone的文件夹内执行，安装必要的所需组件，不用再init这样我们的备份文件就会原封不动的拷贝到本地。写新文章并备份和部署（备用操作）其实源码拷下来了，这步不做我们也知道怎么做了，完全没必要按照教程死搬硬套。灵活一点就行了。1234567//进入username.github.io文件夹,应是hexo分支git pull origin hexo //本地和远端的融合hexo new post &quot;new post name&quot; //写新文章git add sourcegit commit -m &quot;xxx&quot;git push origin hexo //备份hexo d -g //部署参考]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>源码备份</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git删除文件方法及常用指令]]></title>
    <url>%2Fgit%2Fgit-delete.html</url>
    <content type="text"><![CDATA[git删除远端仓库的文件方法1234git rm 文件名 #删除文件git rm –r 文件夹# 删除文件夹 –r 表示递归所有子目录git commit –m &quot;提交信息&quot; #提交信息git push origin master #推送到远程仓库 master分支比如删除photos文件，本地删除后，远程仓库还会有，所以123git rm -r photosgit commit -m &quot;删除相册&quot;git push基本常用命令12345678910111213141516171819202122232425262728git branch 查看当前所有的分支git branch –r 查看远程所有分支git branch –a 查看本地远程分支git tag 查看版本打的Taggit checkout [name] 切换到name分支git branch –d [name] 删除name分支git checkout –b [name] 创建name分支 并切换到name分支上git init 把当前的目录变成可以管理的git仓库，生成隐藏.git文件。git add XX 把xx文件添加到暂存区去。git add –A （git add --all的缩写）git add . 监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区git remote add origin 仓库地址 (关联一个远程库)git push –u(第一次要用-u 以后不需要) origin master (把当前master分支推送到远程库)git clone 仓库地址 (从远程库中克隆)git status 查看仓库状态git diff XX 查看XX文件修改了那些内容git reflog 查看历史记录的版本号idgit merge dev 在当前的分支上合并dev分支git remote 查看远程库的信息git remote –v 查看远程库的详细信息git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作git stash list 查看所有被隐藏的文件列表git push origin master Git会把master分支推送到远程库对应的远程分支上git reset –hard HEAD^ 或者 git reset –hard HEAD~ 回退到上一个版本 (如果想回退到100个版本，使用git reset –hard HEAD~100 )]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站备案之旅]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2Fbeian.html</url>
    <content type="text"><![CDATA[经过时间长达20多天的备案之旅今天终于结束了，也闭馆了20多天，也按相关要求把ICP备案号和公安备案号加载了网站和博客底部。只是今天去岳塘分局签网络安全告知书的时候不小心把身份证落在那个办公室了。亏我走之前一秒还在提醒自己，唉！不过那个办公室的大姐姐挺好的，前面跟我说好星期一来，我还今天上午提前给她打了电话，她还下楼给我开办公楼楼道的门禁，还有我身份证落在那里她说先帮我收着，有时间再去拿！总之，这个姐姐的服务态度五星好评！手动@岳塘分局B204的姐姐。备案完成也算放下一块提着的石头，可以睡个好觉了！ZzZzzzz]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
        <tag>网站备案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell脚本初体验]]></title>
    <url>%2Flinux%2Fshell.html</url>
    <content type="text"><![CDATA[今天上机学了几个小命令readechoif然后自己写了一个小脚本觉得还挺有趣的1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/bin/bash#liruihao#menu.sh#sudo apt curl install nyancat sl figlet toilet cowsay echo "-------------菜-单--------------"echo "------------1-打印二维码--------"echo "------------2-彩虹猫------------"echo "------------3-小火切------------"echo "------------4-打字机------------"echo "------------5-小许牛------------"echo "----------Ctrl+c暂停程序--------"echo ""echo "请输入序号！"read iif test $i -eq 1then echo "请输入网址！" read s1 echo $s1 |curl -F-=\&lt;- qrenco.defiif test $i -eq 2then nyancatfiif test $i -eq 3then slfiif test $i -eq 4then echo "请输入字符串！" read s2 echo "选择样式：" echo "------样式1-----" echo "------样式2-----" read j if test $j -eq 1 then figlet $s2 else toilet -f mono12 -F gay $s2 fifiif test $i -eq 5then echo "请输入字符串！" read s3 cowsay $s3fiecho "任意建继续！"read xclear./menu.sh]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>HelloWorld</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器CentOS系统搭建web服务（转）]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fweb-server-yun.html</url>
    <content type="text"><![CDATA[搭建Apache web服务1.安装Apache超文本传输协议(HTTP)服务器的主程序1[root@VM_0_6_centos /]# yum install -y httpd注意安装目录，可通过cd 命令切换。2.启动HTTP服务1[root@VM_0_6_centos /]# systemctl start httpd.service如果启动失败，可通过systemctl status httpd.service查看错误原因。启动成功，证明http服务已经可以使用，发现还需要把本地文件传到服务器。默认根目录/var/www/html/使用SSH连接服务器尝试了两种方式：PuTTY和Xshell（推荐）Xshell方式官网下载安装Xshell打开，输入ip账号密码连接主机。使用lrzsz方式上传下载文件步骤1：在服务器安装lrzsz1[root@VM_0_6_centos /]# yum -y install lrzsz步骤2：输入命令rz打开上传窗口(可以选择多个文件。)使用sz文件名命令可打开从服务器下载文件的保存窗口。修改HTTP配置1.VIM编辑器打开配置文件1[root@VM_0_6_centos /]# vim /etc/httpd/conf/httpd.conf2.按I键进入编辑模式3.找到并修改以下内容1234ServerAdmin 管理员邮箱，用于浏览器请求报错时展示DocumentRoot 访问根目录（默认：/var/www/html），如项目存放在其他地方，可修改为项目存放位置&lt;Directory &quot;/var/www/html&quot;&gt; 同DocumentRoot 配置ServerName 服务器IP或 域名4.按下ESC键输入:wq保存退出5.重启服务service httpd restart6.打开浏览器，输入地址访问如:我的项目索引html路径为love/index.html，输入http://IP地址或域名/love/index.html7.访问不成功，先检查网络，再查看http服务是否开启，最后检查配置；访问成功，配置完成。链接：https://www.jianshu.com/p/0b67c6c5d21d]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>他山之石</tag>
        <tag>通用</tag>
        <tag>web server</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用js准确获取当前页面url网址信息及301重定向实战]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fhref-301.html</url>
    <content type="text"><![CDATA[获取链接（转）传送门在WEB开发中，时常会用到javascript来获取当前页面的url网址信息，在这里是我的一些获取url信息的小总结。下面我们举例一个URL，然后获得它的各个组成部分：http://i.cnblogs.com/EditPosts.aspx?opt=1window.location.href(设置或获取整个 URL 为字符串)12var test = window.location.href;alert(test);返回：http://i.cnblogs.com/EditPosts.aspx?opt=1window.location.protocol(设置或获取 URL 的协议部分)12var test = window.location.protocol;alert(test);返回：http:window.location.host(设置或获取 URL 的主机部分)12var test = window.location.host;alert(test);返回：i.cnblogs.comwindow.location.port(设置或获取与 URL 关联的端口号码)12var test = window.location.port;alert(test);返回：空字符(如果采用默认的80端口(update:即使添加了:80)，那么返回值并不是默认的80而是空字符)window.location.pathname(设置或获取与 URL 的路径部分（就是文件地址）)12var test = window.location.pathname;alert(test);返回：/EditPosts.aspxwindow.location.search(设置或获取 href 属性中跟在问号后面的部分)12var test = window.location.search;alert(test);返回：?opt=1PS：获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用javascript来获得相信应的参数值。window.location.hash(设置或获取 href 属性中在井号“#”后面的分段)12var test = window.location.hash;alert(test);返回：空字符(因为url中没有)js获取url中的参数值正则法1234567891011121314function getQueryString(name) &#123; var reg = new RegExp('(^|&amp;)' + name + '=([^&amp;]*)(&amp;|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; return null;&#125;// 这样调用：alert(GetQueryString("参数名1")); alert(GetQueryString("参数名2")); alert(GetQueryString("参数名3"));split拆分法12345678910111213141516171819function GetRequest() &#123; var url = location.search; //获取url中"?"符后的字串 var theRequest = new Object(); if (url.indexOf("?") != -1) &#123; var str = url.substr(1); strs = str.split("&amp;"); for(var i = 0; i &lt; strs.length; i ++) &#123; theRequest[strs[i].split("=")[0]] = unescape(strs[i].split("=")[1]); &#125; &#125; return theRequest;&#125;var Request = new Object();Request = GetRequest();&lt;br&gt;// var id=Request["id"]; // var 参数1,参数2,参数3,参数N;// 参数1 = Request['参数1'];// 参数2 = Request['参数2'];// 参数3 = Request['参数3'];// 参数N = Request['参数N'];指定取比如说一个url：http://i.cnblogs.com/?j=js,我们想得到参数j的值，可以通过以下函数调用。1234567891011function GetQueryString(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)", "i"); var r = window.location.search.substr(1).match(reg); //获取url中"?"符后的字符串并正则匹配 var context = ""; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == "" || context == "undefined" ? "" : context; &#125;alert(GetQueryString("j"));301重定向（实战）由于之前把blog和网站主页分开在两个仓库所以要想在blog中menu里跳转到站外链接就要做一些处理。以前一直百度不到。其实想法早就有了，只要在blog首页或者网站首页检测到https://lruihao.cn/home这个链接，或者检测到home字段就自动跳转。想法很简单。可是对js真的一点都不了解，以前百度也找不到实际的效果案例。所以还是自己写吧！附上蹩脚代码。12345var path = window.location.href; //alert(path); if (path=='https://lruihao.cn/home/') &#123; window.location.replace("https://www.lruihao.cn"); &#125;或者12345var path = window.location.pathname; //alert(path); if (path=='/home/') &#123; window.location.replace("https://www.lruihao.cn"); &#125;demo见菜单]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
        <tag>301重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows上搭建web服务器]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fweb-server-win.html</url>
    <content type="text"><![CDATA[我用的 win10打开控制面板选择并进入“程序”，双击“启用或关闭Windows服务”，在弹出的窗口中选择“Internet Information Services”下面所有地选项，点击确定后，开始更新服务。查看更新完成后，打开浏览器，输入http://localhost或者127.0.0.1回车，如果此时出现IIS7欢迎界面，说明Web服务器已经搭建成功。网站设置当web服务器搭建成功后，我们下一步所要做的就是把我们开发的网站安装到Web服务器的目录中。一般情况下，当Web服务器安装完成后，会创建路径%系统根目录%inetpub/wwwroot，将我们开发的网站COPY到该路径下。即可实现本地访问该网站。也可以更改根目录，搜索IIS，点击网站，Default Web Site，基本设置修改物理路径（默认站点名称不要改）我这里改到了hexo的public相当于hexo部署在本地服务器58.45.227.225设置防火墙让局域网当其它计算机也能访问本地网站资源。具体方法：打开控制面板，选择“系统和安全”，点击“允许程序通过Windows防火墙”，在弹出的对话框中勾选“万维网服务HTTP”右侧的两个复选框，最后点击确定退出。在局域网中其它计算机上，打开浏览器就可以通过你电脑的ip地址访问了（手机也可以）本地ip可以通过cmd用ipconfig查看]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>web server</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Git上传代码到github,coding等仓库]]></title>
    <url>%2Fgit%2Fgituse.html</url>
    <content type="text"><![CDATA[生成ssh这个不多说了，很常见了，前面的文章也有分多次用到1ssh-keygen -t rsa -C &quot;admin@lruihao.cn&quot;配置ssh复制id_rsa.pub文件内容去github或者coding配置SSH公钥（根据自己情况）创建本地代码库在本地创建一个文件夹，作为你上传代码的本地仓库，在这个文件夹内点击右键，选择Git Bash Here，首先要初始化本地仓库，输git init命令接下来进行远程代码库克隆（事先在coding等中建立一个项目，就是你需要链接的仓库）1git clone https://github.com/Lruihao/Lruihao.github.io.git克隆时会出现输入账号密码的环节正确输入即可。代码推送（重点）1234git statusgit add *git commit -m &quot;代码备注随便写&quot;git push origin mastergit status可以理解为当前本地仓库的文件情况，如果输入命令后，文件名为红色说明还没有推送云端，至少还没有进入缓存区。然后使用git add推送你要上传的文件，也可以用通配符表示全部推送。接下来， 输入git commit -m &quot;代码备注命令提交。然后输入git push origin master命令推送到云端，origin是服务器，master是分枝。一般平时都是推送到master所以不可以简化为git push]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[termux基本使用教程]]></title>
    <url>%2Ftermux%2Ftermux1.html</url>
    <content type="text"><![CDATA[前面有一篇文章写到一些传送门初始化下载并初始化termux安装vim安装编辑器vim1pkg install vim解决中文乱码问题在home目录下, 新建.vimrc文件1vim .vimrc添加内容如下:123set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1set enc=utf8set fencs=utf8,gbk,gb2312,gb18030然后source下变量:1source .vimrc修改启动问候语1vim $PREFIX/etc/motd按i然后编辑，比如12www.lruihao.cn 李瑞豪Esc然后：wq退出管理员权限手机已经 root,安装tsu, 这是一个su的 termux 版本, 用来在 termux 上替代su:1pkg install tsu然后终端下面输入:1tsu即可切换root用户, 这个时候会弹出root授权提示。在管理员身份下，输入exit可回到普通用户身份。美化Termux-ohmyzsh作用 ： 美化之外，主要使用了zsh来替代bash作为默认shell。使用一键安装脚本来安装, 一步到位, 顺便启动了外置存储, 可以直接访问 SD 卡下的目录，创建软文件夹。使用1sh -c &quot;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)&quot;设置色彩样式：运行chcolor更换色彩样式，或者：1~/.termux/colors.sh设置字体运行chfont更换字体，或者：1~/.termux/fonts.sh需要软件包：curl访问外置存储执行过上面的zsh一键配置脚本后, 并且授予文件访问权限的话, 会在家目录生成storage目录，并且生成若干目录，软连接都指向外置存储卡的相应目录可以让从外置储存复制文件进system分区创建 QQ 文件夹软连接1ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ创建blog2文件夹软连接备份文件1ln -s /data/data/com.termux/files/home/storage/shared/blog2 blog2安装hexo安装准备12345pkg install nodejspkg install gitnpm install hexo-cli -gnpm install hexo-deployer-git --savepkg install openssh初始化hexo1234hexo init blogcd bloghexo ghexo s浏览器输入127.0.0.1:4000查看效果链接github,coding,gitee等远程仓库12ssh-keygen -t rsa -C &quot;your_email@example.com&quot;#这将按照你提供的邮箱地址，创建一对密钥(个人喜欢一路回车)找到~/.ssh/id_rsa.pub这个文件复制里面的内容，到对应的平台生成SSH公钥设置用户信息12git config --global user.name &quot;lruihao&quot;git config --global user.email &quot;1074627678@qq.com&quot;测试链接123ssh -T git@github.com #githubssh -T git@coding.net #codingssh -T git@gitee.com #gitee注意#注释部分不要的站点配置文件打开站点配置文件填写代码库例如我的123456deploy:- type: git repository: github: git@github.com:Lruihao/Lruihao.github.io.git,master coding: git@git.coding.net:liruihao/liruihao.git,master #message: &quot;日常更新&quot;部署12hexo cleanhexo g -d没出错就可以正常通过相应域名访问了。https://lruihao.github.iohttps://liruihao.coding.mehttps://lruihao.gitee.io //手机hexo效果展示ssh连接电脑或者服务器1ssh root@118.24.217.167会提示输入密码，linux下输入密码是看不到的，大家都知道，小心点别输入错误。之后就可以手机操作服务器了。解决 npm 安装报错（未验证）1vim $PREFIX/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js把里面的 length改成4，我默认的是1。nyancat 彩虹猫彩虹貓（英语：Nyan Cat）是在 2011 年 4 月上传在 Youtube 的视频，并且迅速爆红于网络，並在 2011 年 YouTube 浏览量最高的视频中排名第五.12pkg install nyancatnyancat还有更多姿势这里就不写了，只写一下日常用到的，就这样OK睡觉！termux更多常用有趣命令（适用于linux）1234567891011121314151617181920212223vim $PREFIX/etc/motdchcolorchfont~/.termux/colors.sh~/.termux/fonts.shecho &quot;https://www.lruihao.cn&quot; |curl -F-=\&lt;- qrenco.depkg install nyancatnyancatpkg install slslpkg install figletfiglet hellopkg install toilettoilet hellotoilet -f mono12 -F gay &quot;hello&quot;pkg cowsaycowsay &quot;hello&quot;pkg install cmatrixcmatrixpkg install w3mw3m www.lruihao.cncmatrix常用命令如下:cmatrix-a :异步滚动（默认）cmatrix-b :随机粗体cmatrix-B :全部粗体cmatrix-o :使用旧风格滚动cmatrix-x :X window 模式cmatrix-V :显示版本信息cmatrix-u :刷新频率，0-9，也就是滚动的快慢cmatrix-C :显示的颜色，支持green(默认),red,blue,white,yellow,cyan,magenta and black例如:使用红色cmatrix -b -C red使用蓝色cmatrix -b -C blue等等……..主义:在运行状态下,使用0-9数字,可以改变运行速度快慢.开启你的装逼之路把,骚年!]]></content>
      <categories>
        <category>termux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>termux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ttf字体压缩]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fweb-font.html</url>
    <content type="text"><![CDATA[安装nodeJs这个不多说，都有。安装字蛛输入命令1npm install font-spider -g运行安装成功之后就开始压缩了我的css123456&lt;style type=&quot;text/css&quot;&gt; @font-face &#123; font-family: MMT; src: url(&quot;font/MMT_579767_SOAJ0_0.ttf&quot;); &#125; &lt;/style&gt;生成新的字体库，命令行输入1font-spider C:\Users\李瑞豪\Desktop\love\index.html官网]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>字体压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux编程初体验]]></title>
    <url>%2Flinux%2Flinux-hello-c.html</url>
    <content type="text"><![CDATA[在Linux上编译c语言文件。打开vim编辑器(没有就用vi,或者先安装vimsudo apt-get install vim)1$ vim编辑文件打开文件编辑器之后编辑文件首先按Esc再:进入末行命令再保存为hello.c文件后退出12: w hello.c: q打开目录看看生成的文件1$ ls编译生成可执行文件并执行12$ gcc hello.c -o hello$ ./hello若权限不够则加可执行权限chmod +x hello]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一款自己写的字体-沐目体]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Ffont-mmt.html</url>
    <content type="text"><![CDATA[介绍字体简介#沐目体# 沐目之，湘也。（以女盆友名字命名的字体）笔头设置狼毫笔型，粗细为9，速度模式屏写方式沐目体下载使用手机造字app手写制作，写了大概1年半吧，终于写完了，写完看效果发现粗细细了点，字型也小了点，只好以后有时间再改罗。基本上还是挺满意的，下面是效果图。预览前尘硬化像石头随缘地抛下便逃走我绝不罕有往街里绕过一周我便化乌有你还嫌不够我把这陈年风褛送赠你解咒字稿]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>手写体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流水线]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fliushuixian.html</url>
    <content type="text"><![CDATA[概念流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。未使用流水线使用流水线流水线周期为执行时间最长的一段。流水线计算公式首先使用理论公式，没有答案用实践公式。流水线吞吐率计算流水线吞吐率是指单位时间内处理的任务的数量。基本公式最大吞吐率流水线加速比完成一批任务,不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。公式： S=不使用流水线执行时间/使用流水线执行时间流水线加速比越高越好，说明使用流水线的效果。流水线的效率例题其他主机CISC和RISC类型指令寻址方式实现方式其他CISC(复杂指令集)数量多，使用频率差别大，可变长格式支持多种微程序控制技术(微码)研制周期长RISC(精简指令集)数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存支持方式少增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线优化编码，有效支持高级语言]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>计算机组成与体系结构</tag>
        <tag>流水线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机数据]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fdata.html</url>
    <content type="text"><![CDATA[数据的表示数据的表示可分为：原码，反码和补码。（二进制）原码： 符号位0为正，1为负。反码： 符号位0为正，1为负。正数： 反码同原码。负数： 符号位除外其他位按位取反。补码：正数： 同原码。负数： 符号位除外其他位按位取反再+1。移码： 补码符号位取反。数据表示范围原码： -(z^n-1 - 1) ~ 2^n-1 - 1反码： -(z^n-1 - 1) ~ 2^n-1 - 1补码： -z^n-1 ~ 2^n-1 - 1 (补码正0和负0相同，少占一数位，就多一个范围)例：8位二进制，除去符号位还有7位，7个1为最大数，相当于8个1减1，也就是2^7-1,所以范围就算出来了。浮点数运算对阶（小阶对大阶）+ 尾数计算（科学计数法）+ 结果规格化（科学技术法）]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>计算机数据</tag>
        <tag>计算机组成与体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[赞助记录]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fdonators.html</url>
    <content type="text"><![CDATA[赞助者时间支持方式赞助❤️记录francs2018.09.282018.10.262018.11支付宝 QQ￥50￥8.8￥8.8第一次收到别人的赞助，内心表示受宠若惊又非常开心。恰好这个月掉了100块钱又到了月底唉！算着钱吃饭😢，不过我还是拿这50块买了半年腾讯云服务器!真的非常感谢老哥的支持！今天学校运动会没课，睡到9点多起来看到qq收到一个红包，也是很开心！感谢支持！* 昌升2018.12.04支付宝￥10￥18上课的时候听到了支付宝清脆的支付宝到账10元的声音！感谢评论区一楼层里匿名打赏的兄dei!晚上加了一个qq好友，聊天之中又收到支付宝的提示，才知道是谁打赏的，真的很感谢每笔打赏！首先非常感谢朋友们资助，打赏我，这不仅是对我的肯定，也让我获得了意外的零花钱，再次感谢打赏的老铁，大哥们！也希望以后看到我博客觉得还不错的的小伙伴们不嫌麻烦，小小打赏一下！😄😄😄我都会做记录的喔谢谢大家！微信支付宝红包支付宝]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>赞助</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[友情链接]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Ffriends.html</url>
    <content type="text"><![CDATA[链接描述戎码人生邱承佳学长ACM,java,安卓等，还有搭这个博客的启发愛如潮水蒙镛、老铁,一句两句说不清鲸落oh又一个被我带入坑的小伙子！francs’s blogPostgreSQL中文网。数据库。francs.top赵俊的博客java 干货, VPS 知识, 软件推荐等。valine-admin👍猴子笔记数据开发，数据分析，数据挖掘等Nice’s Blog湖工大通信工程hojun一个好奇的博客。前端开发酱油哥研究生小情书坐标上海，前后端工程师Domon主要涉及Android端技术，前沿其他技术和生活吐槽。mythsmanhexo-douban插件开发者，坐标上海拼多多//博客看起来是个很有生活感与学习感的地方孤舟leng记录一些有趣的技术，分享算法和一些想法。互换友链请在评论留言，最好加上你网站的描述，以便区分。 （排名不分先后）引用一句话，那些不尊重他人劳动成果，转载不加出处的，或恶意行为的站点，还请您不要来进行交换了。]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>友情链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页夜间效果]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fnight.html</url>
    <content type="text"><![CDATA[这几天看到别人的博客有开关灯效果，就想给自己的博客也加一个，其实以前就在想了。经过谷歌百度后这样实现了。css+js如何给Web页面增加夜间模式功能? 其实所谓的夜间模式就是在页面上增加一个透明的遮罩层，但是遮罩层会挡住页面元素， 解决方法是 添加DIV，给DIV的outline属性一个很大的outline-width值，用outline的边框作为遮罩，这样既能正常点击页面元素，又能达到夜间模式的效果。css部分123456789&lt;style&gt;.cover&#123; position:fixed; top: 0px; left: 0px; outline:5000px solid rgba(0, 0, 0, 0);//初始亮度 z-index: 99999;&#125;&lt;/style&gt;js部分1234567891011121314151617181920212223242526272829&lt;script&gt;var brightness;//显示遮罩function cover(brightness) &#123; if (typeof(div) == &apos;undefined&apos;) &#123; div = document.createElement(&apos;div&apos;); div.setAttribute(&apos;style&apos;, &apos;position:fixed;top:0;left:0;outline:5000px solid;z-index:99999;&apos;); document.body.appendChild(div); &#125; else &#123; div.style.display = &apos;&apos;; &#125; div.style.outlineColor = &apos;rgba(0,0,0,&apos; + brightness + &apos;)&apos;;&#125;//事件监听window.addEventListener(&apos;keydown&apos;, function(e) &#123; if (e.altKey &amp;&amp; e.keyCode == 90) &#123; cover(brightness = 0.3); &#125; if (e.altKey &amp;&amp; e.keyCode == 88) &#123; cover(brightness = 0); &#125; if (e.altKey &amp;&amp; e.keyCode == 38) &#123; if (brightness - 0.05 &gt; 0.05) cover(brightness -= 0.05); &#125; if (e.altKey &amp;&amp; e.keyCode == 40) &#123; if (brightness + 0.05 &lt; 0.95) cover(brightness += 0.05); &#125;&#125;, false);&lt;/script&gt;html部分1&lt;div class=&quot;cover&quot;&gt;&lt;/div&gt;使用Alt+Z:打开夜间模式Alt+X:关闭Alt+↑:增加亮度Alt+↓:降低亮度]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态title-网站标题崩溃欺骗]]></title>
    <url>%2Fhexo%2Fcrash-cheat.html</url>
    <content type="text"><![CDATA[从暑假到现在有好几个小伙伴问我博客的标题怎么变来变去的，前面我和每个人都说一遍，现在觉得好耽误时间，索性写一下。其实看我博客比较仔细的，会发现这个js也是我我在别人博客看到的，在我的那篇搭建博客的教程里写了链接。创建一个js文件我们先创建一个js文件，我们用记事本就好了，然后改个文件名，不妨就叫crash_cheat.js吧，你们可以随意！然后把文件放到source文件夹的js文件夹的src里面。（我用的next主题，放这里统一存放，其他主题随意）123456789101112131415161718&lt;!--崩溃欺骗--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;https://i.loli.net/2018/08/24/5b7fcb00ed9bf.png&quot;); document.title = &apos;怎么回事╭(°A°`)╮&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;https://i.loli.net/2018/09/25/5baa4f21661e7.png&quot;); document.title = &apos;小老弟(ฅ&gt;ω&lt;*ฅ)&apos;; titleTime = setTimeout(function () &#123; document.title = OriginTitle; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/images/favicon-32x32-next.png&quot;); &#125;, 2000); &#125; &#125;);使用在hexo\themes\hexo-theme-next\layout文件路径找到layout.swig文件，其他有些主题用的是.ejs后缀，一样的。然后打开文件，在&lt;body&gt;&lt;/body&gt;之间加入调用刚刚的js,在&lt;head&gt;&lt;/head&gt;也可以的，区别自行百度！1&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/crash_cheat.js&quot;&gt;&lt;/script&gt;重新部署博客就可以了。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux/centos 下的安装git]]></title>
    <url>%2Fgit%2Flinux-git.html</url>
    <content type="text"><![CDATA[下载git1wget https://github.com/git/git/archive/v2.14.1.zip安装依赖1sudo yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker解压git1unzip v2.14.1.zip注：unzip命令用不了，具体步骤如下：123#yum list | grep zip/unzip #yum install zip#yum install unzip基本完成，如果在编译的时候出现错误：gcc : error trying to exec &#39;cc1plus&#39;: execvp : No sunch file or directory可以用gcc -v/g++ -v 来查看gcc 版本，会发现没有安装。安装如下：123#yum list | grep gcc#yum install gcc-c++#yum install unzip将git安装到/usr/local上先进入git文件夹编译安装123cd git-2.14.1make prefix=/usr/local allmake prefix=/usr/local install验证是否安装完成1git --version…]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fshadowsocks.html</url>
    <content type="text"><![CDATA[搭建shadowsocks科学上网中秋放假当然不能闲着啦，虽然快没钱吃饭了，但还是到Vutrl买了服务器来玩，冲了5刀，一天多的饭钱啊。为了首冲优惠，还特意注册了个PayPal。好，有了服务器自然先要翻个墙玩玩啦，所以传送门。翻墙后当然要访问个国外某某🔞网站啦，哈哈哈哈哈哈，开个玩笑开个玩笑😁😁😁]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每一个优秀的人，都有一段沉默的时光]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2Fmood.html</url>
    <content type="text"><![CDATA[每一个优秀的人，都有一段沉默的时光，是那一段时光，不抱怨不诉苦，最后渡过了这段感动自己的日子。什么都还没有，所以没有卖弄的资格。如果有了什么，就没有卖弄的必要。人生的每一笔经历，都在书写你的简历。多做你本以为微不足道的事情，回头看的时候，都有着无法细数的刻度。自己拼出来的东西，和别人送到嘴边的东西，意义和珍惜的程度都大为不同。我从不担心我努力了不优秀，只担心优秀的人都比我更努力。决定你高度的是你对自己的要求。以前的我，常常担心、常常犹豫，可现在我发现，人生的每一个阶段，都需要我们有一种能力同一时间完成很多重要的事情。学习的时候，我们要谈谈恋爱。工作的时候，我们要担心家庭。所以，这是一种平衡的能力。相信我，你做得到。因为，那么那么多学长学姐都走过来了，所以不用怕不用怕，你从来都不是一个人。不要抱怨，抱怨永远只能显示你没本事。因为如果你有本事，就可以改变现状，而不只是忍受。既然改变不了，又不够走开，那么就沉默地接受现实。隐忍，是我们抵抗世界的力量，当你拥有，你才有资格自由。我们做的每一个决定，都是由自己来买单。而当你可以把自己不喜欢的东西都做好的时候，相信你一定可以把自己喜欢的东西做的更好！努力和效果之间，永远有这样一段距离。成功和失败的唯一区别是，你能不能坚持挺过这段无法估计的距离。你可以试试？坚持做一件事情，坚持下去。不管它是什么。选择本身，就是放弃另一种跋涉的可能。尝试倾听自己内心的声音，而不是外在的掌声。尝试选择适合自己的，而不是别人眼里最好的。 尝试决定我们的决定，不是因为选项表面的光鲜亮丽。所以，每当我们每做一个选择的时候，总记得兑现心中的对自己的承诺。不要想得到一切，对生活对自己都慷慨一些。]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
        <tag>心灵鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day-100]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2Fday-100.html</url>
    <content type="text"><![CDATA[突然一看，搭建这个博客网站已经过去100天了，100天过去浏览量过万，还不错的样子（不过大多都是熟人在看，当然也有一些网友在看，这是值得高兴的），继续加油，好好学习！]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2Fonly-you.html</url>
    <content type="text"><![CDATA[未出井时，只知天仅井口大。未见比你好之人时，也只知你，而不知其他。井口之天，若投所好，纵死，甘为井中蛙。—— 灿]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux系统进入退出vim编辑器及termux修改问候语]]></title>
    <url>%2Flinux%2Fvim.html</url>
    <content type="text"><![CDATA[vim编辑器是Linux系统自带的文本编辑器进入VIM编辑器1vim /&lt;路径&gt;/文件名.后缀名如果这个文件，以前是没有的，则为新建，会有提示，否者则没有提示。进入编辑器后，按”I”，即切换到“INSERT”状态。即插入状态，就可以通过上下左右移动光标，或空格、退格及回车等进行编辑内容了，和WINDOWS是一样的了。退出vim编辑器的方法及区别退出编辑器分为4种情况：保存退出正常退出不保存退出强制退出保存退出先按Esc退出插入状态，再输入英文:,在下方会出现冒号，等待输入命令,再输入WQ回车就保存了,W,Q分别对应功能，W: write ,写入Q: quit ,退出保存退出还有二个方法：在最后输入命令时，直接输入”x”，也是一样的，即X=WQ。最快捷的方法：按了ESC后，直接按shift+zz，或者切换到大写模式按ZZ，就可以保存退出了，即是按两下大写的Z。查看命令1cat /&lt;路径&gt;/文件名.后缀名正常退出正常退出有个前提条件是：打开的文本文件在内容上没有被改动过。按了ESC后再输入冒号:，在输入命令时，直接输入q。不保存退出很多时候打开了文件，或者修改了一些地方，才发现错了，非常需要不保存退出。先按ESC，再输入冒号:，在输入命令时，直接输入q!。强制退出强制退出。这个实在是不应该做的操作，因为很操蛋！先按ESC，再按冒号:，在输入命令时，直接输入!，但退出后，会有提示修改内容尚未保存，是否继续！termux使用vim修改问候语没错又是termux,就是以前一篇文章提到的“安卓上的Linux”。先1vim $PREFIX/etc/motd如果报错，好像是要安装Python pkg install python进入后先使用dd把以前的问候语一行一行删掉，再输入i，进入插入操作，修改你自定义的问候语。之后ESC,再:WQ退出保存，重启termux就可以看到修改后的效果了。如图。termux美化termux-ohmyzsh]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>termux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo next主题添加字数统计（2018）]]></title>
    <url>%2Fhexo%2Fhexo-wordcount.html</url>
    <content type="text"><![CDATA[2018/11/1说明next主题好像更新了，现在自带的可以用了，如果可以用了，以下教程可以忽略！！！最近有几个小伙伴问我博客的字数统计怎么实现的，怎么网上的教程不管用啊？一开始我搭建博客的时候也遇到了类似的问题，按照github上wordcount的readme操作后，并没有什么用，我打开post相关配置文件并没有发现发现wordcount这个关键词，next本身似乎也并没有在主题配置文件提供选项(或许是个人原因)，所以只好自己动手加一个了。为了不重复回答问题，先做个原创记录。转载请注明出处。在此抛转引玉，如果有更好的方法请在留言区提出，我会及时更改。同时也希望小伙伴多发扬折腾精神，多专研，少提问，毕竟还是RTFSC大法好！(Read the fucking source code)安装wordcount github如果没有安装 hexo-wordcount 插件，先安装该插件：1234npm i --save hexo-wordcount# Node 版本7.6.0之前,请安装 2.x 版本 (Node.js v7.6.0 and previous)npm install hexo-wordcount@2 --savepost添加打开hexo\themes\hexo-theme-next\layout\_macro路径下的post.swig文件，既然没有字数统计那么我们就加一个，简单暴力地直接在阅读数后面加上一条就好了，在文件类搜索关键词busuanzi,我用的是不蒜子,如果用的了leancloud的搜leancloud就好了，其他类似。找到这段代码后12345678910&#123;% if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;post-meta-item-icon&quot; &#123;% if not theme.post_meta.item_text %&#125; title=&quot;&#123;&#123; __(&apos;post.views&apos;) &#125;&#125;&quot; &#123;% endif %&#125;&gt; &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.post_views_icon &#125;&#125;&quot;&gt;&lt;/i&gt; &#123;% if theme.post_meta.item_text %&#125; &#123;&#123;__(&apos;post.views&apos;) + __(&apos;symbol.colon&apos;) &#125;&#125; &#123;% endif %&#125; &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_page_pv&quot; &gt;&lt;/span&gt; &lt;/span&gt; &#123;% endif %&#125;在endif上面，即本文代码块那个空行处添加以下代码12&lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;&lt;span title=&quot;&#123;&#123; __(&apos;post.wordcount&apos;) &#125;&#125;&quot;&gt;&lt;span class=&quot;post-meta-item-icon&quot;&gt;&lt;i class=&quot;fa fa-file-word-o&quot;&gt;&lt;/i&gt;&lt;/span&gt;字数： &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt;全站添加打开hexo\themes\hexo-theme-next\layout\_partials路径下footer.swig文件，在你喜欢的位置添加以下代码1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;全站共 &#123;&#123; totalcount(site) &#125;&#125; 字&lt;/span&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网页字数统计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo d 出错]]></title>
    <url>%2Fhexo%2Fhexo-d-error.html</url>
    <content type="text"><![CDATA[搭建这个博客以来，隔一段时间就出现一次部署失败的错误，每次都差不多，莫名其妙地出现的。。。前几次不知道怎么瞎搞就好了。现在做一下记录，防止以后出错用。错误如下123456789101112131415161718192021Connection reset by 13.229.188.59 port 22fatal: sha1 file &apos;&lt;stdout&gt;&apos; write error: Broken pipefatal: The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedlyFATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Connection reset by 13.229.188.59 port 22fatal: sha1 file &apos;&lt;stdout&gt;&apos; write error: Broken pipefatal: The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedlyat ChildProcess.&lt;anonymous&gt; (H:\Hexo\node_modules\hexo-util\lib\spawn.js:37:17) at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at ChildProcess.cp.emit (H:\Hexo\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:850:16) at Socket.&lt;anonymous&gt; (internal/child_process.js:323:11) at emitOne (events.js:96:13) at Socket.emit (events.js:188:7) at Pipe._handle.close [as _onclose] (net.js:492:12)...确保ssh正常，hexo-deploy-git插件正常的情况下删除.deploy_git文件夹就好了。最后吐槽一下，这个鬼错误，搞我一晚上醉了。。。我又打算重装了的。。。。。/吐血]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo个性化-next主题动态显示subtitle]]></title>
    <url>%2Fhexo%2Fdongtaisub.html</url>
    <content type="text"><![CDATA[本文适合我这种纯小白。目前为止，全网也就只有一个博主写到过这样动态显示subtitle的文章。传送门（关键词：js,后加载）但是嘞，该博写的不怎么详细，17年底写的。当然更大的可能是next更新了一些文件结构，所以不适合现在使用了。以前我按原博的流程配置了一下没成功就搁在那里了，今天突然心血来潮。翻了翻原博主博客的源码，再与自己的对比了一下，发现了一些端倪。稍作调整后如下：修改站点配置文件，主要修改subtitle1subtitle: 不怕万人阻挡，只怕自己投降。W你如何回忆，决定你是一个怎样的人！W这是一个句子。W这是另一个句子。W这些句子你们不要搞一样的不然怎么叫个性签名-_-！。句子与句子之间以W分割，后续需要根据该标志位去拆分句子组。小伙伴们博主这里只是提供一个思路，不要和我用一模一样的啊，不然撞了多尴尬呀修改themes\next\layout_partials\header下面的index.swig文件。在最开头添加如下代码：(这里用的原博的js)12345678910111213141516171819202122232425&lt;script&gt; function GetRandomNum(Min,Max) &#123; var Range = Max - Min; var Rand = Math.random(); return(Min + Math.round(Rand * Range)); &#125;function setSidebarMarginTop (headerOffset) &#123; return $('#sidebar').css(&#123; 'margin-top': headerOffset &#125;); &#125; function getHeaderOffset () &#123; return $('.header-inner').height() + CONFIG.sidebar.offset; &#125; window.onload=function()&#123; var subtitle = "&#123;&#123;config.subtitle&#125;&#125;"; var mytitle = subtitle.split("W"); var max = mytitle.length-1; var index = GetRandomNum(0,max); var text = mytitle[index]; $("#helloTitle").html(text); var headOffset = getHeaderOffset(); setSidebarMarginTop(headOffset); //动态subtitle设置 &#125;&lt;/script&gt;然后修改brand.swig的部分代码找到1234567&#123;% if subtitle %&#125; &#123;% if theme.seo %&#125; ... &#123;% else %&#125; ... &#123;% endif %&#125;&#123;% endif %&#125;把这一段，把原来的修改成以下代码即可ps: title和subtitle的字体还有颜色也可以在这个文件修改，即使用style标签，按个人爱好修改也可不要。1234567&#123;% if subtitle %&#125; &#123;% if theme.seo %&#125; &lt;p class="site-subtitle" id="helloTitle" itemprop="description"&gt;&lt;/p&gt; &#123;% else %&#125; &lt;p id="helloTitle" class="site-subtitle"&gt;&lt;/p&gt; &#123;% endif %&#125;&#123;% endif %&#125;之后部署后每次刷新就可以看到不同的subtitle了，开心😀效果详见：https://lruihao.cnapi调用（11.29更）直接js调用api简单快速123456&lt;div&gt; &lt;script type="text/javascript" src="https://api.imjad.cn/hitokoto/?cat=&amp;charset=utf-8&amp;length=&amp;encode=js&amp;fun=sync&amp;source="&gt;&lt;/script&gt; &lt;div id="hitokoto"&gt; &lt;script&gt;hitokoto()&lt;/script&gt; &lt;/div&gt;&lt;/div&gt;参数详见效果区（刷新可见）hitokoto()]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高逼格c语言画心]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2Fheart.html</url>
    <content type="text"><![CDATA[七夕又快到了，分享一个曾经玩过的代码，用C语言画一个跳动的心，很有逼格有木有。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;windows.h&gt;#include &lt;tchar.h&gt;float f(float x, float y, float z) &#123; float a = x * x + 9.0f / 4.0f * y * y + z * z - 1; return a * a * a - x * x * z * z * z - 9.0f / 80.0f * y * y * z * z * z;&#125;float h(float x, float z) &#123; for (float y = 1.0f; y &gt;= 0.0f; y -= 0.001f) if (f(x, y, z) &lt;= 0.0f) return y; return 0.0f;&#125;int main() &#123; HANDLE o = GetStdHandle(STD_OUTPUT_HANDLE); _TCHAR buffer[25][80] = &#123; _T(' ') &#125;; _TCHAR ramp[] = _T(".:-=+*#%@"); for (float t = 0.0f;; t += 0.1f) &#123; int sy = 0; float s = sinf(t); float a = s * s * s * s * 0.2f; for (float z = 1.3f; z &gt; -1.2f; z -= 0.1f) &#123; _TCHAR* p = &amp;buffer[sy++][0]; float tz = z * (1.2f - a); for (float x = -1.5f; x &lt; 1.5f; x += 0.05f) &#123; float tx = x * (1.2f + a); float v = f(tx, 0.0f, tz); if (v &lt;= 0.0f) &#123; float y0 = h(tx, tz); float ny = 0.01f; float nx = h(tx + ny, tz) - y0; float nz = h(tx, tz + ny) - y0; float nd = 1.0f / sqrtf(nx * nx + ny * ny + nz * nz); float d = (nx + ny - nz) * nd * 0.5f + 0.5f; *p++ = ramp[(int)(d * 5.0f)]; &#125; else *p++ = ' '; &#125; &#125; for (sy = 0; sy &lt; 25; sy++) &#123; COORD coord = &#123; 0, sy &#125;; SetConsoleCursorPosition(o, coord); WriteConsole(o, buffer[sy], 79, NULL, 0); &#125; Sleep(33); &#125;&#125;exe文件下载]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git index.lock]]></title>
    <url>%2Fgit%2Fgit-index-lock.html</url>
    <content type="text"><![CDATA[在git没有运行完成之前强制关闭，下次提交的时候会产以下生错误，或者类似的。12345fatal: Unable to create '/xxx/xx/.git/index.lock': File exists.If no other git process is currently running, this probably means agit process crashed in this repository earlier. Make sure no other gitprocess is running and remove the file manually to continue.原因是在你进行某些比较费时的git操作时自动生成，操作结束后自动删除，相当于一个锁定文件，目的在于防止对一个目录同时进行多个操作。有时强制关闭进行中的git操作，这个文件没有被自动删除，之后你就无法进行其他操作，必须手动删除，进入.git文件中删除，打开显示隐藏文件。如果没有看见.git文件夹，可以直接用命令rm -f ./.git/index.lock。之后就可以正常使用。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android上搭建hexo博客]]></title>
    <url>%2Ftermux%2Ftermux.html</url>
    <content type="text"><![CDATA[暑假刚开始的时候放假回家没带电脑，只能玩手机，想折腾一下博客都没有条件，在一个发现一个app,卧槽😱，termux真的强大！(初始化需要科学上网)安卓手机上的linux简直了，在手机就可以搭了一个hexo博客，只要在github上实现分支管理就可以多终端同步更新了。恕我学疏才浅，还只想到这些！一开始想回校后，折腾一下hexo-admin实现类似动态博客一样的多终端管理(手动滑稽)，现在发现termux这样子的操作也不错嘛，挺装哔hhhhhh部署后的效果准备Termux文件管理器（RE,MT文件管理器等高级一点的）开始打开Termux，输入$pkg install nodejs安装Nodejs，在输入pkg install git安装Git。过程会出现一个提示，输入y回车确认即可。按照Hexo官网提示安装Hexo。123npm install hexo-cli -ghexo init blogcd blog注意ssh配置先安装：pkg install openssh然后按照基本操作配置Hexo，GitHub或者gitee,coding等连上，部署测试一次。安装部署插件npm install hexo-deployer-git --save，部署hexo d -g没有问题的话进行下一步。编辑写文章的话创建md文件命令和电脑上一样，文件管理器打开/data/data/com.termux/files/home/i/source/_posts/编辑文章md文件。这种方式需要Root。没有Root的话可以使用Vim，网上很多教程。但是这种方式相对来说更麻烦。参考termux高级终端安装使用配置教程使用 Termux 在手机上运行 linux 黑科技hexo 搭建过程超详细教程效果图(未连接github，coding等)]]></content>
      <categories>
        <category>termux</category>
      </categories>
      <tags>
        <tag>termux</tag>
        <tag>hexo博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[石子阵列(组合数学)]]></title>
    <url>%2FACM%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2Fnowcoder157a.html</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/157/A来源：牛客网题目描述xb有m种石子，每种无限个，Ta想从这些石子中取出n个，并按顺序排列起来，为了好看，相邻的石子不能相同。xb想知道有多少种排列的方法。输入描述:第一行有两个正整数n，m。输出描述:第一行一个整数，表示在m种石子中取出n个的排列方案数模1000000007后的值。示例1输入1 1输出1示例2输入2 3输出6示例3输入3 3输出12备注:对于100%的测试数据：1 ≤ n, m ≤ 1000数据量较大，注意使用更快的输入输出方式。水题。。。123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n,m,ans; scanf("%lld%lld",&amp;n,&amp;m); ans=m; for(int i=1;i&lt;n;i++) ans=(ans*(m-1))%1000000007; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>Nowcoder</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dreamoon and Stairs]]></title>
    <url>%2FACM%2Fcodeforces476a.html</url>
    <content type="text"><![CDATA[题目链接Dreamoon wants to climb up a stair of n steps. He can climb 1 or 2 steps at each move. Dreamoon wants the number of moves to be a multiple of an integer m.What is the minimal number of moves making him climb to the top of the stairs that satisfies his condition?InputThe single line contains two space separated integers n, m (0 &lt; n ≤ 10000, 1 &lt; m ≤ 10).OutputPrint a single integer — the minimal number of moves being a multiple of m. If there is no way he can climb satisfying condition print - 1 instead.Examplesinput10 2output6input3 5output-1NoteFor the first sample, Dreamoon could climb in 6 moves with following sequence of steps: {2, 2, 2, 2, 1, 1}.For the second sample, there are only three valid sequence of steps {2, 1}, {1, 2}, {1, 1, 1} with 2, 2, and 3 steps respectively. All these numbers are not multiples of 5.有一个n级台阶，每次可以走一级或两级，问最少的步数是多少，且步数必须是m的倍数。找一下数学公式就好了。具体看代码。12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int x,n,m; cin&gt;&gt;n&gt;&gt;m; if(n&lt;m)&#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; if(n==m)&#123; cout&lt;&lt;n&lt;&lt;endl; return 0; &#125; if(n%2==0)&#123; x=n/2%m; if(x==0) cout&lt;&lt;n/2&lt;&lt;endl; else cout&lt;&lt;n/2+m-x&lt;&lt;endl; &#125;else if(n%2!=0)&#123; x=(n/2+1)%m; if(x==0) cout&lt;&lt;n/2+1&lt;&lt;endl; else cout&lt;&lt;(n/2+1)+m-x&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dreamoon and WiFi(组合数学)]]></title>
    <url>%2FACM%2F%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2Fcodeforces476b.html</url>
    <content type="text"><![CDATA[题目链接题目大意就是给定两个字符串，第一个字符串由”+”,”-“组成，第二个字符串由”+”,”-“,”?”组成，“+”代表加1，”-“代表减一，“?”代表可取正也可取负，问第二个字符串的位置和第一个字符串相等的概率是多少。我一开始的想法是把（+1，-1）^n 看成和二项式定理一样的展开始式，只不过把乘法改为加法，然后得到公式c(n,0)(n+(-1)0)+c(n,1)(n-1+(-1)1)+c(n,i)(n-i+(-1)i)+...+c(n,n)(n-n+(-1)n)化简一下可知通项为c(n,i)(n-2*i)然后我对第一个串求出位置sum,第二个串先求出已知位置sum1，然后记录下？的个数，然后遍历找出展开式中某一项n-2i+sum1==sum，这样x的系数就是可能出现位置相等的所有情况，用(n-2i)/系数和就是概率了啊，可是为什么不对呢，本地调试，数据没问题，可是交到cf上第二组都过不了，烦亏我还觉得想到一个独辟的方法呢，过不了。。。1234567891011//cf错误报告，思前恐后不晓得why,wtf???先码着吧Test: #2, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWERInput+-+-+-??Output-0.000000000000Answer0.500000000000Checker Logwrong answer 1st numbers differ - expected: &apos;0.5000000&apos;, found: &apos;-0.0000000&apos;, error = &apos;0.5000000&apos;错误代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int i,j,cnt=0; long long c[11][11],sum=0,sum1=0; for(i = 0; i &lt; 11; i++)&#123;//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(j = 1; j &lt; i; j++) c[i][j] = c[i-1][j] + c[i-1][j-1]; &#125; string a,b; cin&gt;&gt;a&gt;&gt;b; //cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b&lt;&lt;endl; int len=a.length(); for(i=0;i&lt;len;i++) if(a[i]=='+') sum+=1; else sum-=1; for(i=0;i&lt;b.length();i++)&#123; if(b[i]=='+') sum1+=1; else if(b[i]=='-')sum1-=1; if(b[i]=='?') cnt++; &#125; if(sum==sum1&amp;&amp;cnt==0)&#123; printf("1.000000000000\n"); return 0; &#125; int flag=0; int x=0; for(j=0;j&lt;=cnt;j++) x+=c[cnt][j]; //cout&lt;&lt;x&lt;&lt;endl; for(i=0;i&lt;=cnt;i++) if(cnt-2*i+sum1==sum)&#123; flag=1; long double y=c[cnt][i]*1.0/x; printf("%.12llf\n",y); &#125; if(!flag)printf("0.000000000000\n"); return 0;&#125;想不通，没办法只好换思路。。。。我先分别记下a,b串的’+’,’-‘,’?’个数，然后后我们很容易知道，如要a,b位置相等,则加号和减号的数目，两串要相等，且a中的加号要比b中已知的加号要多，减号也要比b中已知的要多，否则打死都不会相等的，仔细比划一下就知道了。然后有z个‘?’，相当于有z个坑，让我们去填使得a,b相等。只能填+或-，设加号差等于x-p,所以概率就等于c(z,x-p)/2^z。AC代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; string a,b; int x,y,z,p,q,c[11][11],i,j; for(i = 0; i &lt; 11; i++)&#123; c[i][0] = 1; c[i][i] = 1; for(j = 1; j &lt; i; j++) c[i][j] = c[i-1][j] + c[i-1][j-1]; &#125; cin&gt;&gt;a; cin&gt;&gt;b; x=y=z=p=q=0; for(i=0;i&lt;a.length();i++) if(a[i]=='+') x++; else y++; for(i=0;i&lt;b.length();i++)&#123; if(b[i]=='+') p++; else if(b[i]=='-') q++; else z++; &#125; if(x==p&amp;&amp;z==0)&#123; printf("1.000000000000\n"); return 0; &#125; if(x-p&lt;0||y-q&lt;0) &#123; printf("0.000000000000\n"); return 0; &#125; x=x-p; printf("%0.12f",c[z][x]*1.0/(2&lt;&lt;(z-1))); return 0;&#125;几分钟写完后面的代码，心中一万头草泥马在奔腾。。。。]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The equation-SGU106(扩展欧几里得)(转)]]></title>
    <url>%2FACM%2F%E6%95%B0%E8%AE%BA%2FEuclid.html</url>
    <content type="text"><![CDATA[转载注明，侵删题意：给出a,b,c,x1,x2,y1,y2，求满足ax+by+c=0，且x∈[x1,x2],y∈[y1,y2]的整数解个数。分析：对于解二元一次不定方程，容易想到利用扩展欧几里得求出一组可行解后找到通解，下面来介绍一下欧几里得以及扩展欧几里得。欧几里得：又名辗转相除法，是用来计算两个数的最大公约数，其中就是利用gcd(a,b)=gcd(b,a mod b)来求解。下证gcd(a,b)=gcd(b,a mod b)的正确性：设a,b的一个公约数为d设a mod b=r，则a=kb+r(k为整数)，r=a-kb因为d|a,d|b所以d|a-kb,即d|r，而r=a mod b所以d为b,a mod b的公约数又因为d也为a,b的公约数，所以（a,b)和(b,a mod b)的公约数一样，所以最大公约数必然一样，得证。代码描述：12345int gcd(int a,int b)&#123; if (b==0) return a; return gcd(b,a%b);&#125;扩展欧几里得顾名思义，为上述欧几里得算法的扩展。欧几里得是用来求a,b的最大公约数，那么扩展欧几里得不仅能求出a,b的最大公约数，还能求出满足ax+by=gcd(a,b)的一组可行解。求解过程中，扩展欧几里得比欧几里得多了一个赋值过程，具体证明如下：设ax1+by1=gcd(a,b),bx2+(a mod b)y2=gcd(b,a mod b)因为由欧几里得算法可知，gcd(a,b)=gcd(b,a mod b)所以ax1+by1=bx2+(a mod b)y2因为a mod b=a-(a div b)*b（div为整除所以有ax1+by1=bx2+(a-(a div b)*b)y2将右边移项，展开得：12ax1+by1=ay2+bx2-(a div b)*b*y2 =ay2+b[x2-(a div b)]y2所以可得：x1=y2y1=x2-(a div b)*y2将得到的的x1,y1递归操作求解x2,y2，如此循环往复，将会像欧几里得一样得到b=0的情况，此时递归结束，返回x=1,y=0，回溯得解。代码描述：此函数返回的是a,b的最大公约数，同时也求解出满足ax+by=gcd(a,b)的一组可行的(x,y)12345678int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if (b==0) &#123;x=1;y=0;return a;&#125; int t=exgcd(b,a%b,x,y); int x0=x,y0=y; x=y0;y=x0-(a/b)*y0; return t;&#125;关于求解二元一次不定方程ax+by=c首先，如果c不是gcd(a,b)的倍数，方程显然无解。扩展欧几里得求解的是ax+by=gcd(a,b)=1的可行解，但是题目中并没有说c与a,b互质之类的条件，所以需要在开始时两边同时除以gcd(a,b)。设d=gcd(a,b)设a’=a/d,b’=b/d,c’=c/d,则下面需要求解a’x+b’y=c’的整数解，而gcd(a’,b’)=1，则我们只需求a’x+b’y=1的可行解直接使用扩展欧几里得，得到(x’,y’),则最终解为x&#39;*c&#39;,y&#39;*c&#39;设为(x0,y0)。现在得到了一组可行解，但是如何得到通解呢？将(x0,y0)代入ax+by=c，则有a*(x0)+b*(y0)=c通过拆添项，可有：1234567a*(x0+1*b)+b*(y0-1*a)=ca*(x0+2*b)+b*(y0-2*a)=ca*(x0+3*b)+b*(y0-3*a)=c……a*(x0+k*b)+b*(y0-k*a)=c (k∈Z)至此，我们得到了通解的方程x=x0+k*by=y0-k*a (k∈Z)这样，所有满足ax+by=c的可行解都可求出。具体实现有了主体算法，下面要谈到具体实现了。先处理一下无解的情况：当a=0并且b=0，而c≠0时，显然无解；当a=0,b=0，而c=0时，[x1,x2],[y1,y2]都为可行解，根据乘法原理，可行解的个数为(x2-x1+1)*(y2-y1+1);当a=0 b≠0时：此时即为求解by=c，则y=c/b，如果c/b不是整数或c/b不在[y1,y2]的范围内，无解否则[x1,x2]内全部整数都为可行解.当b=0,a≠0时，同上。若c不是gcd(a,b)的个数，方程显然无解。处理完了一些繁琐的细节后，下面是具体的求解过程：扩展欧几里得求解的是ax+by=c，而本题是ax+by+c=0，需将c移项。对于本道题，首先要注意的是，对于负数的模运算在此算法中无法得到正确解，所以要处理一下a,b,c的正负情况。如果a为负数，只需将a取相反数后，再处理一下x∈[x1,x2]的范围。当a取了相反数，相当于把x也取反，则需要把x的范围由[x1,x2]转变成[-x2,-x1],类似于把数轴反了过来。b同理。利用扩展欧几里得解二元一次不定方程，得到一组可行解(x0,y0)。因为题目中对x,y有条件约束，而有x=x0+kb,y=y0-kb，我们可以求出满足x∈[x1,x2],y∈[y1,y2]的k的取值范围,即为求解x1&lt;=x0+kb&lt;=x2,y1&lt;=y0-kb&lt;=y2的整数k的个数但是在求解这两个一次函数的过程中，会有除不尽的现象，该如何取整呢？举个例子当出现2.5&lt;=k&lt;=5.5时，我们需要的可行的k为3,4,5，所以需要将2.5向上取整得到3，5.5向下取整得到5，即为3&lt;=k&lt;=5；当出现-5.5&lt;=&lt;=-2.5时，我们需要的可行的k为-5,-4,-3,所以需要将-5.5向上取整得到-5,-2.5向下取整得到-3，即为-5&lt;=k&lt;=-3；正负数的情况都已经考虑完全了，可以得到取整的结论：上界下取整，下界上取整。最后，将得到的两个范围取交集，得到[l,r]，则最终答案为r-l+1。这样，本题就可以完美解决了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// BY Rinyo#include&lt;cstdio&gt;#include&lt;cmath&gt;long long a,b,c,x1,x2,yy1,y2,x0,yy0;inline long long cmin(const long long &amp;x,const long long &amp;y) &#123;return x&lt;y?x:y;&#125;inline long long cmax(const long long &amp;x,const long long &amp;y) &#123;return x&gt;y?x:y;&#125;long long gcd(long long a,long long b)&#123; if (b==0) return a; return gcd(b,a % b);&#125;void exgcd(long long a,long long b)&#123; if (b==0)&#123;x0=1;yy0=0;return;&#125; exgcd(b,a%b); long long t=x0;x0=yy0;yy0=t-a/b*yy0; return;&#125;int main()&#123; scanf("%I64d%I64d%I64d%I64d%I64d%I64d%I64d",&amp;a,&amp;b,&amp;c,&amp;x1,&amp;x2,&amp;yy1,&amp;y2); c=-c; if (c&lt;0) &#123;a=-a;b=-b;c=-c;&#125; if (a&lt;0) &#123;a=-a;long long t=x1;x1=-x2;x2=-t;&#125; if (b&lt;0) &#123;b=-b;long long t=yy1;yy1=-y2;y2=-t;&#125; if (a==0 &amp;&amp; b==0) &#123; if (c==0) &#123; printf("%I64d",(x2-x1+1)*(y2-yy1+1)); return 0; &#125; printf("0");return 0; &#125; else if (a==0) &#123; if (c %b ==0) if (c/b&lt;=y2 &amp;&amp; c/b&gt;=yy1) &#123;printf("%I64d",x2-x1+1);return 0;&#125; printf("0");return 0; &#125; else if (b==0) &#123; if (c%a==0) if (c/a&lt;=x2 &amp;&amp; c/a&gt;=x1) &#123;printf("%I64d",y2-yy1+1);return 0;&#125; printf("0");return 0; &#125; long long d=gcd(a,b); if (c%d!=0)&#123;printf("0");return 0;&#125; a=a/d;b=b/d;c=c/d; exgcd(a,b); x0=x0*c;yy0=yy0*c; double tx2=x2,tx1=x1,tx0=x0,ta=a,tb=b,tc=c,ty1=yy1,ty2=y2,ty0=yy0; long long down1=floor(((tx2-tx0)/tb)),down2=floor(((ty0-ty1)/ta)); long long r=cmin(down1,down2); long long up1=ceil(((tx1-tx0)/tb)),up2=ceil(((ty0-ty2)/ta)); long long l=cmax(up1,up2); if (r&lt;l) printf("0"); else printf("%I64d",r-l+1); return 0;&#125;扩展欧几里得模板1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int exgcd(int a,int b,int &amp;x,int &amp;y)&#123; if(b==0) &#123; x=1; y=0; return a; &#125; int gcd=exgcd(b,a%b,x,y); int x2=x,y2=y; x=y2; y=x2-(a/b)*y2; return gcd;&#125;int main()&#123;int x,y,a,b;cout&lt;&lt;"请输入a和b:"&lt;&lt;endl;cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;"a和b的最大公约数:"&lt;&lt;endl;cout&lt;&lt;exgcd(a,b,x,y)&lt;&lt;endl;cout&lt;&lt;"ax+by=gcd(a,b) 的一组解是:"&lt;&lt;endl;cout&lt;&lt;x&lt;&lt;" "&lt;&lt;y&lt;&lt;endl;return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>欧几里得</tag>
        <tag>他山之石</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leading and Trailing-lightoj1282(快速幂+对数运算)]]></title>
    <url>%2FACM%2F%E6%95%B0%E8%AE%BA%2Flightoj1282.html</url>
    <content type="text"><![CDATA[题目链接题目大意：给定两个数n,k 求n^k的前三位和最后三位。分析求后三位的话：直接快速幂，对1000取模就好了。求前三位，对于给定的一个数n,它可以写成n=10^a,其中这个a为浮点数,则t=n^k=(10^a)^k=10^a*k=(10^x)*(10^y);其中x,y分别是a*k的整数部分和小数部分，对于t=n^k这个数，它的位数由(10^x)决定，它的位数上的值则有(10^y)决定，因此我们要求t的前三位，只需要将10^y求出，在乘以100，就得到了它的前三位。分析完，我们再整体看，设n^k=10^z;那么z=k*log10(n)fmod(z,1)可以求出x的小数部分。123456789101112131415161718192021222324252627282930313233343536//再一次吐槽lightoj的头文件，让我不能用万能头&lt;bits/stdc++.h&gt;#include&lt;stdio.h&gt;#include&lt;math.h&gt;typedef long long LL;int quickpow (int m, int n, int k)&#123; int b = 1; while (n &gt; 0) &#123; if (n &amp; 1) b = (b * m) % k; n &gt;&gt;= 1; m = (m * m) % k; &#125; return b%k;&#125;int main ()&#123; int t, flag = 1; scanf ("%d", &amp;t); while (t--) &#123; LL n, k; scanf ("%lld %lld", &amp;n, &amp;k); int first = pow (10.0, 2.0 + fmod (k*log10(n*1.0), 1)); int last = quickpow (n%1000, k, 1000); printf ("Case %d: %d %03d\n", flag++, first, last); &#125; return 0;&#125;注：C库函数 - fmod()C 库函数 double fmod(double x, double y) 返回 x 除以 y 的余数。x – 代表分子的浮点值。y – 代表分母的浮点值。该函数返回 x/y 的余数。下面的实例演示了 fmod() 函数的用法。123456789101112131415#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main ()&#123; float a, b; int c; a = 9.2; b = 3.7; c = 2; printf("%f / %d 的余数是 %lf\n", a, c, fmod(a,c)); printf("%f / %f 的余数是 %lf\n", a, b, fmod(a,b)); return(0);&#125;结果：9.200000 / 2 的余数是 1.2000009.200000 / 3.700000 的余数是 1.800000]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 502(Div.1 + Div.2)]]></title>
    <url>%2FACM%2Fcfcontest1017.html</url>
    <content type="text"><![CDATA[A. The Rank题目大意：给出n个学生的成绩，Thomas Smith的成绩是第一行，然后要按总成绩进行排序，总分相同的按编号从小到大排；开始看还以为要写sort的cmp函数进行多条件排序，敲完才发现其实只要按总分就可以了，因为托马斯的id是一，必然会排在前面。12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;int a[4],sum[1005];int main()&#123; int n,s,f1; cin&gt;&gt;n; for(int j=1;j&lt;=n;j++)&#123; s=0; for(int i=0;i&lt;4;i++)&#123; cin&gt;&gt;a[i]; s+=a[i]; &#125; sum[j]=s; if(j==1) f1=s; &#125; sort(sum+1,sum+n+1,greater&lt;int&gt;()); for(int i=1;i&lt;=n;i++) if(sum[i]==f1)&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; return 0;&#125;B. The Bits题目大意：先给出二进制数的长度，然后输入两个二进制数a,b，问交换a中的某些位数的数，使得a|b(按位或)的结果不同，求有多少种不同的或值。a,b上下对应的情况：a/b个数1/0m0/0n1/1x0/1y用组合数学的思想来想：只要看b为0的位就行了，如果0/0,a只能换1的位置，为了避免重复，所以这里总数为n*x,再考虑1/0的情况，只能和0的位置换，这是后可以把0/0没算的都算上，所以总数m*(n+y)所以最后总数为sum=n*x+m*(n+y)123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n,m,x,y,t; n=m=x=y=0; char a[100005],b[100005]; cin&gt;&gt;t; cin&gt;&gt;a&gt;&gt;b; for(int i=0;i&lt;t;i++)&#123; int p=a[i]-'0'; int q=b[i]-'0'; if(p==0&amp;&amp;q==0) n++; if(p==1&amp;&amp;q==0) m++; if(p==1&amp;&amp;q==1) x++; if(p==0&amp;&amp;q==1) y++; &#125; long long sum=n*x+m*(y+n); cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数]]></title>
    <url>%2FACM%2F%E6%95%B0%E8%AE%BA%2Feuler.html</url>
    <content type="text"><![CDATA[欧拉函数是求小于x并且和x互质的数的个数通式：φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn)其中p1, p2……pn为x的所有质因数，x是不为0的整数φ(1)=1（唯一和1互质的数就是1本身）【注意：每种质因数只一个。比如12=223】定理：若n是素数p的k次幂，φ(n)=p^k-p^(k-1)=(p-1)p^(k-1)，因为除了p的倍数外，其他数都跟n互质 欧拉函数是积性函数——若m,n互质，φ(mn)=φ(m)φ(n)特殊性质：当n为奇数时，φ(2n)=φ(n)p是素数，φ(p) = p - 1，φ(p)称为p的欧拉值若a为素数,b mod a=0,φ(a*b)=φ(b)*a模板//直接法12345678910111213141516int Euler(int n)&#123; int res = n,i; //由于任何一个合数都至少有一个不大于根号n的素因子，所以只要遍历到根号n即可 for(i=2;i * i &lt;= n;i++) if(n%i == 0)&#123; //第一次找到的必为素因子 n /=i ; res = res - res/i; //x(1-1/p1) while(n % i ==0) n/=i; //将该素因子的倍数也全部筛掉 &#125; if (n &gt; 1) res = res - res/n; return res;&#125;以上转载注明//素数筛选法，先素数筛选，再求欧拉123456789101112131415161718192021222324252627282930/*特性 :1.若a为质数,phi[a]=a-1;2.若a为质数,b mod a=0,phi[a*b]=phi[b]*a3.若a,b互质,phi[a*b]=phi[a]*phi[b](当a为质数时,if b mod a!=0 ,phi[a*b]=phi[a]*phi[b])*/int m[n],phi[n],p[n],nump;//m[i]标记i是否为素数,0为素数,1不为素数;p是存放素数的数组;nump是当前素数个数;phi[i]为欧拉函数int make()&#123; phi[1]=1; for (int i=2;i&lt;=n;i++) &#123; if (!m[i])//i为素数，m[]初始化为0 &#123; p[++nump]=i;//将i加入素数数组p中 phi[i]=i-1;//因为i是素数,由特性得知 &#125; for (int j=1;j&lt;=nump&amp;&amp;p[j]*i&lt;n;j++) //用当前已的到的素数数组p筛,筛去p[j]*i &#123; m[p[j]*i]=1;//可以确定i*p[j]不是素数 if (i%p[j]==0) //看p[j]是否是i的约数,因为素数p[j],等于判断i和p[j]是否互质 &#123; phi[p[j]*i]=phi[i]*p[j]; //特性2 break; &#125; else phi[p[j]*i]=phi[i]*(p[j]-1); //互质,特性3,p[j]-1就是phi[p[j]] &#125; &#125;&#125;附素数打表12345678910int p[N]=&#123;1,1,0&#125;;void prime()&#123; for(int i=2;i&lt;N;i++) if(!p[i])&#123; for(int j=2*i;j&lt;=N;j+=i)//筛掉i的倍数 p[j]=1; &#125;&#125;例题Bi-shoe and Phi-shoe LightOJ - 1370题意：给一些数Ai（第 i 个数），Ai这些数代表的是某个数欧拉函数的值，我们要求出数 Ni 的欧拉函数值不小于Ai。而我们要求的就是这些 Ni 这些数字的和sum，而且我们想要sum最小，求出sum最小多少。解题思路：要求和最小，我们可以让每个数都尽量小，那么我们最后得到的肯定就是一个最小值。给定一个数的欧拉函数值ψ(N)，我们怎么样才能求得最小的N?我们知道，一个素数P的欧拉函数值ψ(P)=P-1。所以如果我们知道ψ(N)，那么最小的N就是最接近ψ(N)，并且大于ψ(N)的素数。我们把所有素数打表之后再判断就可以了。这个lightoj有毒，什么头文件都不支持，卡了我好久。。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#define N 1000005#define ll long longint m[N]=&#123;1,1,0&#125;;int p[100000],cnt=0;int max(int x,int y)&#123; return x&gt;y?x:y;&#125;void prime()&#123; for(int i=2;i&lt;N;i++) if(!m[i])&#123; for(int j=2*i;j&lt;=N;j+=i) m[j]=1; p[cnt++]=i; &#125;&#125;int binary_search(int x)&#123;//二分查找 int l=0,r=cnt; while(l&lt;=r)&#123; int mid=(l+r)/2; if(p[mid]&gt;x) r=mid-1; else l=mid+1; &#125; for(int i=max(r,0);;i++) if(p[i]&gt;x) return p[i];&#125;int main()&#123; prime(); int T,n,cas=1,temp; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); ll sum=0; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;temp); sum+=binary_search(temp); &#125; printf("Case %d: %lld Xukha\n",cas++,sum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>euler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Heavy Transportation-poj1797(dijkstra或最大生成树)]]></title>
    <url>%2FACM%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2Fpoj1797.html</url>
    <content type="text"><![CDATA[题目链接](http://poj.org/problem?id=1797)大意：要从城市1到城市N运送货物，有M条道路，每条道路都有它的最大载重量，问从城市1到城市N运送最多的重量是多少。其实题意很简单，就是找一条1–&gt;N的路径，在不超过每条路径的最大载重量的情况下，使得运送的货物最多。一条路径上的最大载重量为这个路径上权值最小的边;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//dijkstra#include&lt;iostream&gt;#include&lt;cstdio&gt;#define min(a,b) (a&lt;b?a:b)using namespace std;int n,m,v[1010],maps[1010][1010],d[1010];//此时d表示1到每一个点的能通过的最大的重量int dijkstra()&#123; int i,j,k; for(i=1;i&lt;=n;i++)&#123; v[i]=0; d[i]=maps[1][i];//这个时候d不代表最短路径，而是从1到n的最大承载量 &#125; for(i=1;i&lt;=n;i++)&#123;//n个点 int f=-1; for(j=1;j&lt;=n;j++) if(!v[j]&amp;&amp;d[j]&gt;f)&#123; f=d[j]; k=j; &#125; v[k]=1; for(j=1;j&lt;=n;j++) if(!v[j]&amp;&amp;d[j]&lt;min(d[k],maps[k][j]))//更新说明见图解 d[j]=min(d[k],maps[k][j]); &#125; return d[n];&#125;int main()&#123; int ans=1; int a,b,w; int T; scanf("%d",&amp;T); while(T--)&#123; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++) maps[i][j]=0; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;a,&amp;b,&amp;w); maps[a][b]=maps[b][a]=w; &#125; printf("Scenario #%d:\n%d\n\n",ans++,dijkstra()); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>POJ</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客自定义console log]]></title>
    <url>%2Fhexo%2Fconsole-log.html</url>
    <content type="text"><![CDATA[看到知乎，百度的页面F12检查后都会有一些有趣的招聘信息。于是乎我也想给我的博客加一个。我主要用到的工具：console.log()Notepad++在线图片转文字工具用法用js在&lt;body&gt;&lt;/body&gt;使用console.log()就行了，hexo的主题文件在_layout.swig里，所以我们打开该文件，在该位置，添加js就行了；图案我用的我自己的一张照片(电脑上照片就那么几张。。。)，然后用 在线图片转文字工具 转字符，选择文件，设置大小，然后生成，生成后，复制TXT文件（下面那个框，上面的是HTML代码）粘贴到Notepad++里面，然后按图操作；Ctrl+H 替换最后就变成一个字符串了。效果图线上demo,按F12找到console我的txt1\n` @@#``@@@@@@@@@@@@@@@@@@##,` \n` @@#`;@@@@@@@@@@@@@@@@@@@&apos;:&apos; \n` @@#`@@@@@@@@@@@@@@@@@@@#+#;` \n` @@#`@@@@@@@@@@@@@@@@@@###@&apos;. \n` @@+.@@@@@@@@@@@@@@@@@@@@@##, \n` @@#,@@@@@@@@@@@@@@@@@@@@@@#, \n` #@#:@@@@@@@@@@@@@@@@@@@@@@@, \n` #@#&apos;@@@@@@@@@@@@@@@@@@@@@@@. \n` +@#;@@@@@@@@@@@@@@@@@@@@@@# \n` `;: ;@#&apos;@@@@@@@@@@@@@@@@@@+&apos;+@&apos; \n` `,,;&apos;;&apos;+&apos;;&apos;@@+:@@@@@@@@@@@@##@#&apos;,.:#; \n,, `` ``..,:;@@#&apos;@@@@@@@@#####@@@@#:`:. \n` `````:++@@@@@@@@@@@@@###@@@@#+,.. \n ``````.#@@@@@@@@@@@@@@#@@@#++#&apos;`` \n` ```.,,:,.`:@@@@@@@@@@@@@###@@@##&apos;.` \n``..`````..,::;+@@@@@@@@@@@@#+`::+##&apos;`. \n` ````.```,@@@@@@@@@@@##;``.,&apos;;` ` \n``.;@@@@@@@@@@@@@@@@@@@@@@###;``..`````` \n#@@@@@@@@@@@@@@@@@@@@@@@@##@#;``,``,.`` \n@@@@@@@@@@@@@@@@@@@.`````..``.. +` `:` \n@+&apos;&apos;++#####@@#`.@@@``````` ` `,``` `` \n&apos;;;;;&apos;+##+&apos;+.`;+@@@,..```` `` :,. \n;::,,:;+#++``,,#@@@&apos;..``````` ,`.`` \n;,,,,...&apos;#.,,..#@@@#,,.`````` .```` \n:,,,,....`,::;&apos;&apos;+#@#;,..`````````.`` \n:,,,.....&apos;##++&apos;&apos;&apos;;:+&apos;:,.`..,,...` \n:,,,...#####+&apos;+#@@@&apos;.&apos;;+:. ` `` \n;,,.`&apos;####&apos;#,`.`+@@@+&apos;``` `.` \n;,.`#@@@#+:&apos;+++##+@##@,,,,` \n&apos;,.#@@###&apos;&apos;&apos;&apos;;:,.```,+#. \n+,#@@@####;,,..``````````````` `.:,::\n+@@@@###+;,,..`````````````````` `.,\n#@@@##+&apos;,,,........`````````````` \n@@@@#+:,,,,`........`````````` \n@@@#+:,,,,.`````.....`````````` `` \n@@##&apos;:,......`````....``` ````` ```\n@@@#&apos;:,....,..``````..```` ``` ```\n@@@#&apos;,....,,,..``````````` ``` ..\n@@@#,.....,,,,.`` ```````` `````` \n@@@+....,,,,,..````````````` `````````` \n@@@:....,,,,.LiRuihao```````` ```````````` \n#@@,....,,,,.Always Be Yourself !````````````\n,##,,...,::,.````````````..`````` `......``\n,&apos;#,,..,,:::.`````````........`````` `.,,..\n\n你好！\n欢迎进入什么都不会的李瑞豪的个人网站！\nhttps://lruihao.cn\nhttps://www.lruihao.cn\nhttps://lruihao.github.io\nhttps://liruihao.coding.me\n\n\n\n其他个人网站，个人博客也是可以的。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Til the Cows Come Home-poj2387(dijkstra判断重边)]]></title>
    <url>%2FACM%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2Fpoj2387.html</url>
    <content type="text"><![CDATA[题目链接题目大意：说的是，一只奶牛位于N号节点，输入N个节点和T对双向的边，求出由N到1的最短的距离，其实就是问的单源最短路问题。两个点可能有多条路，选择最短的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int INF=99999999; //设为无穷大int maps[1005][1005],v[1005],d[1005]; //v表示是否已经过遍历 d表示从源到点当前最短路int n;void Dijkstra(int s,int t)&#123; int i,j,k,mini; for(i=1;i&lt;=n;i++) d[i]=INF; //除源点设为0距离外 其他先设为无穷大 d[s]=0; for(i=1;i&lt;=n;i++) //n点循环n次 ,找出n个k,找n个点 &#123; mini=INF; k=-1; for(j=1;j&lt;=n;j++) //在所有未标记点中 选d值最小的点 if(!v[j] &amp;&amp; d[j]&lt;mini) mini=d[k=j]; v[k]=1; //标记节点 if(k==t) &#123; printf("%d\n",d[t]); return; &#125; for(j=1;j&lt;=n;j++) if(!v[j] &amp;&amp; (d[k]+maps[k][j])&lt;d[j]) //表示从k出发的点，对于所有边，更新相连点 d[j]=d[k]+maps[k][j]; &#125;&#125;int main()&#123; int T,i,j,x,y,D; while(scanf("%d %d",&amp;T,&amp;n)!=EOF) &#123; memset(v,0,sizeof(v)); //清除标记 for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) maps[i][j]=INF; for(i=1;i&lt;=T;i++)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;D); if(maps[x][y]&gt;D) //可能有多条路，只记录最短的 maps[x][y]=D,maps[y][x]=D; &#125; Dijkstra(1,n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路入门]]></title>
    <url>%2FACM%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%2Fzuiduanlu.html</url>
    <content type="text"><![CDATA[Dijkstra算法1.定义概览Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径）2.算法描述1)算法思想：设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。2)算法步骤：a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则&lt;u,v&gt;正常有权值，若u不是v的出边邻接点，则&lt;u,v&gt;权值为∞。b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。d.重复步骤b和c直到所有顶点都包含在S中。执行动画过程如下图spfa算法spfa是一种求单源最短路的算法算法中需要用到的主要变量int n; //表示n个点，从1到n标号int s,t; //s为源点，t为终点int d[N]; //d[i]表示源点s到点i的最短路int p[N]; //记录路径（或者说记录前驱）queueq; //一个队列，用STL实现，当然可有手打队列，无所谓bool vis[N]; //vis[i]=1表示点i在队列中 vis[i]=0表示不在队列中几乎所有的最短路算法其步骤都可以分为两步1.初始化2.松弛操作初始化：d数组全部赋值为INF（无穷大）；p数组全部赋值为s（即源点），或者赋值为-1，表示还没有知道前驱,然后d[s]=0; 表示源点不用求最短路径，或者说最短路就是0。将源点入队；（另外记住在整个算法中有顶点入队了要记得标记vis数组，有顶点出队了记得消除那个标记）队列+松弛操作读取队头顶点u，并将队头顶点u出队（记得消除标记）；将与点u相连的所有点v进行松弛操作，如果能更新估计值（即令d[v]变小），那么就更新，另外，如果点v没有在队列中，那么要将点v入队（记得标记），如果已经在队列中了，那么就不用入队以此循环，直到队空为止就完成了单源最短路的求解SPFA可以处理负权边定理: 只要最短路径存在，上述SPFA算法必定能求出最小值。证明： 每次将点放入队尾，都是经过松弛操作达到的。换言之，每次的优化将会有某个点v的最短路径估计值d[v]变小。所以算法的执行会使d越来越小。由于我们假定图中不存在负权回路，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着d值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。（证毕）期望的时间复杂度O(ke)， 其中k为所有顶点进队的平均次数，可以证明k一般小于等于2。判断有无负环： 如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图）代码]]></content>
      <categories>
        <category>ACM</category>
        <category>最短路</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟，大牛和教主，三者的区别(转)]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2Ffucking4.html</url>
    <content type="text"><![CDATA[对菜鸟来说题目有三种：会算法且能AC的，会算法但不能AC的，不会做的对大牛来说题目有两种：会做的，不会做的对教主来说题目有两种：能AC的，数据有错的菜鸟提交WA了，找了N久找不出错时，在论坛大骂数据有错，但是没人理大牛提交WA了，找了N久找不出错时，写暴力程序或者求别人的AC程序对拍教主提交WA了，Judge马上修正数据菜鸟面对一道难题，直接暴搜大牛面对一道难题，算了算时间复杂度不对，或者证明出是NP难，果断放弃教主面对一道难题，说，虽然我不会做，但AC还是没有问题的菜鸟AC了一道难题，巴不得召告天下大牛AC了一道难题，会写一篇解题报告，第一句话一定是：这题其实不难教主AC了一道难题，好像什么都没发生过菜鸟切OJ，只挑简单题做大牛切OJ，成套成套地做教主早就不切OJ了菜鸟经常在论坛和QQ上求助大牛经常在论坛和QQ上灌水教主一般不露面菜鸟喜欢说自己做了几十几百道题大牛喜欢说自己把某个OJ做了百分之八九十教主一般不说话菜鸟队看到场上90%的队伍挂起了红球，开始找红球是哪道题大牛队全场第一个挂起黄球，然后发现几乎同时有另外几支大牛队也挂起了黄球教主队全场第一个挂起绿球，然后全场到最后也只有一个绿球菜鸟喜欢搜集各种模板大牛只用自己写的模板教主不用模板，但他当场写的程序会被别人用作模板菜鸟喜欢YY这种分析菜鸟、大牛和教主的区别的文章(没错就是我！- _ -)大牛看完这样的文章会笑一笑，懒得回帖教主直接无视]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>他山之石</tag>
        <tag>生活随笔</tag>
        <tag>fun sth for acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[菜鸟，大牛和教主，三者的区别(转)]]></title>
    <url>%2FACM%2Ffucking3.html</url>
    <content type="text"><![CDATA[对菜鸟来说题目有三种：会算法且能AC的，会算法但不能AC的，不会做的对大牛来说题目有两种：会做的，不会做的对教主来说题目有两种：能AC的，数据有错的菜鸟提交WA了，找了N久找不出错时，在论坛大骂数据有错，但是没人理大牛提交WA了，找了N久找不出错时，写暴力程序或者求别人的AC程序对拍教主提交WA了，Judge马上修正数据菜鸟面对一道难题，直接暴搜大牛面对一道难题，算了算时间复杂度不对，或者证明出是NP难，果断放弃教主面对一道难题，说，虽然我不会做，但AC还是没有问题的菜鸟AC了一道难题，巴不得召告天下大牛AC了一道难题，会写一篇解题报告，第一句话一定是：这题其实不难教主AC了一道难题，好像什么都没发生过菜鸟切OJ，只挑简单题做大牛切OJ，成套成套地做教主早就不切OJ了菜鸟经常在论坛和QQ上求助大牛经常在论坛和QQ上灌水教主一般不露面菜鸟喜欢说自己做了几十几百道题大牛喜欢说自己把某个OJ做了百分之八九十教主一般不说话菜鸟队看到场上90%的队伍挂起了红球，开始找红球是哪道题大牛队全场第一个挂起黄球，然后发现几乎同时有另外几支大牛队也挂起了黄球教主队全场第一个挂起绿球，然后全场到最后也只有一个绿球菜鸟喜欢搜集各种模板大牛只用自己写的模板教主不用模板，但他当场写的程序会被别人用作模板菜鸟喜欢YY这种分析菜鸟、大牛和教主的区别的文章(没错就是我！- _ -)大牛看完这样的文章会笑一笑，懒得回帖教主直接无视]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>他山之石</tag>
        <tag>生活随笔</tag>
        <tag>fun sth for acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞ACM最悲催的事。。。(转)]]></title>
    <url>%2FACM%2Ffucking2.html</url>
    <content type="text"><![CDATA[搞ACM最悲催的事莫过于你在写poj1475你看到这道题夏天的风分类为level2而且你level1还没做完你认为你可以做着试试因为这只不过是个推箱子而已于是就开始做了写了一遍bfs发现推箱子并没有你想象的那么简单而且这道题的数据简直太变态不仅变态还有问题代码写好以后提交果断的TLE于是剪枝半天还是TLE于是你告诉自己要面对现实只能换算法于是你又想了半天想出一个自己认为很好的算法然后啪啦啪啦的敲了150行代码马上就要敲完的时候发现自己这个算法思路有问题然后石化了晚上睡觉满脑子在想这道题第二天早上起床的时候突然灵机一动又想出一个新的算法！！需要3个bfs就能解决然后你就敲啊敲敲了200行编译通过很高兴然后开始跑数据结果发现以前1个bfs能跑出来的数据你这3个bfs居然跑不出来了！！！而且运行一会立刻就消失了！！！连结果都没见着！！有木有啊有木有！！！这才是搞ACM最悲催的事啊！！！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>他山之石</tag>
        <tag>生活随笔</tag>
        <tag>fun sth for acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搞ACM的你伤不起（转）]]></title>
    <url>%2FACM%2Ffucking1.html</url>
    <content type="text"><![CDATA[劳资六年前开始搞ACM啊！！！！！！！！！！从此踏上了尼玛不归路啊！！！！！！！！！！！！谁特么跟劳资讲算法是程序设计的核心啊！！！！！！尼玛除了面试题就没见过用算法的地方啊！！！！！！谁再跟劳资讲算法之美算法的力量，劳资一本算法导论拍死你啊！！！！！！！！那是搞ACM的入门书啊！！！！特么的入门书就一千多页啊！！！！！！！还没有习题答案啊，学完了你特么都不知道自己到底会不会啊有木有！！！！！！然后你就得看lrj的黑书啊！！！！！！还是特么的没有习题答案啊！！！！那书难的一B啊！！！！人家一个“显然”得出的结论够你想一礼拜啊有木有！！！！一个课后题够你想几个月啊有木有！！！！然后还有一堆堆的书啊！！！！每一类算法都足够写一本书啊！！！！每本都是砖头一样啊！！！！还都特么是英文的啊！！！！也有中文翻译版啊！！！！！！翻译得跟屎一样啊！！！！你看的时候得把它再变回英文才能懂啊！！！！！！有木有！！！！！！ACM的题目类型是没有范围的啊！！！！！！动态规划有木有！！！！数据结构有木有！！！！图论有木有！！！！！！计算几何有木有！！！！！！数论有木有！！！！！！要写两三百行的模拟题有木有！！！！！！特么连物理题化学题都有啊！！！！！！还有理论上就不可做的NP难问题啊！！！！！！特么理论上不可做的题也有人能AC啊！！！！坑爹啊！！！！课本上学的东西完全不给力啊！！！！！！你以为学过一个最长公共子串就是懂动态规划了啊！！！！！！树型的有木有！！！！状态压缩的有木有！！！！插头的有木有！！！！而且特么写出来就超时啊！！！！！！你得四边形优化啊！！！！你得斜率优化啊！！！！你得队列优化啊！！！！特么恨不得把要算十年的程序优化到一秒啊！！！！你以为学过一个二叉搜索树就是懂数据结构了啊！！！！！！平衡啊旋转啊红啊黑啊有木有！！！！伸展啊随机权重啊合并啊拆分啊有木有！！！！！！你以为学过一个Dijkstra最短路就是懂图算法了啊！！！！！！特么的图里有几百万个点啊！！！！！！得用堆来优化啊！！！！而且边权要是负的就不对了啊！！！！还有环啊！！！！而且特么的你根本看不出是最短路问题啊！！！！！！为神马最短路算法可以用来解不等式啊！！！！还有网络流啊！！！！特么的课本上的算法铁定超时啊！！！！！！你得看论文去研究神马Dinic啊SAP啊！！！！！！而且你还是根本看不出是网络流啊！！！！！！网络流是在图上来求啊！！！！特么的图在哪里啊！！！！特么的八竿子打不着的问题都能变成网络流啊！！！！！！这些你都学会了啊！！！！想参加比赛了啊！！！！发现想拿个成绩非常难啊！！！！！！校内选拔赛就好几百人报名啊有木有！！！！！！最后只能剩下十几个啊！！！！人家都是竞赛保送的啊！！！！！！中学就学了好几年了有木有！！！！怎么比的过啊！！！！！！进了校队以后你就不要想寒暑假了啊！！！！！！夏天劳资全身脱光了涂满花露水半夜刷题有木有！！！！！！冬天劳资跑遍校园找不到一个开门的食堂有木有！！！！！！而且特么老外的在线比赛都在半夜啊！！！！！！！！在机房通宵是常事啊有木有！！！！！！比赛是三个人啊！！！！但是只有一台电脑啊！！！！！！特么的ACM组委会连多买几台电脑都不肯啊！！！！！！队友占着机器你就只能干着急啊！！！！！！想把他踹一边儿去啊！！！！！！没机器你就得在纸上调试啊！！！！！！你的脑子就是个CPU啊有木有！！！！你要是摊上一个啥都不会，连读题都误导你的队友，你就死定了啊！！！！！！不怕神一样的对手就怕猪一样的队友啊！！！！你终于参加区域赛了啊！！！！一百多个队啊！！！！！！还有一大堆打星号的高中生们啊！！！！！！都是全国前几名级别的有木有！！！！还有一大堆打星号的老不死们啊！！！！！！毕业了还要来诈尸啊！！！！一开场那气球呼呼地挂啊！！！！你还没读完题人家已经AC了啊！！！！而且最先过的不一定是最简单的啊！！！！人家故意在误导你啊有木有！！！！！！比赛要五个小时啊！！！！结束了以后脑子都抽筋了啊！！！！人家做七八道题，你连一半都不到啊！！！！！！拿个毛的奖啊！！！！去个毛的总决赛啊！！！！！！去了总决赛也是被虐啊！！！！！！老毛子们更尼玛不是人啊有木有！！！！！！连清华都被虐啊有木有！！！！！！你拿着一堆Honorable Mention毕业了啊！！！！想找工作啊！！！！谁说懂算法很容易找到好工作啊！！！！都特么要项目经验有木有！！！！劳资成天盯着一个黑乎乎的控制台窗口！！！！哪有时间做项目啊！！！！！！同学们都是网站啊桌面程序啊做过一堆啊！！！！人家对面试官侃侃而谈啊！！！劳资只好说劳资除了算法啥也不会啊！！而且其实算法也没学会啊！！！！！坑爹啊！！！！终于工作了啊！！！！发现算法神马的完全用不上啊！！！！稍微复杂点的算法都有现成的库可以用啊！！！！！！要懂Shell编程有木有！！！！要懂多线程有木有！！！！要懂Socket有木有！！！！要懂分布式有木有！！！！要懂J2EE有木有！！！！要懂设计模式有木有！！！！要懂以下省略三千字有木有！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！总之搞ACM的上辈子都是脑细胞死光钻到牛角尖里出不来的天使啊！！！！！！你伤不起啊！！！！！！]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>他山之石</tag>
        <tag>生活随笔</tag>
        <tag>fun sth for acm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客暑假多校第五场]]></title>
    <url>%2FACM%2Fnowcodersummer-5th.html</url>
    <content type="text"><![CDATA[题目链接 密码：l9sn终于不爆零了，但是还是wa了无数次，有时候代码感觉都差不多G-max12345678910111213141516171819202122232425262728/*//wa#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,c;//好像不会爆int吧，头晕 cin&gt;&gt;c&gt;&gt;n; int t=n/c; if(t&lt;1) cout&lt;&lt;"-1\n";// else if(t==1) cout&lt;&lt;c*c&lt;&lt;endl; else cout&lt;&lt;(t*c)*((t-1)*c)&lt;&lt;endl; return 0;&#125;*///AC#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; long long n,c; cin&gt;&gt;c&gt;&gt;n; long long t=n/c; if(t&lt;1) cout&lt;&lt;-1&lt;&lt;endl; else if(t==1) cout&lt;&lt;c*c&lt;&lt;endl; else cout&lt;&lt;(t*c)*((t-1)*c)&lt;&lt;endl; return 0;&#125;J-plan1234567891011121314151617181920212223242526272829/*枚举所有情况全买双人n%2 0 or 1//剩1个人的时候，可以多开一间房或者退一间2人房开一间3人房全买3人n%3 0 or 1 or 2再比较大小*/#include&lt;bits/stdc++.h&gt;#define INF 1&lt;&lt;20using namespace std;typedef long long ll;ll min(ll a,ll b)&#123; return a&lt;b?a:b;&#125;int main()&#123; ll n,p2,p3,sum,sum1; while(cin&gt;&gt;n&gt;&gt;p2&gt;&gt;p3)&#123; if(n%2==0) sum=p2*(n/2); else sum=p2*(n/2)+min(min(p2,p3),p3-p2);//退二买三； if(n%3==0) sum1=p3*(n/3); else if(n%3==1) sum1=p3*(n/3)+min(min(p2,p3),2*p2-p3);//退3买2*2 else if(n%3==2) sum1=p3*(n/3)+min(p3,p2);//退3买3*2 cout&lt;&lt;min(sum1,sum)&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[食物链-poj1182（带权并查集经典模板）]]></title>
    <url>%2FACM%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fpoj1182.html</url>
    <content type="text"><![CDATA[题目链接思路参考1,思路参考2（没看懂）先占坑，有时间再理理思路。同一棵树中d=1,即x和y是同类，则需满足r[x]==r[y]d=2,x应该吃了y,也就是(r[x]+1)%3 == r[y] 不同树合并且更新关系(x树做主根)‘ 如果 x和y为关系r1, y和z为关系r2， 那么x和z的关系就是（r1+r2）%3如果 d==1则x和y是同类 ，那么 y对x的关系是0,如果d==2 ,则x吃了y, 那么y对x的关系是1, x对y的关系是2。综上所述 ,无论d为1或者是为2, y对x的关系都是 d-1。fy对y 的关系为 3-r[y] （有点互补的感觉，注意这里是不同类喔）y对x的关系为 d-1,x 对fx 的关系为 r[x]所以fy对fx 的关系是（3-r[y] + d-1 + r[x]）%3。可以借助向量图理解 fy-&gt;y-&gt;x-&gt;fx1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt; const int maxn = 50000+10; int p[maxn]; //存父节点int r[maxn];//存与父节点的关系 0 同一类，1被父节点吃，2吃父节点 void set(int n) //初始化&#123; for(int x = 1; x &lt;= n; x++) &#123; p[x] = x; //开始自己是自己的父亲节点 r[x] = 0;//开始自己就是自己的父亲，每一个点均独立 &#125;&#125; int find(int x) //找父亲节点&#123; if(x == p[x]) return x; int t = p[x]; p[x] = find(p[x]); r[x] = (r[x]+r[t])%3; //回溯由子节点与父节点的关系和父节点与根节点的关系找子节点与根节点的关系 return p[x];&#125; void Union(int x, int y, int d)&#123; int fx = find(x); int fy = find(y); p[fy] = fx; //合并树 注意：被 x 吃，所以以 x 的根为父 r[fy] = (r[x]-r[y]+3+(d-1))%3; //对应更新与父节点的关系&#125; int main()&#123; int n, m; scanf("%d%d", &amp;n, &amp;m); set(n); int ans = 0; int d, x, y; while(m--) &#123; scanf("%d%d%d", &amp;d, &amp;x, &amp;y); if(x &gt; n || y &gt; n || (d == 2 &amp;&amp; x == y)) ans++; //如果节点编号大于最大编号，或者自己吃自己，说谎 else if(find(x) == find(y)) //如果原来有关系，也就是在同一棵树中，那么直接判断是否说谎 &#123; if(d == 1 &amp;&amp; r[x] != r[y]) ans++; //如果 x 和 y 不属于同一类 if(d == 2 &amp;&amp; (r[x]+1)%3 != r[y]) ans++; // 如果 x 没有吃 y (注意要对应Uinon(x, y)的情况，否则一路WA到死啊！！！) &#125; else Union(x, y, d); //如果开始没有关系，则建立关系 &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>POJ</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小希的迷宫-HDU-1272(并查集or树性质)]]></title>
    <url>%2FACM%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F%2Fhdu1272.html</url>
    <content type="text"><![CDATA[题目链接：小希的迷宫并查集：无回路单连通并查集做，首先想到的是判断两个点是否连通，不连通就合并，已连通的话说明会形成回路，则可以判定No，交了一发错了。想了一下没有考虑到多个连通域的情况，该题必须只有一个连通域树的性质：既然单连通无回路，则这肯定是一棵树；那么edge=v-1;最后注意空树的情况，至于自环我这里No也过了，没有去验证自环Yes的情况了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//并查集#include&lt;bits/stdc++.h&gt;using namespace std;int pre[100001];int find(int root)&#123; int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root)&#123; t=pre[son]; pre[son]=root; son=t; &#125; return root;&#125;void join(int a,int b)&#123; int x=find(a),y=find(b); if(x!=y) pre[y]=x;&#125;int main()&#123; int a,b,flag,i,sum; while(1) &#123; flag = 0; while(~scanf("%d%d",&amp;a,&amp;b) &amp;&amp; a!=0 &amp;&amp; b!=0)&#123; if(a==-1 &amp;&amp; b==-1) return 0; if(pre[a]==0)pre[a]=a; if(pre[b]==0)pre[b]=b; if(find(a)==find(b))flag = 1; else if(flag!=1) join(a,b); &#125; for(sum = 0,i=1;i&lt;100001;i++)&#123; if(pre[i]==i)sum++; pre[i] = 0; &#125; if(sum&gt;1 || flag == 1) printf("No\n"); else printf("Yes\n"); &#125;&#125;//1 2 3 4 0 0 No 没有连通//0 0 Yes//1 1 0 0 No(该代码)12345678910111213141516171819202122232425262728293031//树性质#include &lt;stdio.h&gt;bool s[100001];int main()&#123; int a,b,i,len,num,v; for(i=0;i&lt;100001;++i) s[i]=false; len=0,num=0,v=0; while(1) &#123; scanf("%d%d",&amp;a,&amp;b); if(a==-1&amp;&amp;b==-1) break; if(a==0&amp;&amp;b==0) &#123; if(v==0) &#123; printf("Yes\n"); continue; &#125; if(num==len-1) //划重点！！ printf("Yes\n"); else printf("No\n"); num=len=v=0; for(i=0;i&lt;100001;++i) s[i]=false; continue; &#125; v=1; if(s[a]==false) len++;//点数 if(s[b]==false) len++; s[a]=s[b]=true; num++;//边数 &#125; return 0;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小希的迷宫-HDU-1272(并查集or树性质)]]></title>
    <url>%2FACM%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fhdu1272.html</url>
    <content type="text"><![CDATA[题目链接：小希的迷宫并查集：无回路单连通并查集做，首先想到的是判断两个点是否连通，不连通就合并，已连通的话说明会形成回路，则可以判定No，交了一发错了。想了一下没有考虑到多个连通域的情况，该题必须只有一个连通域树的性质：既然单连通无回路，则这肯定是一棵树；那么edge=v-1;最后注意空树的情况，至于自环我这里No也过了，没有去验证自环Yes的情况了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//并查集#include&lt;bits/stdc++.h&gt;using namespace std;int pre[100001];int find(int root)&#123; int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root)&#123; t=pre[son]; pre[son]=root; son=t; &#125; return root;&#125;void join(int a,int b)&#123; int x=find(a),y=find(b); if(x!=y) pre[y]=x;&#125;int main()&#123; int a,b,flag,i,sum; while(1) &#123; flag = 0; while(~scanf("%d%d",&amp;a,&amp;b) &amp;&amp; a!=0 &amp;&amp; b!=0)&#123; if(a==-1 &amp;&amp; b==-1) return 0; if(pre[a]==0)pre[a]=a; if(pre[b]==0)pre[b]=b; if(find(a)==find(b))flag = 1; else if(flag!=1) join(a,b); &#125; for(sum = 0,i=1;i&lt;100001;i++)&#123; if(pre[i]==i)sum++; pre[i] = 0; &#125; if(sum&gt;1 || flag == 1) printf("No\n"); else printf("Yes\n"); &#125;&#125;//1 2 3 4 0 0 No 没有连通//0 0 Yes//1 1 0 0 No(该代码)12345678910111213141516171819202122232425262728293031//树性质#include &lt;stdio.h&gt;bool s[100001];int main()&#123; int a,b,i,len,num,v; for(i=0;i&lt;100001;++i) s[i]=false; len=0,num=0,v=0; while(1) &#123; scanf("%d%d",&amp;a,&amp;b); if(a==-1&amp;&amp;b==-1) break; if(a==0&amp;&amp;b==0) &#123; if(v==0) &#123; printf("Yes\n"); continue; &#125; if(num==len-1) //划重点！！ printf("Yes\n"); else printf("No\n"); num=len=v=0; for(i=0;i&lt;100001;++i) s[i]=false; continue; &#125; v=1; if(s[a]==false) len++;//点数 if(s[b]==false) len++; s[a]=s[b]=true; num++;//边数 &#125; return 0;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How Many Answers Are Wrong-hdu3038(带权并查集)]]></title>
    <url>%2FACM%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fhdu3038.html</url>
    <content type="text"><![CDATA[题目链接：How Many Answers Are Wrong思路参考：本题直接参考,图文解释123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;int pre[200010],ranks[200010];int find(int root)&#123; if(pre[root] != root) &#123; int f = pre[root]; pre[root] = find(pre[root]);//递归路径压缩 ranks[root] += ranks[f]; /*精髓假如一开始没关系，那么用rank数组来表示a，b各自到各自祖先的距离。 那么在把a的祖先给b的祖先当父亲之后，那么b到祖先的距离也就是rank[b]就要再加上b原本的祖先到a的祖先的距离，更新一下， 其中find函数（找根节点的函数）里rank[x]+=rank[pre[x]]（这里pre数组存的是对应数的父节点）*/ &#125; return pre[root];&#125;int main()&#123; int n,m; while(~scanf("%d%d",&amp;n,&amp;m))&#123; int ans=0; for(int i=1; i&lt;=n; i++) pre[i]=i; memset(ranks,0,sizeof(ranks)); while(m--)&#123; int a,b,c; scanf("%d%d%d",&amp;a,&amp;b,&amp;c); a--;//[a,b]~~(a--,b] int fa=find(a); int fb=find(b); if(fa!=fb)&#123; pre[fb]=fa;//注意合并顺序，反过来下面的也要改 ranks[fb]=ranks[a]-ranks[b]+c;//更新距离 &#125; else &#123; if(ranks[b]-ranks[a]!=c) ans++; &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bear and Finding Criminals-Codeforces680B]]></title>
    <url>%2FACM%2FCodeforces680B.html</url>
    <content type="text"><![CDATA[题目链接：Bear and Finding Criminals大致题意就是小熊警察住在某个城市，他要抓各个城市的罪犯，现在用一个BCD可以知道那个城市里一定有罪犯。一定能确定该城市有小偷的几种情况：1.警察所住城市有罪犯，则一定能检测到2.警察所住城市的左边和右边位置若都不为0，则说明两座城市都有罪犯（只有一边为1是不能确定到底哪个城市有罪犯的）3.警察所在城市的一边检测到有罪犯，但在另一边已经没有城市了，则说明该城市一定有罪犯12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int t[107];int main()&#123; int n, a; while(cin&gt;&gt;n&gt;&gt;a)&#123; int sum = 0; for(int i =1; i &lt;= n; i++) cin &gt;&gt; t[i]; if(t[a]) sum++;//小熊所在城市有罪犯 for(int i = 1; i &lt;= n; i++)&#123; if(a-i &gt; 0&amp;&amp;a+i &lt;= n) &#123; if(t[a-i] == 1&amp;&amp;t[a+i] == 1) sum+=2; &#125; else if(a-i &lt;= 0&amp;&amp;a+i &lt;= n)&#123;//警察在第一个点 if(t[a+i]) sum++; &#125; else if(a-i &gt; 0&amp;&amp;a+i &gt; n)&#123; if(t[a-i]) sum++; &#125; &#125; cout &lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bear and Five Cards-Codeforces680A]]></title>
    <url>%2FACM%2FCodeforces680A.html</url>
    <content type="text"><![CDATA[题目链接：Bear and Five Cards大致题意就是小熊有5张卡片，每张卡片有对应的分数，他可以选择丢弃2张相同的或者3张相同的卡片，没有相同的就无法丢弃，问小熊剩下的分数最少是多少。没有想得那么复杂，由于分数最大才100，所以直接暴力就好了。。。123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int a[5],b[107],i,j,sum=0,sum1=0; for(i=0;i&lt;5;i++)&#123; cin&gt;&gt;a[i]; sum+=a[i]; &#125; sort(a,a+5); memset(b,0,sizeof(b)); for(i=0;i&lt;5;i++) b[a[i]]++; for(i=0;i&lt;107;i++)&#123; if(b[i]==2) sum1=max(2*i,sum1); if(b[i]&gt;=3) &#123;sum1=max(3*i,sum1);/*cout&lt;&lt;3*i&lt;&lt;" "&lt;&lt;sum1&lt;&lt;endl;*/&#125; &#125; cout&lt;&lt;sum-sum1&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how many tables-HDU-1213(并查集求连通域数目)]]></title>
    <url>%2FACM%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fhow-tables.html</url>
    <content type="text"><![CDATA[并查集求连通域数目，初始化sum=n；题目链接： how many tables123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;int pre[1005];int find(int root)&#123; int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root)&#123; t=pre[son]; pre[son]=root; son=t; &#125; return root;&#125;int main()&#123; int n,m,t,sum,root1,root2; cin&gt;&gt;t; while(t--)&#123; cin&gt;&gt;n&gt;&gt;m; sum=n; for(int i=1;i&lt;=n;i++) pre[i]=i; for(int i=0;i&lt;m;i++)&#123; cin&gt;&gt;root1&gt;&gt;root2; int xx=find(root1); int yy=find(root2); if(xx!=yy)&#123; pre[xx]=yy; sum--; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The-suspects-POJ-1611(并查集)]]></title>
    <url>%2FACM%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2FThe-suspects.html</url>
    <content type="text"><![CDATA[题目链接：The-suspects翻译：警察抓贩毒集团。有不同类型的犯罪集团，人员可能重复，集团内的人会相互接触。现在警察在其中一人（0号）身上搜出毒品，认为与这个人直接接触或通过其他人有间接接触的人都是嫌疑犯。问包括0号犯人共有多少嫌疑犯？Input多样例输入。每个测试用例以两个整数n和m开头，其中n为人数，m为犯罪集团数。你可以假定0 &lt; n &lt;= 30000和0 &lt;= m &lt;= 500。在所有的情况下，每个人都有自己独特的整数编号0到n−1, 且0号是公认的嫌疑犯。接下来m行输入，每个犯罪集团一行。每一行从一个整数k开始，它本身表示集团内成员的数量。按照成员的数量，在这个组中有k个整数表示人员。一行中的所有整数都被至少一个空格隔开。n = 0且m = 0时输入结束。Output对于每个样例，输出嫌疑犯人数。Sample Input100 42 1 25 10 13 11 12 142 0 12 99 2200 21 55 1 2 3 4 51 00 0Sample Output411这题也很好理解，AC代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;int pre[30010],x[30010];int find(int root)&#123; int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root)&#123; t=pre[son]; pre[son]=root; son=t; &#125; return root;&#125;void join(int x,int y)&#123; int fx=find(x),fy=find(y); if(fx!=fy) pre[fy]=fx;&#125;int main()&#123; int n,m,i,k,sum; while(scanf("%d%d",&amp;n,&amp;m),n||m)&#123; sum=0; for(i=0;i&lt;n;i++) pre[i]=i; while(m--)&#123; scanf("%d",&amp;k); for(i=0;i&lt;k;i++) scanf("%d",&amp;x[i]); for(i=1;i&lt;k;i++) join(x[i-1],x[i]); &#125; for(i=0;i&lt;n;i++) if(find(0)==find(i)) sum++;//再次查找并压缩路径，注不用pre[i] printf("%d\n",sum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>POJ</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wireless network-POJ-2236(并查集)]]></title>
    <url>%2FACM%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2Fwireless-network.html</url>
    <content type="text"><![CDATA[题目链接：wireless network翻译：南亚发生了一次地震。ACM (Asia Cooperated Medical 亚洲联合医疗队) 已经为膝上型电脑搭建了一个无线网络，但受到了一次不可预知的余震攻击，因此网络中的所有电脑都被破坏了。电脑被逐台修复，网络逐步恢复了工作。由于受到硬件的约束，每台电脑只能与距离它不超过 d 米的其它电脑直接通信。但每台电脑可被看作其它两台电脑的通信中转点，也就是说，如果电脑 A 和电脑 B 可以直接通信，或存在一台电脑 C 既可与 A 也可与 B 通信，那么电脑 A 和电脑 B 之间就能够通信。在处理网络修复的过程中，工作人员们在任何一个时刻，可以执行两种操作：维修一台电脑，或测试两台电脑是否能够通信。请您找出全部的测试操作。输入第一行包含了两个整数 N 和 d (1 &lt;= N &lt;= 1001, 0 &lt;= d &lt;= 20000)。此处 N 是电脑的数目，编号从 1 到 N；同时，D 是两台电脑之间能够直接通信的最大距离。接下来的 N 行，每行包含两个整数 xi, yi (0 &lt;= xi, yi &lt;= 10000)，表示 N 台电脑的坐标。从第 (N+1) 行到输入结束，是逐一执行的操作，每行包含一个操作，格式是以下两者之一：“O p” (1 &lt;= p &lt;= N)，表示维护电脑 p 。“S p q” (1 &lt;= p, q &lt;= N)，表示测试电脑 p 和 q 是否能够通信。输入不超过 300000 行。输出对于每个测试操作，如果两台电脑能够通信，则打印 “SUCCESS”；否则，打印 “FAIL”。示例输入4 10 10 20 30 4O 1O 2O 4S 1 4O 3S 1 4示例输出FAILSUCCESSAC代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include "iostream"#include "cstring"using namespace std;int pre[1005];int x[1005],y[1005],use[1005];int findd(int root)&#123; int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root)&#123; t=pre[son]; pre[son]=root; son=t; &#125; return root;&#125;void join(int x,int y)&#123; int fx=findd(x),fy=findd(y); if(fx!=fy) pre[fx]=fy;&#125;int dis(int i,int num,int d)&#123; d=d*d; int xx=x[i]-x[num]; int yy=y[i]-y[num]; if((xx*xx+yy*yy)&lt;=d) return 1; return 0;&#125;int main()&#123; int n,d; char s; memset(use,0,sizeof(use)); cin&gt;&gt;n&gt;&gt;d; for(int i=0;i&lt;=n;i++) pre[i]=i; for(int i=1;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;y[i]; while(cin&gt;&gt;s)&#123; if(s=='O')&#123; int num; cin&gt;&gt;num; use[num]=1; findd(num);//路径压缩 for(int i=1;i&lt;=n;i++) if(i!=num&amp;&amp;use[i]==1&amp;&amp;dis(i,num,d))//修好了，且可以被合并（自己除外） join(i,num); &#125; else if(s=='S')&#123; int q,p; cin&gt;&gt;q&gt;&gt;p; if(findd(q)==findd(p)) cout&lt;&lt;"SUCCESS"&lt;&lt;endl; else cout&lt;&lt;"FAIL"&lt;&lt;endl; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>POJ</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Piles-with-stones]]></title>
    <url>%2FACM%2FPiles-with-stones.html</url>
    <content type="text"><![CDATA[Codeforces Round #500 (Div. 2)题目链接：Piles With Stones大致题意就是有n堆石头，第一天每堆有一定数目的石头，第二天石头可能被小朋友移动或者带走，求满足题意的两天的石碓；所以第二天的石头总数不会大于第一天的，所以是sum1-sum2&gt;=0即可。//又只打了一道题，扣了80多分。。。1234567891011121314151617181920#include&lt;bits/stdc++.h&gt;using namespace std;int x[55],y[55],n,s1=0,s2=0;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;x[i]); s1+=x[i]; &#125; for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;y[i]); s2+=y[i]; &#125; if((s1-s2)&gt;=0) printf("Yes\n"); else printf("No\n"); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[畅通工程-HDU-1232(并查集经典模板)]]></title>
    <url>%2FACM%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B.html</url>
    <content type="text"><![CDATA[并查集入门推荐：超有爱的并查集~题目链接：畅通工程题意分析：首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int pre[1010];int findd(int root)&#123; int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root)&#123; t=pre[son]; pre[son]=root; son=t; &#125; return root;&#125;int main()&#123; int n,m,i,sum,r1,r2,star,end1; while(scanf("%d",&amp;n)&amp;&amp;n)&#123; sum=n-1; for(i=1;i&lt;=n;i++) pre[i]=i; scanf("%d",&amp;m); while(m--)&#123; scanf("%d%d",&amp;star,&amp;end1); r1=findd(star); r2=findd(end1); if(r1!=r2)&#123; pre[r1]=r2; sum--; &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125;基础回顾：find()函数找根结点的两种写法如下：第一种递归：1234int find(int x)&#123; return x == pre[x] ? x : find(pre[x]);&#125;第二种：1234567891011121314int find(int x)&#123; int root, temp; root = x; while(root != pre[root]) root = pre[root]; while(x != root) &#123; temp = pre[x]; pre[temp] = root; x = temp; &#125; return root;&#125;合并函数123456void join(int x,int y)&#123; int fx=find(x); int fy=find(y); if(fx!=fy) pre[fx]=fy;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>HDU</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客练习赛23]]></title>
    <url>%2FACM%2F%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23.html</url>
    <content type="text"><![CDATA[两题水过，暴力，找规律。。托米的赌球托米的划分a12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int c[13],d[13]=&#123;100,50,20,10,5,2,1,50,20,10,5,2,1&#125;; int i,t; cin&gt;&gt;t; int a,b; while(t--)&#123; memset(c,0,sizeof(c)); cin&gt;&gt;a&gt;&gt;b; for(i=0;i&lt;7;i++)&#123; int x=0; if(a&gt;c[i])&#123; x=a/d[i]; c[i]+=x; a-=x*d[i]; &#125; &#125; for(i=7;i&lt;13;i++)&#123; int x=0; if(b&gt;c[i])&#123; x=b/d[i]; c[i]+=x; b-=x*d[i]; &#125; &#125; cout&lt;&lt;c[0]; for(i=1;i&lt;13;i++) cout&lt;&lt;" "&lt;&lt;c[i]; cout&lt;&lt;endl; &#125; return 0;&#125;bf(n)=f(n-1)+n-1;12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;long long sum;int main()&#123; int n; int t; cin&gt;&gt;t; while(t--)&#123; sum=1; cin&gt;&gt;n; if(n==1) sum=0; for(int i=3;i&lt;=n;i++) sum+=i-1; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客这些事]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Fbugs.html</url>
    <content type="text"><![CDATA[博客日志2019.01.22 -- 更换腾讯云对象存储可能存储方式的不同，每个目录的访问必须以/结尾。比如lruihao.cn/about是无法访问的，得访问lruihao.cn/about/2019.01.12 -- 博客UV过万2018.10.29 -- 网站ICP和公安备案完成2018.08.28 -- 第一次收到france支持 赞助记录2018.09.05 -- 博客一百天，PV过万2018.06 ~ 2018.09 -- 接入百度站长，seo优化，加入评论、客服、访客统计等 创建RUI豪小栈2018.05.28 20:01:01 -- 博客诞生 博客搭建及美化教程BUGs日常BUG记录，欢迎大家找出其他bug!CPU占用过高前两天收到网友的反馈，说我的网站打开CPU占用80%多，我以前都没想过这些性能问题，突然出现就慌了，一开始怀疑是js的原因，后来又有人反馈截图说他的电脑上正常，不过在win10的电脑上就很高，后来在浏览器中吧js加载关掉就正常了，说明就是js造成的，虽然不懂js，不过为了解决这个致命的问题还是硬着头皮，在翻next源码中，自己用过的js,翻了一整天没找出结果，期间还麻烦晓剑帮我找了。知道今天又找了一上午才找到，罪魁祸首，是next提供的动态壁纸，后来测试了一下，那些动态壁纸都会让CPU飚起来，不知道是我改了什么源码的原因，还是静态壁纸和动态壁纸不能一起用的原因。不过总之这个问题吧已经解决，开心。杂七杂八使用hexo-all-minifier压缩博文，导致打赏button失效；原因：压缩倒是button那块div，有一个叫&#39;QR&#39;的id,压缩后变成小写&#39; qr&#39;解决方法：取消html或js压缩；或者取消压缩打赏文件reward.swig（未测试）；打开reward.swig把第三行中的document.getElementById(&#39;QR&#39;);改为document.getElementById(&amp;quot;QR&amp;quot;);；评论gitalk评论插件，由于我没有对文章标题id进行md5等转码，所以在较长标题博客下可能造成github登录失败等原因以至于无法评论，所以评论不太友好，大佬略过，这个bug目前我不打算修复(我换了gitment评论)，懒！然后如果实在有啥问题可以在右边栏的在线客服那里在线联系我，也可以加上面的联系方式联系我！（我也是小白哈哈哈哈哈！）gitment bug，解决gitalk大部分问题，但是还是存在以下问题：手机浏览器无法登陆的问题，目测手机浏览器对文章标题转码导致。解决方案：去一篇标题短的文章下面登陆再回来评论。文章标题还是不能太长，我并没有将id做转码缩短处理，只是对github中文lable简单地处理了一下。gitment在我双线部署后，被我抛弃了，其实我挺喜欢gitment的Markdown语法功能的，但是比较适合github.io这种域名的，主要是登陆问题，我觉得是返回值啥的，gitment的仓库在github上。就这样吧，用来必力评论吧，虽然是韩国的，加载会慢点，不过没关系，反正没人评论，都是我自己记录，足够了！！！彩蛋www.lruihao.cn和lruihao.cn的评论是不一样的在留言页面地址后面加/index.html ,这个的隐藏评论区hhhh，同样有第一种的区别无论哪个域名，在主页后加“ /love/ ”,可以看到我和女票的一些小故事当然有密码的hhhh由于入口隐藏，所以比较隐蔽，算彩蛋也算bug吧，有时候利用这些bug写写东西也不错，就这样吧！按下F12打开浏览器调试工具，在console可以看到一些“有趣”的东西- _ -!网站背景亮度调节Alt+Z: 打开夜间模式Alt+X: 关闭Alt+↑: 增加亮度Alt+↓: 降低亮度还有好多好多bug，有bug就有bug吧，不改了，越改越多::&gt; _ &lt;::]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>BUG</tag>
        <tag>通用</tag>
        <tag>博客日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线离线算法]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2F%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[在线算法在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。在计算机科学中，一个在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。相对的，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。例如，选择排序在排序前就需要知道所有待排序元素，然而插入排序就不必。因为在线算法并不知道整个的输入，所以它被迫做出的选择最后可能会被证明不是最优的，对在线算法的研究主要集中在当前环境下怎么做出选择。对相同问题的在线算法和离线算法的对比分析形成了以上观点。如果想从其他角度了解在线算法可以看一下 流算法（关注精确呈现过去的输入所使用的内存的量），动态算法（关注维护一个在线输入的结果所需要的时间复杂度）和在线机器学习。一个很好的展示在线算法概念的例子是 加拿大旅行者问题，这个问题的目标是在一个有权图中以最小的代价到达一个目标节点，但这个有权图中有些边是不可靠的可能已经被剔除。然而一个旅行者只有到某个边的一个端点时才能确定该边是否已经被移除了。最坏情况下，该问题会变得简单了，即所有的不确定的边都被移除该问题将会变成通常的最短路径问题。离线算法离线算法( off line algorithms)，是指基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。设计策略 在执行算法前输入已知的基本假设前提 具有问题完全信息算法设计策略都是基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果，通常将这类具有问题完全信息前提下设计出的算法称为离线算法( off line algorithms)]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU-1495-非常可乐（bfs模拟倒水or数论）]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2FHDU%20-%201495-%E9%9D%9E%E5%B8%B8%E5%8F%AF%E4%B9%90%20%EF%BC%88bfs%E6%A8%A1%E6%8B%9F%E5%80%92%E6%B0%B4%20%20or%20%E6%95%B0%E8%AE%BA%EF%BC%89.html</url>
    <content type="text"><![CDATA[非常可乐大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S&lt;101）毫升 (正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出”NO”。Input三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以”0 0 0”结束。Output如果能平分的话请输出最少要倒的次数，否则输出”NO”。Sample Input7 4 34 1 30 0 0Sample OutputNO3模拟一下倒水的过程，一共有三种倒法，a向bc，b向ac，c向ab。(相当于一共六个方向)搜索并记录搜索过的过程就好了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include&lt;bits/stdc++.h&gt;using namespace std;int a,b,c;int used[111][111][111];struct node&#123; int x,y,z; int step;&#125;m,n;int bfs()&#123; queue&lt;node&gt;q; m.x = a; m.y = 0; m.z = 0; m.step = 0; used[a][0][0] = 1; q.push(m); while (!q.empty()) &#123; int trans; //倒水量 m = q.front(); q.pop(); //成功分好的三种情况 if ((m.x == 0 &amp;&amp; m.y == m.z) || (m.y == 0 &amp;&amp; m.x == m.z) || (m.z == 0 &amp;&amp; m.x == m.y)) return m.step; //下面开始6个搜索（由一个杯子向另外两个倒水） if (m.x) &#123; //第一 trans = min(m.x , b - m.y);//自己模拟一下倒水过程就知道了 n.x = m.x - trans; n.y = m.y + trans; n.z = m.z; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) &#123; q.push(n); used[n.x][n.y][n.z] = 1; &#125; //第二 trans = min(m.x , c - m.z); n.x = m.x - trans; n.y = m.y; n.z = m.z + trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) &#123; q.push(n); used[n.x][n.y][n.z] = 1; &#125; &#125; if (m.y) &#123; //第三 trans = min(m.y , a - m.x); n.x = m.x + trans; n.y = m.y - trans; n.z = m.z; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) &#123; used[n.x][n.y][n.z] = 1; q.push(n); &#125; //第四 trans = min(m.y , c - m.z); n.x = m.x; n.y = m.y - trans; n.z = m.z + trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) &#123; used[n.x][n.y][n.z] = 1; q.push(n); &#125; &#125; if (m.z) &#123; //第五 trans = min(m.z , a - m.x); n.x = m.x + trans; n.y = m.y; n.z = m.z - trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) &#123; used[n.x][n.y][n.z] = 1; q.push(n); &#125; //第六 trans = min(m.z , b - m.y); n.x = m.x; n.y = m.y + trans; n.z = m.z - trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) &#123; q.push(n); used[n.x][n.y][n.z] = 1; &#125; &#125; &#125; return 0;&#125;int main()&#123; while (~scanf ("%d %d %d",&amp;a,&amp;b,&amp;c) &amp;&amp; (a || b || c)) &#123; if (a&amp;1) //先简单的剪枝一下,奇数肯定不能平分 printf ("NO\n"); else &#123; memset (used,0,sizeof (used)); int ans = bfs(); if (ans) printf ("%d\n",ans); else printf ("NO\n"); &#125; &#125; return 0;&#125;然后杭电上讨论板子上提供一种数论题解，但是数据存在一点问题，只不过有些数据好像不对；比如： 10 6 5的结果应该是1而不是9， 也提示我们多维思考同一个问题！数论推导12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int s,n,m; while(cin&gt;&gt;s&gt;&gt;n&gt;&gt;m,s+n+m)&#123; s/=__gcd(n,m); if(s&amp;1)//奇数 cout&lt;&lt;&quot;NO\n&quot;; else cout&lt;&lt;s-1&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>搜索</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-2612-Find a way（双bfs）]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2Fhdu-2612-Find-a-way%EF%BC%88%E5%8F%8Cbfs%EF%BC%89.html</url>
    <content type="text"><![CDATA[Find a way圣诞节要到了，坤神和瑞瑞这对基佬想一起去召唤师大峡谷开开车。百度地图一下，发现周围的召唤师大峡谷还不少，这对基佬纠结着，该去哪一个。。。坤神：我要去左边的这个（因为离自己比较近 哈哈~）。。瑞瑞：我要去右边的这个（因为离自己比较近 嘿嘿~） ……..这对基佬闹矛盾了，开车有危险了！ 为了不让他们去召唤师大峡谷坑人，riot决定让他们去X召唤师大峡谷，保证他俩所走的路程和最短。每走一个点需要花费11分钟，输出他们一共花费多少时间（最短时间噢）Input多组测试数据每组数据，开始一行n，m (2&lt;=n,m&lt;=200)接下来是个n x m的矩阵‘Y’ 表示坤神所在的初始位置‘M’ 表示瑞瑞所在的初始位置‘#’ 该点禁止通行‘.’ 该点可通行‘@’ 召唤师大峡谷Output每组测试数据，输出坤神和瑞瑞到达同一个召唤师大峡谷所花费的最短时间。Sample Input4 4Y.#@…..#..@..M4 4Y.#@…..#..@#.M5 5Y..@..#….#…@..M.#...#Sample Output668866Hint对于第一组样例，坤神和瑞瑞去矩阵（4,1） 这个召唤师大峡谷，耗费的时间为 3 11 + 3 11 = 66， 去矩阵（1,4）这个召唤师大峡谷，耗费的时间为 5 11 + 3 11 = 88 。所以，最终答案：66。思路参考写代码总是好粗心！！12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;bits/stdc++.h&gt;#define inf 0x3f3f3f3f //acm中“无穷大”的一般定义using namespace std;const int M=202;char mp[M][M]; //地图int a[M][M],b[M][M];bool vis[M][M]; //标记数组int n,m;int ans;struct node&#123; int x,y,step;&#125;;void init() //初始化函数&#123; ans=inf; for(int i=0; i&lt;n; i++) for(int j=0; j&lt;m; j++) &#123; a[i][j]=inf; b[i][j]=inf; &#125;&#125;void bfs(int x,int y,bool flag)&#123; int dir[4][2]=&#123;-1,0,1,0,0,1,0,-1&#125;; node u,v; queue&lt;node&gt; q; //初始化队列第一个元素 u.x=x; u.y=y; u.step=0; vis[x][y]=true; q.push(u); while(!q.empty())&#123; u=q.front(); q.pop(); if(mp[u.x][u.y]=='@')&#123; if(!flag) a[u.x][u.y]=u.step; else b[u.x][u.y]=u.step; &#125; for(int i=0;i&lt;4;i++)&#123; int tx=u.x+dir[i][0]; int ty=u.y+dir[i][1]; if(tx&gt;=0&amp;&amp;ty&gt;=0&amp;&amp;tx&lt;n&amp;&amp;ty&lt;m&amp;&amp;!vis[tx][ty]&amp;&amp;mp[tx][ty]!='#')&#123;//注意@和M，Y也是可以走的。 v.x=tx; //每次写搜索都忘记vis!!!! v.y=ty; vis[tx][ty]=true; //我总是忘记。。。 v.step=u.step+1; q.push(v); &#125; &#125; &#125;&#125;int main()&#123; while(~scanf("%d%d",&amp;n,&amp;m)) &#123; init(); for(int i=0; i&lt;n; i++) scanf("%s",mp[i]); for(int i=0; i&lt;n; i++) for(int j=0; j&lt;m; j++) &#123; if(mp[i][j]=='Y') &#123; memset(vis,false,sizeof(vis)); bfs(i,j,false); &#125; if(mp[i][j]=='M') &#123; memset(vis,false,sizeof(vis)); //记得再次初始化标记数组 bfs(i,j,true); &#125; &#125; for(int i=0; i&lt;n; i++) for(int j=0; j&lt;m; j++) if(mp[i][j]=='@') ans=min(ans,a[i][j]+b[i][j]); printf("%d\n",ans*11); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>搜索</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-3278-Catch That Cow(bfs)]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2FPOJ%20-%203278%20-Catch%20That%20Cow%20%20(bfs).html</url>
    <content type="text"><![CDATA[Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.Walking: FJ can move from any point X to the points X - 1 or X + 1 in a single minuteTeleporting: FJ can move from any point X to the point 2 × X in a single minute.If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?###InputLine 1: Two space-separated integers: N and K###OutputLine 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.###Sample Input5 17###Sample Output4###HintThe fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes.###题意：农场主的牛不见了，主人和牛在一条直线上，且牛没有新的目标，它不会走动，主人的位置是你n，牛的位置是k，主人可以有三种走路的方法，右左（距离+-1），闪现（距离+x,x为当前位置），每走一步，一分钟，问几分钟主人能找到牛。bfs搜索方向即为三个“方向”。搜索所有走法；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&quot;iostream&quot;#include&lt;queue&gt;#include&quot;string.h&quot;using namespace std;int n,k;bool sign[200007];struct node&#123; int x,step;&#125;;bool check(int a)&#123; if(!sign[a]&amp;&amp;a&gt;=0&amp;&amp;a&lt;110000) return true; return false;&#125;void bfs()&#123; node u,v; queue&lt;node&gt; q; v.x=n;//初始化起点 v.step=0; q.push(v); sign[v.x]=true; while(!q.empty())&#123; u=q.front(); q.pop(); if(u.x==k)&#123; cout&lt;&lt;u.step&lt;&lt;endl; return ; &#125; //三种前进方向，左右和闪现 v=u; v.x++; v.step++; if(check(v.x))&#123; sign[v.x]=true; q.push(v); &#125; v=u; v.x--; v.step++; if(check(v.x))&#123; sign[v.x]=true; q.push(v); &#125; v=u; v.x=2*v.x; v.step++; if(check(v.x))&#123; sign[v.x]=true; q.push(v); &#125; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; memset(sign,0,sizeof(sign)); bfs(); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>BFS</tag>
        <tag>搜索</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-2251-Dungeon Master（三维bfs最短路）]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2Fpoj-2251-Dungeon%20Master%EF%BC%88%E4%B8%89%E7%BB%B4bfs%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89.html</url>
    <content type="text"><![CDATA[英文原题链接Description - 题目描述你被困在一个三维的空间中,现在要寻找最短路径逃生！空间由立方体单位构成你每次向上下前后左右移动一个单位需要一分钟你不能对角线移动并且四周封闭是否存在逃出生天的可能性？如果存在，则需要多少时间？Input - 输入输入第一行是一个数表示空间的数量。每个空间的描述的第一行为L，R和C（皆不超过30）。L表示空间的高度。R和C分别表示每层空间的行与列的大小。随后L层地牢，每层R行，每行C个字符。每个字符表示空间的一个单元。’#’表示不可通过单元，’.’表示空白单元。你的起始位置在’S’，出口为’E’。每层空间后都有一个空行。L，R和C均为0时输入结束。Output - 输出每个空间对应一行输出。如果可以逃生，则输出如下Escaped in x minute(s). x为最短脱离时间。如果无法逃生，则输出如下Trapped!Sample Input - 输入样例123456789101112131415161718192021223 4 5S.....###..##..###.#############.####...###########.#######E1 3 3S###E####0 0 0Sample Output - 输出样例Escaped in 11 minute(s).Trapped!类似二维四个方向的bfs最短路，改成上下东西南北就行了，三维bfs最短路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;char map[35][35][35];int vis[35][35][35];int k,n,m,sx,sy,sz,ex,ey,ez;int to[6][3] = &#123;&#123;0,0,1&#125;,&#123;0,0,-1&#125;,&#123;0,1,0&#125;,&#123;0,-1,0&#125;,&#123;1,0,0&#125;,&#123;-1,0,0&#125;&#125;;//上下东西南北struct node&#123; int x,y,z,step;&#125;;int check(int x,int y,int z)//检查是否可走&#123; if(x&lt;0 || y&lt;0 || z&lt;0 || x&gt;=k || y&gt;=n || z&gt;=m)//越界判断 return 1; else if(map[x][y][z] == '#') return 1; else if(vis[x][y][z]) return 1; return 0;&#125;int bfs()&#123; int i; node a,next; queue&lt;node&gt; Q; a.x = sx,a.y = sy,a.z = sz; a.step = 0; vis[sx][sy][sz] = 1; Q.push(a); while(!Q.empty()) &#123; a = Q.front(); Q.pop(); if(a.x == ex &amp;&amp; a.y == ey &amp;&amp; a.z == ez) return a.step; for(i = 0; i&lt;6; i++) &#123; next = a; next.x = a.x+to[i][0]; next.y = a.y+to[i][1]; next.z = a.z+to[i][2]; if(check(next.x,next.y,next.z)) continue; vis[next.x][next.y][next.z] = 1; next.step = a.step+1; Q.push(next); &#125; &#125; return 0;&#125;int main()&#123; int i,j,r; while(scanf("%d%d%d",&amp;k,&amp;n,&amp;m),n+m+k) &#123; for(i = 0; i&lt;k; i++) &#123; for(j = 0; j&lt;n; j++) &#123; scanf("%s",map[i][j]); for(r = 0; r&lt;m; r++) &#123; if(map[i][j][r] == 'S') &#123; sx = i,sy = j,sz = r; &#125; else if(map[i][j][r] == 'E') &#123; ex = i,ey = j,ez = r; &#125; &#125; &#125; &#125; memset(vis,0,sizeof(vis)); int ans; ans = bfs(); if(ans) printf("Escaped in %d minute(s).\n",ans); else printf("Trapped!\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>BFS</tag>
        <tag>搜索</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1321 棋盘问题（dfs）]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2Fpoj-1321%20%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98%EF%BC%88dfs%EF%BC%89.html</url>
    <content type="text"><![CDATA[Time Limit: 1000MSMemory Limit: 10000KTotal Submissions: 63659Accepted: 30423Description在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。Input输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n * n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。Output对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。Sample Input1234567892 1#..#4 4...#..#..#..#...-1 -1Sample Output1221Source蔡错@pku思路下子方案数就相当于遍历图的不同遍历数，用dfs变形。理解以下数据还有样例应该差不多了3 2#...#...#33 2#...##..#4AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char mp[8][8];int v[8];int n,k,w,r;//状态计数器rvoid dfs(int x)//逐行深搜，x为当前搜索行&#123; if(w==k)//下子数w &#123; r++;return; &#125; if(x==n)return; for(int i=0;i&lt;n;i++) &#123; if(v[i]!=1&amp;&amp;mp[x][i]=='#') &#123; v[i]=1; w++; dfs(x+1); w--; v[i]=0; &#125; &#125; dfs(x+1);//搜索下一行&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;k) &#123; if(n==-1&amp;&amp;k==-1) return 0; memset(mp,0,sizeof(mp)); memset(v,0,sizeof(v)); for(int i=0;i&lt;n;i++) cin&gt;&gt;mp[i]; w=0;r=0; dfs(0); cout&lt;&lt;r&lt;&lt;endl; &#125;&#125;传送门]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>搜索</tag>
        <tag>POJ</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-1426-Find The Multiple(dfs)]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2Fpoj%20-%201426%20-Find%20The%20Multiple(dfs).html</url>
    <content type="text"><![CDATA[Find The MultipleTime Limit: 1000MS Memory Limit: 10000KTotal Submissions: 40713 Accepted: 17088 Special JudgeDescriptionGiven a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits.InputThe input file may contain multiple test cases. Each line contains a value of n (1 &lt;= n &lt;= 200). A line containing a zero terminates the input.OutputFor each value of n in the input print a line containing the corresponding value of m. The decimal representation of m must not contain more than 100 digits. If there are multiple solutions for a given value of n, any one of them is acceptable.Sample Input26190Sample Output10100100100100100100111111111111111111给定一个正整数n，请编写一个程序来寻找n的一个非零的倍数m，这个m应当在十进制表示时每一位上只包含0或者1。你可以假定n不大于200且m不多于100位。提示：本题采用Special Judge，你无需输出所有符合条件的m，你只需要输出任一符合条件的m即可。123456789101112131415161718192021222324252627282930#include"iostream"using namespace std;typedef unsigned long long ll;int n;bool sign;void dfs(ll x,int count)&#123; if(sign) return ; if(x%n==0)&#123; sign=true; cout&lt;&lt;x&lt;&lt;endl; return ; &#125; if(count==19)//m最多200位 return ; dfs(x*10,count+1); dfs(x*10+1,count+1); //每两位数后两位有两种情况，10或11，深搜所有情况，找到一种就返回，找不到找另外一颗子树&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; sign=false; dfs(1,0); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>搜索</tag>
        <tag>POJ</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adjacent Replacements]]></title>
    <url>%2FACM%2FAdjacent-Replacements.html</url>
    <content type="text"><![CDATA[A. Adjacent Replacements第一次打cf就做出一道这样的找规律的题，打到自闭。12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n,a[1001]; cin&gt;&gt;n; int i; int flag=0; for(i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; if(!(a[i]&amp;1)) a[i]--; if(!flag) &#123;cout&lt;&lt;a[i];flag=1;&#125; else cout&lt;&lt;" "&lt;&lt;a[i]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[poj-3984-迷宫问题(bfs路径)]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2Fpoj-3984-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98(bfs%E8%B7%AF%E5%BE%84).html</url>
    <content type="text"><![CDATA[迷宫问题Time Limit: 1000MS Memory Limit: 65536KTotal Submissions: 32323 Accepted: 18471Description定义一个二维数组：int maze[5][5] = {0, 1, 0, 0, 0,0, 1, 0, 1, 0,0, 0, 0, 0, 0,0, 1, 1, 1, 0,0, 0, 0, 1, 0,};它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。Input一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。Output左上角到右下角的最短路径，格式如样例所示。Sample Input0 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0Sample Output(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4)对于新手来说，主要是bfs路径的问题有点难度，搞得晕晕的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int map[5][5];int visited[5][5];int dx[4]=&#123;0, 1, 0, -1&#125;;int dy[4]=&#123; 1, 0,-1, 0&#125;;int head,tail;struct node&#123; int xx,yy; int fa;//父节点&#125;pre[25],way[25];void BFS(int x,int y)&#123; int x1,y1; head=0,tail=1; visited[x][y]=1; pre[0].xx=x,pre[0].yy=y; while(tail&gt;head)//栈空 &#123; x=pre[head].xx; y=pre[head].yy; if(x==4&amp;&amp;y==4)//结束标志 return ; for(int i=0;i&lt;4;i++) &#123; x1=x+dx[i];y1=y+dy[i]; if(x1&gt;=0&amp;&amp;x1&lt;=4&amp;&amp;y1&gt;=0&amp;&amp;y1&lt;=4) if(map[x1][y1]==0&amp;&amp;!visited[x1][y1]) &#123; pre[tail].xx=x1; pre[tail].yy=y1; pre[tail].fa=head; visited[x1][y1]=1; tail+=1;//入栈 &#125; &#125; head++;//相当于出栈 &#125;&#125;int main()&#123; int i,j; ios::sync_with_stdio(false); memset(map,0,sizeof(map)); memset(visited,0,sizeof(visited)); for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) cin&gt;&gt;map[i][j]; BFS(0,0); i=0; while(head)//逆序进行赋值输出就是通路 &#123; way[i].xx=pre[head].xx; way[i].yy=pre[head].yy; head=pre[head].fa; i++; &#125; //画一下队列 way[i].xx=0;way[i].yy=0; while(i!=-1) &#123; cout&lt;&lt;"("&lt;&lt;way[i].xx&lt;&lt;", "&lt;&lt;way[i].yy&lt;&lt;")"&lt;&lt;endl; i--; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>BFS</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛20-染色]]></title>
    <url>%2FACM%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B20-%E6%9F%93%E8%89%B2.html</url>
    <content type="text"><![CDATA[链接:https://www.nowcoder.com/acm/contest/133/A来源:牛客网题目描述现在有一棵被Samsara-Karma染了k种颜色的树，每种颜色有着不同的价值,Applese觉得Samsara-Karma染的太难看了，于是打算把整棵树重新染成同一种颜色 但是，由于一些奥妙重重的原因，每一次染色Applese可以选择两个有边相连的点，将其中一个染成另一个的颜色。而进行一次这样的操作需要付出两种颜色价值和的代价，现在，Applese的钱要用来买书(game)，所以他想要最小化代价输入描述:输入包括若干行第一行包括一个数n，表示这棵树有n个节点第二行包括n个数，第i个数表示第i个节点的颜色coli注意：一个颜色的标号即价值接下来的n - 1行，每行包括两个数u, v，表示u节点与v节点之间有一条无向边n ≤ 100000, 1 ≤ coli ≤ 1e9，数据保证是一棵树输出描述:输出包括一行第一行包括一个数，表示最小代价示例1输入42 3 4 31 22 33 4输出12蒟蒻暴力枚举-_-!12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;using namespace std;const int MAXN=1e5+10;int a[MAXN];map&lt;int, int &gt;ma;set&lt;int&gt;se;int x[MAXN],y[MAXN];int main()&#123; int n; scanf("%d",&amp;n); for (int i = 1; i &lt;=n ; ++i) &#123; scanf("%d",&amp;a[i]); se.insert(a[i]); &#125; for (int i = 1; i &lt;n ; ++i) &#123; scanf("%d%d",&amp;x[i],&amp;y[i]); &#125; long long ans=1e14,sum=0; set&lt;int&gt;::iterator it; for (it=se.begin(); it !=se.end() ; ++it) &#123; sum=0; for (int j = 1; j &lt;=n ; ++j) &#123; if((*it)!=a[j]) sum+=((*it)+a[j]); &#125; ans=min(sum,ans); &#125; printf("%lld\n",ans); return 0;&#125;最后想说这都过了什么鬼，不会数据这么弱吧？？！?我只枚举了最小的价值颜色的情况，唉，不管了不管了。12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;int a[1000000],n,m,k=1,t,ans=0;int main()&#123; scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]); sort(a+1,a+n+1); for(int i=2;i&lt;=n;++i) if(a[i]!=a[1]) ans+=a[i]+a[1]; printf(&quot;%d&quot;,ans); return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨辉三角]]></title>
    <url>%2FACM%2F%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92.html</url>
    <content type="text"><![CDATA[百度知道11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 11 6 15 20 15 6 11、每行数字左右对称，由1开始逐渐变大，然后变小，回到1。 2、第n行的数字个数为n个。 3、第n行数字和为2^(n－1)。 4、每个数字等于上一行的左右两个数字之和。可用此性质写出整个帕斯卡三角形。 5、将第2n+1行第1个数，跟第2n+2行第3个数、第2n+3行第5个数……连成一线，这些数的和是第2n个斐波那契数。将第2n行第2个数，跟第2n+1行第4个数、第2n+2行第6个数……这些数之和是第2n-1个斐波那契数。 6、第n行的第1个数为1，第二个数为1×(n-1)，第三个数为1×(n-1)×（n-2）/2，第四个数为1×(n-1)×（n-2）/2×（n-3）/3…依此类推。此数列中各行中的数字正好是二项式a+b乘方后，展开始终各项的系数。如： (a+b)^1=a^1+b^1 (a+b)^2=a^2+2ab+b^2 (a+b)^3=a^3+3a^2b+3ab^2+b^3 …… (a+b)^6=a^6+6a^5b+15a^4b^2+20a^3b^3+15a^2b^4+6ab^5+b^6（注意发现规律） ……二项式展开式：]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>杨辉三角</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hud-1241-Oil Deposits (dfs)]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2Fhud-1241-Oil%20Deposits%20(dfs).html</url>
    <content type="text"><![CDATA[Oil Deposits翻译Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 41406 Accepted Submission(s): 23977Problem DescriptionThe GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid.InputThe input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 &lt;= m &lt;= 100 and 1 &lt;= n &lt;= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ‘ * ‘, representing the absence of oil, or ‘@’, representing an oil pocket.OutputFor each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets.Sample Input1234567891011121314151 1*3 5*@*@***@***@*@*1 8@@****@*5 5 ****@*@@*@*@**@@@@*@@@**@0 0Sample Output0122SourceMid-Central USA 1997RecommendEddy | We have carefully selected several similar problems for you: 1016 1010 1312 1242 1240思路dfs模板题吧，八个方向搜索；（像i，j这样的计数器还是写在局部比较好，我尽然被定义域的问题搞了一晚上醉了醉了。。。）123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,s;char maze[107][107];int vx[8]=&#123;-1,1,0,0,-1,-1,1,1&#125;;int vy[8]=&#123;0,0,-1,1,-1,1,1,-1&#125;;void dfs(int x,int y)&#123; maze[x][y]='*'; for(int i=0;i&lt;8;i++)&#123; int tx=x+vx[i]; int ty=y+vy[i]; if(tx&gt;=0&amp;&amp;tx&lt;m&amp;&amp;ty&gt;=0&amp;&amp;ty&lt;n&amp;&amp;maze[tx][ty]=='@') dfs(tx,ty); &#125;&#125;int main()&#123; int i,j; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m)&#123; s=0; for(i=0;i&lt;m;i++) cin&gt;&gt;maze[i]; for(i=0;i&lt;m;i++)&#123;//相当于不连通的情况 for(j=0;j&lt;n;j++)&#123; if(maze[i][j]=='@')&#123; dfs(i,j); s++; &#125; &#125; &#125; cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>搜索</tag>
        <tag>HDU</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFS求最短路]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2FBFS%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF.html</url>
    <content type="text"><![CDATA[假设有一个n行m列的迷宫，每个单位要么是空地(用1表示)要么是障碍物(用0表示).如和找到从起点到终点的最短路径？利用BFS搜索，逐步计算出每个节点到起点的最短距离，以及最短路径每个节点的前一个节点。最终将生成一颗以起点为根的BFS树。此时BFS可以求出任意一点到起点的距离。图1 3 0 21 232 0 17 20 224 0 14 0 05 0 12 15 186 8 10 0 197 9 11 13 16输入6 51 1 0 1 11 0 1 1 11 0 1 0 01 0 1 1 11 1 1 0 11 1 1 1 1输出1 2 4 5 6 8 10 12 14 17 20 21 2312//最短距离代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int maxn=100+5;int G[maxn][maxn]; //存图的d=idint path[maxn]; //存每个节点的父节点，即路径int n,m; //n行 m列int k=1;//记录编号int end_num;int vx[5] = &#123;-1,1,0,0&#125;; //vx vy用来计算一个节点周围上下左右4个节点int vy[5] = &#123;0,0,-1,1&#125;;bool vis[maxn][maxn]; //判断某节点是否已经被访问过struct node&#123; int x; int y; int id; int parent=0; node(int a,int b,int c) &#123; x=a; y=b; id=c; &#125;&#125;;int main()&#123; //freopen("in.txt","r",stdin); memset(G,0,sizeof(G)); memset(vis,0,sizeof(vis)); memset(path,0,sizeof(path)); cin&gt;&gt;n&gt;&gt;m; for(int i=1; i&lt;=n; i++) for(int j=1; j&lt;=m; j++) &#123; cin&gt;&gt;G[i][j]; &#125; queue&lt;node&gt; q; node v=node(1,1,1); q.push(v); vis[1][1]=1; while(!q.empty()) &#123; node u=q.front(); q.pop(); path[u.id]=u.parent;//记录每个点的父节点 for(int i=0; i&lt;4; i++) &#123; int tx=u.x+vx[i]; int ty=u.y+vy[i]; if(G[tx][ty]&amp;&amp;!vis[tx][ty])//有路可走且未访问 &#123; vis[tx][ty]=1; //cout&lt;&lt;tx&lt;&lt;ty&lt;&lt;endl; node v=node(tx,ty,++k); end_num=k; v.parent=u.id; q.push(v); &#125; &#125; &#125; vector&lt;int&gt; ans; //cout&lt;&lt;end_num&lt;&lt;endl; while(end_num)//从后面开始找父亲节点 &#123; ans.push_back(end_num); end_num=path[end_num]; &#125; int s=0; while(!ans.empty()) &#123; s++; cout&lt;&lt;*(ans.end()-1)&lt;&lt;' ';//ans最后一个元素是0 ans.pop_back(); &#125; cout&lt;&lt;endl&lt;&lt;s-1; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Educational Codeforces Round 47 (Rated for Div. 2)]]></title>
    <url>%2FACM%2FEducational%20Codeforces%20Round%2047%20(Rated%20for%20Div.%202).html</url>
    <content type="text"><![CDATA[那天晚上报名了没打，第二天早上打的，也只出了两题。A. Game Shopping123456789101112131415161718192021222324252627#include&lt;iostream&gt;using namespace std;int main()&#123; int n,m,s=0; cin&gt;&gt;n&gt;&gt;m; int i,j; int c[1000],a[1000]; for(i=0;i&lt;n;i++) cin&gt;&gt;c[i]; for(i=0;i&lt;m;i++) cin&gt;&gt;a[i]; for(i=0,j=0;i&lt;n;)&#123; if(j==m) break; if(c[i]&lt;=a[j])&#123; s++; j++; i++; &#125; else i++; &#125; if(i==n&amp;&amp;s==0) cout&lt;&lt;"0\n"; else cout&lt;&lt;s&lt;&lt;endl; return 0;&#125;B. Minimum Ternary String1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;string s, ans;int main()&#123; cin &gt;&gt; s; int one = 0; for (int i = 0; i &lt; s.size(); i++)&#123; if (s[i] == '0') ans += "0"; if (s[i] == '1') one++; if (s[i] == '2') ans += "2"; &#125; bool flag = false; for (int i = 0; i &lt; ans.size(); i++)&#123; if (ans[i] == '2' &amp;&amp; !flag) flag = true, cout &lt;&lt; string(one, '1'); cout &lt;&lt; ans[i]; &#125; if (!flag) cout &lt;&lt; string(one, '1'); return 0;&#125;/*100210112221212020010202012012101111000*/]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深搜广搜]]></title>
    <url>%2FACM%2F%E6%90%9C%E7%B4%A2%2F%E6%B7%B1%E6%90%9C%E5%B9%BF%E6%90%9C.html</url>
    <content type="text"><![CDATA[广度优先搜索（BFS）广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。访问了就入队。深度优先搜索（DFS）深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define N 5using namespace std;int maze[N][N] = &#123;//无权有向图邻接矩阵 &#123; 0, 1, 0, 1, 0 &#125;, &#123; 0, 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0, 1 &#125;, &#123; 0, 0, 1, 0, 0 &#125;, &#123; 0, 0, 0, 0, 0 &#125; &#125;; int visited[N]; void DFS(int start) &#123; cout &lt;&lt; start&lt;&lt; " "; visited[start] = 1; for (int i = 0; i &lt; N; i++) &#123; if (!visited[i] &amp;&amp; maze[start][i] == 1)//没访问过且为邻居节点 DFS(i); &#125; &#125; void BFS(int start)&#123; queue&lt;int&gt; Q;//队列 Q.push(start); visited[start] = 1; while (!Q.empty()) &#123; int front = Q.front();//头 cout &lt;&lt; front &lt;&lt; " "; Q.pop(); for (int i = 0; i &lt;N; i++) &#123; if (!visited[i] &amp;&amp; maze[front][i] == 1) &#123; visited[i] = 1; Q.push(i); &#125; &#125; &#125; &#125; int main() &#123; memset(visited,0,sizeof(visited)); for (int i = 0; i &lt; N; i++)//不连通的情况 &#123; if (visited[i] == 1)//访问过 continue; DFS(i); &#125; cout&lt;&lt;endl; memset(visited,0,sizeof(visited)); for (int i = 0; i &lt; N; i++)//不连通的情况 &#123; if (visited[i] == 1)//访问过 continue; BFS(i); &#125; return 0; &#125;传送门]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>BFS</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TaoTao要吃鸡]]></title>
    <url>%2FACM%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2FTaoTao%E8%A6%81%E5%90%83%E9%B8%A1.html</url>
    <content type="text"><![CDATA[链接：https://www.nowcoder.com/acm/contest/74/B来源：牛客网题目描述Taotao的电脑带不动绝地求生，所以taotao只能去玩pc版的荒野行动了，和绝地求生一样，游戏人物本身可以携带一定重量m的物品，装备背包之后可以多携带h（h为0代表没有装备背包）重量的东西。玩了几天taotao发现了一个BUG，当装备背包之后，如果可携带重量没有满，就可以拿一个任意重的东西。（解释看样例）有一天taotao空降到了一个奇怪的岛上，岛上有n件装备，每个装备都有重量Wi和威力值Vi,但taotao不认识这些装备，所以他来求助你，挑选威力最大的装备，帮助他吃鸡。输入描述:本题有多组输入（小于10），当n=0时结束输入。第一行输入n,m,h。n，m，h为整数，并且0&lt;=n,m,h&lt;=100，接下来n行，每行输入第i个物品的物品的重量Wi和威力值Vi。0&lt;=Wi,Vi&lt;=100.输出描述:输出最大威力值，每组输出一行。示例1输入3 3 32 33 22 30输出8说明可携带的总重量为6，当拿了前两件装备，此时容量为5/6，还可以再拿第三件物品。思路：0-1背包的变形题目，h=0的时候为背包的模板，h！=0的时候枚举每一个需要特殊处理的物品再背包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;int v[105];int w[105];int n,m,h;int dp[205];int main()&#123; while(scanf("%d",&amp;n)==1&amp;&amp;n!=0)&#123; int sum=0; scanf("%d%d",&amp;m,&amp;h); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;w[i],&amp;v[i]); if(h==0)&#123; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++) //前i个物品 for(int j=m;j&gt;=w[i];j--) //枚举背包重量 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); // sum=dp[m]; &#125; else&#123; m+=h for(int k=1;k&lt;=n;k++) //枚举可以被剩下的物品 &#123; memset(dp,0,sizeof(dp)); for(int i=1;i&lt;=n;i++)&#123; //前i个物品 if(i!=k)&#123; for(int j=m;j&gt;=w[i];j--) //枚举背包重量 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); &#125; &#125; //留下来一个重量，即初始化威力为那个重量的威力 for(int j=m-1;j&gt;=m-w[k];j--) //枚举背包重量+剩下物品 dp[m]=max(dp[m],dp[j]+v[k]); // printf("%d\n",dp[m]); sum=max(sum,dp[m]); &#125; &#125; printf("%d\n",sum); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>背包问题</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
        <tag>Nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wannafly挑战赛18-序列]]></title>
    <url>%2FACM%2FWannafly%E6%8C%91%E6%88%98%E8%B5%9B18-%E5%BA%8F%E5%88%97.html</url>
    <content type="text"><![CDATA[时间限制：C/C++ 1秒，其他语言2秒空间限制：C/C++ 262144K，其他语言524288K64bit IO Format: %lld题目描述有一个长度为n的序列a，已知a[1]=a[n]=1，且对于2 &lt;= x &lt;= n，a[x] / a[x-1]是以下三个数字之一 [ 1，-2，0.5 ],问有多少种不同的序列满足题意。两个序列不同当且仅当它们有至少一个位置上的数字不同，序列a可以为任何实数。输入描述:一个整数 表示n (1&lt;= n &lt;= 1e3)输出描述:一个整数 表示答案模109+7示例1输入5输出7解题思路：整体来看，a[x] = a[x-1] [1, -2, 0.5]，那么等于从n-1个[1,-2,0.5]中选出n-1个数值相乘（a[x-1]=a[x-2] [1,-2,0.5]同理化简式子），最后答案要是1，所以-2就必须有偶数个，同理0.5的个数要等于-2.顺序无关.那所有的转换中，就只要保证有若干组(-2,-2,0.5,0.5)存在表示偶数个2的个数与偶数个0.5的个数组合；组合数用二项式系数，杨辉三角来求。12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1e3 + 5;const int mod = 1e9 + 7;long long c[maxn][maxn];int main()&#123; for(int i = 0; i &lt; maxn; i++)&#123;//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(int j = 1; j &lt; i; j++) c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod; &#125; int n; while(~scanf("%d", &amp;n))&#123; n--; long long ans = 0; for(int i = 0; i*2 &lt;= n; i += 2)&#123; ans = (ans%mod + (c[n][i]*c[n-i][i])%mod)%mod; &#125; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>Nowcoder</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四六级考试]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2F%E5%9B%9B%E5%85%AD%E7%BA%A7%E8%80%83%E8%AF%95.html</url>
    <content type="text"><![CDATA[呃呃呃呃呃，今天四六级考试我昨天才知道，而就在昨天做计算机组成原理的课设接线的时候，我买了一个域名lruihao.cn做完后实验后开开心心回到宿舍解析域名，实名认证什么，coding和github双部署什么的，在一切都完成后本打算享受地躺在床上欣赏一下自己的“杰作”的，可是最后部署失败，作为小白的我，当然看不懂，然后又各种百度谷歌，翻博客，还是没有解决，于是乎我刚刚搞好的www.lruihao.cn 强势的显示出404错误，额，因为我不知道原因的情况下一激动把coding托管的代码删除了，还好github上还有个备份，被自己的操作蠢哭。搞到晚上11多还是没有解决，介于第二天四级考试，不舍地睡着了，当然也睡得很快hhhhh，确实有点累，中午没午休。。。今天7:30醒来准备好考试相关工具后，又搞了一下，还是无果，考试完，和女朋友吃了个饭，送到亲民后，我很快回到寝室继续研究，实在不懂，我做出一个大胆的决定，我打算重新搭hexo，然后我git，node，hexo 所有的东西都删了，简单暴力，重新来了一遍。。。最后，写这篇流水账不是想说我有多牛逼，多无聊（不过好像是有点。。。），我只是想试试重装后能不能部署，这篇博客能不能发出去。。。。唉ε=(´ο｀* )))]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单背包]]></title>
    <url>%2FACM%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85.html</url>
    <content type="text"><![CDATA[弱鸡还是弱鸡啊最简单的背包问题——。——！1）问题描述:假设有一个能装入总体积为T的背包和n件体积分别为W1，W2，···，Wn的物品，能否从n件物品中挑选若干件恰好装满背包，即使W1+W2+···+Wn=T，要求找出所有满足上述条件的解。例如：当T=10，共6件物品，物品的体积为{1，2，3，4，5，8}，那么可找到下列4组解：（1，2，3，4）、（1，4，5）、（2，3，5）、（2、8）。2）实现提示：可利用回溯法的设计思想来解决背包问题。首先，将物品排成一列，然后顺序选取物品装入背包，假设已选取了前i件物品之后背包还没有装满，则继续选取第i+1件物品，若该件物品“太大”不能装入，则丢弃而继续选取下一件，直至背包装满为止。但如果在剩余的物品中找不到合适的物品以填满背包，则说明“刚刚”装入背包的那件物品“不合适”，应将它取出“丢弃一边”，继续再从“它之后”的物品中选取，如此重复，直至求得满足条件的解，或者无解。由于回溯求解的规则是“后进先出”，因此要用到栈。使用栈作为该程序的数据结构，利用栈进行语法检查，以深度优先的搜索方式解空间，实现递归过程和函数的调用，在设计时还使用C语言的数组及其循环语言来实现程序。运用回溯法解题，在搜索解空间树时，只要其左儿子节点是一个可行结点，搜索就进入左子树，在右子树中有可能包含最优解是才进入右子树搜索。否则将右子树剪去。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#define size 50struct stacks &#123; int data[size]; int top;&#125; stack;void backpack(int number,int V,int w[])&#123; int i,j=1,k=0; int flag=0; do &#123; while (V &gt; 0 &amp;&amp; k &lt;= number) &#123; if (V &gt;= w[k]) &#123; stack.data[stack.top] = k;//第k个物品的体积下标 stack.top++; V -= w[k]; &#125; k++; &#125; if (V == 0) &#123; flag=1; printf("第%d个符合条件的解：", j); for (i = 0; i &lt; stack.top; i++) &#123; printf("%d ", w[stack.data[i]]); &#125; j++; printf("\n"); &#125; //k满时回溯 k = stack.data[--stack.top]; stack.data[stack.top] = 0; V += w[k]; k++; &#125; while (!(stack.top == 0 &amp;&amp; k == number)); if(!flag)&#123; printf("背包无解！\n"); &#125;&#125;void judge(int number,int V,int w[])&#123; int i,s = 0; for (i = 0; i &lt; number; i++) s = s + w[i]; if(V &gt; s)&#123; printf("背包无解！\n"); exit(0); &#125; if(V==s)&#123; printf("只有一个符合条件的解：%d\n", V); exit(0); &#125;&#125;int main() &#123; int w[size]; int V; int i = 0; int j = 0; int number; printf("\t**简单背包问题**\n\n"); printf("\n请输入可供选择装入物品的个数：\n"); scanf("%d", &amp;number); printf("\n请输入各件物品的体积：\n"); for (i = 0; i &lt; number; i++) scanf("%d", &amp;w[i]); //排序 for(i=0;i&lt;number;i++) for(j=i+1;j&lt;number;j++) if(w[i]&gt;w[j])&#123; w[i]=w[i]^w[j]; w[j]=w[i]^w[j]; w[i]=w[i]^w[j]; &#125; printf("\n请输入背包的总体积：\n"); scanf("%d", &amp;V); while(V &lt; 0)&#123; printf("输入背包体积错误！重新输入！\n"); scanf("%d",&amp;V); &#125; judge(number,V,w); //初始化栈 for (i = 0; i &lt; number; i++) stack.data[i] = 0; stack.top = 0; backpack(number,V,w); return 0;&#125;--这么简单的问题我都费力，太辣鸡了]]></content>
      <categories>
        <category>ACM</category>
        <category>背包问题</category>
      </categories>
      <tags>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18湘潭邀请赛参赛队员代表发言]]></title>
    <url>%2FACM%2F2018%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%2F18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80.html</url>
    <content type="text"><![CDATA[来自一位大佬的演讲尊敬的领导、教练，亲爱的参赛选手们：大家好，我是来自广东工业大学的tmk。今天很荣幸能够站在这里代表全体参赛选手发言，与大家分享我的经历和感受。刚开始来到大学的时候，我一心向学，本着“好好学习，天天向上，为校争光，不搞对象”的信念，想在大学一展宏图。因为高中OI的挫败，我在刚上大学的时候就选择了ACM这条“不归路”。一开始是因为高中的遗憾，到后来就完全是因为信念和兴趣慢慢一直搞到现在。当时的我还不知道踏上ACM这条路的苦，而如今的我却也尝到了ACM带给我的乐。在这三年里，有数不清的夜晚，我的舍友们在寝室里开黑，而我和我的队友在机房里开黑；在这三年里，有数不清的周末，我的舍友们在校园里驰骋，而我和我的队友在题库里驰骋；在这三年里，有数不清的假期，我的舍友们在召唤师峡谷里征战，而我和我的队友在中国各省市征战。三年过去了，我的舍友们成为了offer收割机，而我和我的队友成为了气球收割机。为了变强是一个痛苦且漫长的过程，只有耐得住寂寞，才能守得住繁华。我的一位队友为了变强甚至牺牲了自己的头发，仅仅是因为他担心他的头发阻碍了他思维的发散。他变秃了也变强了。三年的 ACM 让我成长很多，收获很多。我也从一个“好好学习天天向上为校争光不搞对象”的无知青年变成了一个写的了工程查得出异常的准程序员。我觉得三年献身于ACM的日子是值得的，和一大堆萌萌的男孩子们在屋子里面一个又一个通宵奋斗的酣畅淋漓的日子是值得的，看着谈恋爱的大家一会儿哀伤一会儿忧愁而我与代码自得其乐矢志不渝的日子是值得的。此外他还给我带来两个最好的小伙伴，是他们的一路陪伴，让我有勇气一直走下去。我和他们走过的地方，比我和女朋友去过的地方还要多。噢，对了，我好像没有女朋友。总而言之，请珍惜你们的队友，他们是你们在大学里为数不多一起奋斗的小伙伴。希望大家像我一样，也爱着ACM，为自己心爱的努力。最后预祝各位参赛选手们取得理想的成绩，也预祝本次大赛圆满成功。谢谢大家。]]></content>
      <categories>
        <category>ACM</category>
        <category>2018湘潭邀请赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[18湘潭邀请赛总结]]></title>
    <url>%2FACM%2F2018%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%2F18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[题目链接（hdu复赛）2018年湘潭邀请赛，在湘大举行，当时一起打的过去的，因为没出市就方便点。第一次参加现场赛，首先反省一下自己，比赛前算法先不说(没有好好搞过)，就连普通的题，数学性质的题都很少刷，什么都不会，然后英语不说四六级的东西，很多专业英语词汇都没有好好了解过，主要的原因还是刷题刷少了，英文题刷少了。理所当然，成功拿下一铁，湘潭赛打铁告终。比赛开始，这次是三个人没人一份纸质题目，拿到题目，看最后一题，k.2018发现可以做，(事实证明确实是一道水题)，我就在做这题，他们看了a题，好像是k题一顿操作后提交，错了，一直到比赛结束都没做出来，后来回去看别人的题解，发现自己情况没有分析全面，其实是完全可以解出来的，真的做的太少太少了。a题最后也是没过，还有一个f题，sort，我最初的想法是用stl里的那个sort排序，只要对sort的compare函数做处理应该可以完成排序，比赛之前我看过，但是不熟悉，zxm她也看了我就交给她了，最后好像因为爆long double的问题也没做出来。哎，菜还是菜，很多算法都不懂，数据结构也没学好，很有一段时间我都特别头疼算法，不想学，费劲，觉得自己不适合学计算机，更不适合ACM。有时候又想，不适合好像总是loser的借口！总是在后悔和偷懒的矛盾中！最后，放上，”参赛奖”羞辱自己，也是鞭策！]]></content>
      <categories>
        <category>ACM</category>
        <category>2018湘潭邀请赛</category>
      </categories>
      <tags>
        <tag>2018湘潭邀请赛</tag>
        <tag>ACM</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[F.sorting]]></title>
    <url>%2FACM%2F2018%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%2FF-sorting.html</url>
    <content type="text"><![CDATA[Sample Input21 1 11 1 221 1 21 1 131 3 12 2 13 1 1Sample Output2 11 21 2 3题意：给定n个元组(a1,b1,c1),(a2,b2,c2),…,(an,bn,cn)，将其按(ai+bi)/(ai+bi+ci)的值从小到大排序，输出排序后的n个元组的原序号；思路：编写sort里的cmp函数(形参为元组结构体元素，设为Tuple x,Tuple y)，若直接算出(x.a+x.b)(y.a+y.b+y.c)和(y.a+y.b)(x.a+x.b+x.c)再比较大小，这两个结果会爆unsigned long long；可以把因式乘积展开成多项式的和，约去两式中相同的项，得到x.ay.c+x.by.c和y.ax.c+y.bx.c，因此只需计算它俩再比较即可，结果不会爆unsigned long long后AC代码1234567891011121314151617181920212223242526272829303132#include "bits/stdc++.h"using namespace std;struct node&#123; long double a,b,c; int numb;&#125;ss[1005];bool cmp(const node &amp;a,const node &amp;b)&#123; long double suma,sumb; //suma=a.a*b.c+a.b*b.c; //sumb=b.a*a.c+b.b*a.c; suma=(a.a+a.b)/(a.a+a.b+a.c); sumb=(b.a+b.b)/(b.a+b.b+b.c); if(suma!=sumb)return suma&lt;sumb; return a.numb&lt;b.numb;&#125;int main()&#123; int n; while(cin&gt;&gt;n)&#123; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;ss[i].a&gt;&gt;ss[i].b&gt;&gt;ss[i].c; ss[i].numb=i+1; &#125; stable_sort(ss,ss+n,cmp); int i; for(i=0;i&lt;n-1;i++) cout&lt;&lt;ss[i].numb&lt;&lt;" "; cout&lt;&lt;ss[i].numb&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>2018湘潭邀请赛</category>
      </categories>
      <tags>
        <tag>2018湘潭邀请赛</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K.2018]]></title>
    <url>%2FACM%2F2018%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%2FK-2018.html</url>
    <content type="text"><![CDATA[K. 2018Given a,b,c,d, ﬁnd out the number of pairs of integers (x,y) where a ≤ x ≤ b,c ≤ y ≤ d and x·y is amultiple of 2018.InputThe input consists of several test cases and is terminated by end-of-ﬁle.Each test case contains four integers a,b,c,d.OutputFor each test case, print an integer which denotes the result.Constraint• 1≤ a ≤ b ≤109,1≤ c ≤ d ≤109• The number of tests cases does not exceed 104.Sample Input1 2 1 20181 2018 1 20181 1000000000 1 1000000000Sample Output360511485883320325200题意：给定区间[a,b]、[c,d]，问有多少对有序数组(x,y)(x∈[a,b],y∈[c,d])使得xy是2018的倍数思路：2018=21009(分解质因数)，则对x分类讨论:1)仅为2的倍数；2）仅为1009的倍数；3）即为2又为1009的倍数；4）既不为2又不为1009的倍数等价于如下分类讨论：1.若x是偶数：1）若x是1009的倍数，则y可为[c,d]中任意数； 2）若x不是1009的倍数，则y必定为[c,d]中1009的倍数2.若x是奇数：1）若x是1009的倍数，则y必定为[c,d]中2的倍数； 2）若x不是1009的倍数，则y必定为[c,d]中2018的倍数后AC代码1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;iostream&gt;typedef unsigned long long ll;using namespace std;int main()&#123; ll a,b,c,d; while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d)&#123; ll num1_all_1009=b/1009-(a-1)/1009; ll num1_even=b/2-(a-1)/2; ll num1_1009_in_even=b/2018-(a-1)/2018; ll num1_rest_in_even=num1_even-num1_1009_in_even; ll num1_odd=(b-a+1)-num1_even; ll num1_1009_in_odd=num1_all_1009-num1_1009_in_even; ll num1_rest_in_odd=num1_odd-num1_1009_in_odd; ll ans=0; ans+=num1_1009_in_even*(d-c+1); ll num2_all_1009=d/1009-(c-1)/1009; ans+=num1_rest_in_even*num2_all_1009; ll num2_even=d/2-(c-1)/2; ans+=num1_1009_in_odd*num2_even; ll num2_all_2018=d/2018-(c-1)/2018; ans+=num1_rest_in_odd*num2_all_2018; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>2018湘潭邀请赛</category>
      </categories>
      <tags>
        <tag>2018湘潭邀请赛</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B.Higher h-index]]></title>
    <url>%2FACM%2F2018%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%2FB-Higher.html</url>
    <content type="text"><![CDATA[B. Higher h-indexThe h-index of an author is the largest h where he has at least h papers with citations not less than h.Bobo has no papers and he is going to publish some subsequently. If he works on a paper for x hours, thepaper will get (a·x) citations, where a is a known constant. It’s clear that x should be a positive integer.There is also a trick – one can cite his own papers published earlier.Given Bobo has n working hours, ﬁnd the maximum h-index of him.InputThe input consists of several test cases and is terminated by end-of-ﬁle.Each test case contains two integers n and a.OutputFor each test case, print an integer which denotes the maximum h-index.Constraint• 1≤ n ≤109• 0≤ a ≤ n• The number of test cases does not exceed 104.Sample Input3 03 11000000000 1000000000Sample Output121000000000NoteFor the ﬁrst sample, Bobo can work 3 papers for 1 hour each. With the trick mentioned,he will get papers with citations 2,1,0. Thus, his h-index is 1.For the second sample, Bobo can work 2 papers for 1 and 2 hours respectively.He will get papers with citations 1+1,2+0. Thus, his h-index is 2.题意：给定n个小时，可以用其中x(1&lt;=x&lt;=n)个小时写一篇论文，那么这篇论文的”既定”引用数将会是x*a(a为给定正整数)；此外，已经写好的论文将会被其后写成的论文所引用，也就是说，这篇论文的总引用数将会是”既定”引用数+其后论文篇数；问在所有的写论文方案中(例如一种方案就是用n个小时写n篇论文，每篇论文各花1小时(可以得到这n篇论文的引用数))，h最大为多少(h的含义同上题)(每一种方案都对应着一个h，求这些h中的最大者)思路：最优方案(即对应h值最大的方案)是平摊n小时写成n篇论文(证明未知)；此时n篇论文的引用数为a,a+1,a+2,…,a+n-1，引用数为a+i时，引用数大于等于它的论文有n-i篇，令a+i=n-i得i=(n-a)/2,所以h=a+(n-a)/2;后AC代码123456789#include&lt;cstdio&gt;int main()&#123; int n,a; while(scanf("%d%d",&amp;n,&amp;a)!=EOF)&#123; printf("%d\n",a+(n-a)/2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>2018湘潭邀请赛</category>
      </categories>
      <tags>
        <tag>2018湘潭邀请赛</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B.Higher h-index]]></title>
    <url>%2FACM%2F2018%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%2FB-Higher-h-index.html</url>
    <content type="text"><![CDATA[B. Higher h-indexThe h-index of an author is the largest h where he has at least h papers with citations not less than h.Bobo has no papers and he is going to publish some subsequently. If he works on a paper for x hours, thepaper will get (a·x) citations, where a is a known constant. It’s clear that x should be a positive integer.There is also a trick – one can cite his own papers published earlier.Given Bobo has n working hours, ﬁnd the maximum h-index of him.InputThe input consists of several test cases and is terminated by end-of-ﬁle.Each test case contains two integers n and a.OutputFor each test case, print an integer which denotes the maximum h-index.Constraint• 1≤ n ≤109• 0≤ a ≤ n• The number of test cases does not exceed 104.Sample Input3 03 11000000000 1000000000Sample Output121000000000NoteFor the ﬁrst sample, Bobo can work 3 papers for 1 hour each. With the trick mentioned,he will get papers with citations 2,1,0. Thus, his h-index is 1.For the second sample, Bobo can work 2 papers for 1 and 2 hours respectively.He will get papers with citations 1+1,2+0. Thus, his h-index is 2.题意：给定n个小时，可以用其中x(1&lt;=x&lt;=n)个小时写一篇论文，那么这篇论文的”既定”引用数将会是x*a(a为给定正整数)；此外，已经写好的论文将会被其后写成的论文所引用，也就是说，这篇论文的总引用数将会是”既定”引用数+其后论文篇数；问在所有的写论文方案中(例如一种方案就是用n个小时写n篇论文，每篇论文各花1小时(可以得到这n篇论文的引用数))，h最大为多少(h的含义同上题)(每一种方案都对应着一个h，求这些h中的最大者)思路：最优方案(即对应h值最大的方案)是平摊n小时写成n篇论文(证明未知)；此时n篇论文的引用数为a,a+1,a+2,…,a+n-1，引用数为a+i时，引用数大于等于它的论文有n-i篇，令a+i=n-i得i=(n-a)/2,所以h=a+(n-a)/2;后AC代码123456789#include&lt;cstdio&gt;int main()&#123; int n,a; while(scanf("%d%d",&amp;n,&amp;a)!=EOF)&#123; printf("%d\n",a+(n-a)/2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>2018湘潭邀请赛</category>
      </categories>
      <tags>
        <tag>2018湘潭邀请赛</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A.Easy h-index]]></title>
    <url>%2FACM%2F2018%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%2FA-Easy.html</url>
    <content type="text"><![CDATA[A. Easy h-indexThe h-index of an author is the largest h where he has at least h papers with citations not less than h.Bobo has published many papers. Given a0,a1,a2,…,an which means Bobo has published ai papers withitations exactly i, ﬁnd the h-index of Bobo.InputThe input consists of several test cases and is terminated by end-of-ﬁle.The ﬁrst line of each test case contains an integer n. The second line contains (n+1) integers a0,a1,…,an.OutputFor each test case, print an integer which denotes the result.Constraint• 1≤ n ≤2·105• 0≤ ai ≤109• The sum of n does not exceed 250,000.Sample Input11 221 2 330 0 0 0Sample Output120题意：给定被引用次数为0~n的论文分别有几张，找到最大的h，满足被引用次数大于等于h的论文至少有h张思路：在区间[0,n]内二分答案；或直接从n~0遍历找到第一个满足条件的h后AC代码12345678910111213141516171819202122#include "bits/stdc++.h"using namespace std;int main()&#123; int a[200005]; int n; int i; while(cin&gt;&gt;n)&#123; for(i=0;i&lt;=n;i++) cin&gt;&gt;a[i]; int sum=a[n]; for(i=n;i&gt;=0;)&#123; if(sum&gt;=i)&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; else sum+=a[--i]; &#125; if(i&lt;0) cout&lt;&lt;"0"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>2018湘潭邀请赛</category>
      </categories>
      <tags>
        <tag>2018湘潭邀请赛</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A.Easy h-index]]></title>
    <url>%2FACM%2F2018%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%2FA-Easy-h-index.html</url>
    <content type="text"><![CDATA[A. Easy h-indexThe h-index of an author is the largest h where he has at least h papers with citations not less than h.Bobo has published many papers. Given a0,a1,a2,…,an which means Bobo has published ai papers withitations exactly i, ﬁnd the h-index of Bobo.InputThe input consists of several test cases and is terminated by end-of-ﬁle.The ﬁrst line of each test case contains an integer n. The second line contains (n+1) integers a0,a1,…,an.OutputFor each test case, print an integer which denotes the result.Constraint• 1≤ n ≤2·105• 0≤ ai ≤109• The sum of n does not exceed 250,000.Sample Input11 221 2 330 0 0 0Sample Output120题意：给定被引用次数为0~n的论文分别有几张，找到最大的h，满足被引用次数大于等于h的论文至少有h张思路：在区间[0,n]内二分答案；或直接从n~0遍历找到第一个满足条件的h后AC代码12345678910111213141516171819202122#include "bits/stdc++.h"using namespace std;int main()&#123; int a[200005]; int n; int i; while(cin&gt;&gt;n)&#123; for(i=0;i&lt;=n;i++) cin&gt;&gt;a[i]; int sum=a[n]; for(i=n;i&gt;=0;)&#123; if(sum&gt;=i)&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; else sum+=a[--i]; &#125; if(i&lt;0) cout&lt;&lt;"0"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>2018湘潭邀请赛</category>
      </categories>
      <tags>
        <tag>2018湘潭邀请赛</tag>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort排序]]></title>
    <url>%2FACM%2FSTL%2Fsort%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[sort使用#include头文件，sort(开始地址，结束地址，排序方式)，其中第三参数可以没有，则默认为升序排序。或者简单的用less&lt;参数类型&gt;()表示升序greater&lt;参数类型&gt;()表示降序也可以用一个bool型函数，比如：12345bool cmp(int a,int b)&#123; return a&gt;b;//表从大到小，即降序&#125;假设自己定义了一个结构体node1234567891011typedef struct node&#123;int a;int b;double c;&#125;note;有一个node类型的数组node arr[100]，想对它进行排序：先按a值升序排列，如果a值相同，再按b值降序排列，如果b还相同，就按c降序排列。就可以写这样一个比较函数：以下是代码片段：1234567891011bool cmp(node x,node y)&#123;if(x.a!=y.a) return x.a&lt;y.a;if(x.b!=y.b) return x.b&gt;y.b;return x.c&gt;y.c;&#125;sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组，数组类型可以是int,char等。实例:先降序再升序12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef struct data&#123; int a; double b;&#125;date;bool cmp(date a,date b)&#123; if(a.b!=b.b) return a.b&gt;b.b; return a.a&lt;b.a;&#125;int main()&#123; date a[3]=&#123;&#123;5,56.5&#125;,&#123;4,56.5&#125;,&#123;8,85&#125;&#125;; sort(a,a+3,cmp); for(int i=0;i&lt;3;i++) cout&lt;&lt;a[i].a&lt;&lt;"-"&lt;&lt;a[i].b&lt;&lt;endl; cout&lt;&lt;endl; return 0;&#125;​​​​传送门]]></content>
      <categories>
        <category>ACM</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C++</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[位运算]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2F%E4%BD%8D%E8%BF%90%E7%AE%97.html</url>
    <content type="text"><![CDATA[1. &amp;运算&amp;运算通常用于二进制取位操作，例如一个数 &amp; 1的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为0表示该数为偶数，最末位为1表示该数为奇数.2. |运算|运算通常用于二进制特定位上的无条件赋值，例如一个数or 1的结果就是把二进制最末位强行变成1。如果需要把二进制最末位变成0，对这个数| 1之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。3. ^运算^运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：异或0都不变，异或1则取反。 ^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即a ^ b ^ b = a。^运算可以用于简单的加密，比如你想对你MM说1314520，但怕别人知道，于是双方约定拿你的生日19880516作为密钥。1314520^19880516 = 20665500，你就把20665500告诉MM。MM再次计算20665500 ^ 19880516的值，得到1314520，于是她就明白了你的企图。还可以用异或来进行快速地交换数据，a=2;b=3;//先转化成二进制a=a^b;b=a^b;a=a^b;操作后a=3;b=2;4. ~ 运算~运算的定义是把内存中的0和1全部取反。使用~运算时要格外小心，你需要注意整数类型有没有符号。如果~的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000到$FFFF依次表示的。5. &lt;&lt;运算a &lt;&lt; b就表示把a转为二进制后左移b位（在后面添b个0）。例如100的二进制为1100100，而110010000转成十进制是400，那么100 &lt;&lt;2 = 400。可以看出，a &lt;&lt; b的值实际上就是a乘以2的b次方，因为在二进制数后添一个0就相当于该数乘以2。通常认为a &lt;&lt; 1比a * 2更快，因为前者是更底层一些的操作。因此程序中乘以2的操作请尽量用左移一位来代替。定义一些常量可能会用到&lt;&lt;运算。你可以方便地用1 &lt;&lt;16 – 1来表示65535。很多算法和数据结构要求数据规模必须是2的幂，此时可以用&lt;&lt;来定义Max_N等常量。6. &gt;&gt;运算和&lt;&lt;相似，a &gt;&gt; b表示二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）。我们也经常用&gt;&gt; 1来代替div 2，比如二分查找、堆的插入操作等等。想办法用&gt;&gt;代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以2操作来代替慢得出奇的mod运算，效率可以提高60%。​​​​传送门原文:http://www.matrix67.com/blog/archives/263]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ with STL]]></title>
    <url>%2FACM%2FSTL%2FC%2B%2B%20with%20STL.html</url>
    <content type="text"><![CDATA[1.swap（交换两元素值，在algorithm下，用法：swap(a,b);）交换两元素的值在C语言课上作为指针讲解的典例。int a=1,b=2;swap(a,b);//此时a=2,b=1(可以是其他类型)2.sort(,,)sort排序是不稳定的，stl中的stable_sort才是稳定的1234567inta[10]=&#123;1,6,2,3,5,4,3,8,9,7&#125;;stable_sort(a,a+10,greater&lt;int&gt;());for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" ";3.reverse（翻转序列，在algorithm下）//常用在字符串上int a[5]={1,2,3,4,5};reverse(a,a+5);//序列现在是 5 4 3 2 1char s[]=”ericxie”;reverse(s,s+strlen(s));//序列现在是 “eixcire”//同样适用于stringstring s=”qwer”;reverse(s.begin(),s.end());4.min，max（取大，取小）int a=1,b=2,c;c=min(a,b);//此时c等于1c=max(a,b);//此时c等于2string s=”qwer”,d=”asjk”,c;c=min(s,d);//c=”asjk”5.__gcd（最大公约数）手写gcd函数也行，辗转相除，辗转相减；12345int gcd(int a,int b)&#123; return a%b ? b : gcd(b,a%b);&#125;//直接用123int a=4,b=6;int c=__gcd(a,b);//注意下划线，此时c等于26.lower_bound和upper_bound（二分查找）lower_bound意思就是：找到第一个位置，使得：如果在这个位置插入value后，原有序序列依旧有序。upper_bound是找到最后一个符合数位置后一个位置，使得：如果在这个位置插入value后，原有序序列依旧有序。//数组int a[8]={1,2,4,4,9,12,12,15};int pos1 = lower_bound(a,a+8,4)-a;int pos2 = upper_bound(a,a+8,4)-a-1;//在这个样例下pos1!=pos2;pos1=2;pos2=3;根据我的理解lower_bound(a,a+8,value)得到的是一个地址，拿这个地址减去数组首地址a[0]，那么刚好就是value应该放入的位置。//vectorvector&lt;int&gt; a;若a中目前的元素也是{1,2,4,4,9,12,12,15};那么这里用lower_bound得到的应该也是一个类似于指针的东西，为什么不叫它指针呢？因为他有了一个名字，叫做迭代器。123vector&lt;int&gt;::iterator it;it = lower_bound(a.begin(),a.end(),4);//这里的it就是迭代器，那么* it就是该下标对应的value了。//set集合12345set&lt;int&gt; a;set&lt;int&gt;::iterator it;it = a.lower_bound(value);7.next_permutation （排列）bool next_permutation( iterator start, iterator end );通常用于生成序列的全排列。用之前先保证有序；1234567891011int a[]=&#123;1,2,3&#125;; do&#123; for(int i=0;i&lt;3;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; &#125;while(next_permutation(a,a+3));结果为：1 2 31 3 22 1 32 3 13 1 23 2 1123456789string str="STL";sort(str.begin(), str.end());do&#123; cout &lt;&lt; str &lt;&lt; endl;&#125;while (next_permutation(str.begin(),str.end()))；结果：LSTLTSSLTSTLTLSTSL大数据c比c++效率高123456789101112131415int length;char str[MAX]; gets(str); length = strlen(str); sort(str, str + length); do&#123; puts(str); &#125;while(next_permutation(str, str+length))；8.unique （去重）如何把序列 a 中的重复元素去除呢？首先需要对原序列 a 进行排序，保证有序后，调用unique(a.head , a.tail )就可以了。unique会返回一个类似指针的东西（和lower_bound有点像），-a后表示去重之后序列的长度。下面是实例。123456789int a[]=&#123;1,3,5,7,9,2,2,2,1,1,1&#125;;sort(a,a+11);int len = unique(a,a+11)-a;for(int i=0;i&lt;len;i++) cout&lt;&lt;a[i]&lt;&lt;" ";输出结果为：1 2 3 5 7 9 ​​​​传送门]]></content>
      <categories>
        <category>ACM</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>STL</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础教程]]></title>
    <url>%2Fhexo%2FMarkdown%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[本文来自kio对Markdown的基础教程其他推荐参考：https://segmentfault.com/markdownMarkdown主张使用最简单的符号来控制格式，兼顾易读易写特性，让你可以专注在文本创作上。这篇文章旨在让你通过大约三分钟来快速掌握Markdown的基本用法。在开始之前，需要特别注意的点通常，格式控制符号与文本内容需要保留一个空格段落之间需要空格一行标题在书写中，标题是最常用的格式，Markdown中，通过在文本前加上 # 即可，同时，根据#的数量可以可以划分为二级标题、三级标题、四级标题…一共六级。一级标题二级标题三级标题四级标题五级标题六级标题列表列表分为无序列表和有序列表，无序列表在文本前面加上 - 即可：无序列表一无序列表二无序列表三而有序列表仅需要在文本前面加上 1. 即可：1231. 有序列表一2. 有序列表二3. 有序列表三有序列表一有序列表二有序列表三引用文本经常需要引入一些内容，包括他人的话等等。仅需要在文本前面加上 &gt; 即可：Kio•纯粹写字文字修饰为了表达的抑扬顿挫，需要使用到粗体、斜体、删减体等来表明重点，其中用一个 * 号包围起来的文字为斜体，用 ** 包围起来的文字为粗体，而使用 ~~ 包围起来的文字为删减体：斜体 粗体 删减体段落分隔符通过 --- 即可以添加段落分割线：链接及图片另外一篇博文链接和图片可以为文章润色不少，通过 [描述](地址)既可以添加链接，而在其前面添加一个 ! 号即为添加图片， 具体为:123[百度](https://www.baidu.com)![Kio Logo](http://oss.blurme.idik.net/artemis/image/logo.png)表格12345|英文|解释|备注||:-:|:--|--:||Book|书| ||Hello|你好| ||World|世界|world|英文解释备注Book书Hello你好World世界world这样即可自动生成表格，第二行为内容对准格式，第一格表示内容居中，第二格表示居左，第三格表示居右。插入高亮代码如果你需要插入一些代码，Markdown也可以帮你自动高亮，包括行内高亮和代码块高亮，行内高亮仅需要使用 内容 包围起来即可。1代码块高亮至此，写作中需要用到的控制符已经介绍完毕了，Kio提供的所见即所得Markdown支持和便捷的输入辅助能帮助你快速掌握这一密术 :]移动端写作工具Kio：密码99o4可以导出PDF，md文件markdownx：密码a5n4SM.MS图床：密码ch0v若链接失效还可以去酷安上下载。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种Links汇总]]></title>
    <url>%2F%E9%80%9A%E7%94%A8%2Flinks.html</url>
    <content type="text"><![CDATA[我们在平时学习生活总会遇到很多很多有用的网站，也许我们收藏在了浏览器书签里，可过久了，不做说明，这些链接的价值就被时间淹没了，我们自己都记不起来了，所以这篇文章因此而生。对自己收藏的链接做些简单的说明(用了我一个下午)。ACM相关链接描述各大OJ题目分类各种算法分类，对应OJ题号超链接ACM题目分类codeforces俄国CF在线编程，一般比赛在晚上9:30和11：00牛客网国内求职学习网，有很多程序设计比赛vjudge这个不用说了吧hihocoder打得少，感觉好多数据结构的题百练OpenJudge的一个小组，很多题目来自POJ；也是我ACM启蒙地HNIEOJ湖南工程学院OJHDUOJ杭州电子科技大学OJPOJ北京大学OJ洛谷lintcode领扣国外leedcode国外codewar国外更多OJ，在线刷题网站…编程,学习链接描述visualgo算法学习，数据结构和算法动态可视化c,c++学习很详细的知识讲解w3school可在线测试,Web技术教程,HTML,浏览器脚本,服务器脚本,xml教程等w3cschool和上面不同哦，是不是和上面的很像哈哈哈！我估计是上一个网站的新版，功能更强大，内容更丰富，还有微信小程序教程等菜鸟教程和上面两个差不多，还有一些数据库、安卓的东西，git学习python学习Python库安装包下载,python,Django,HTML,ACM学习廖雪峰git,python,javascript学习新晴网PS学习，摄影教程等实验楼在线做实验,高效学编程web前端、在线工具等链接描述easyicon图标库图标下载，格式转换，可外链semantic-ui.com图标库semantic-ui.com还有很多前端样式对应代码Font Awesome图标库hexo指定图标库iconfont阿里巴巴矢量图标库emoji在线复制Simple emoji copy and pastehexo seo优化百度收录等极简图床使用微博，七牛云，阿里云OSSsm.ms非常好用的图床小贱贱图床快速，上传即得外链，每个ip每日限制20张优酷视频上传获取视频外链，其他：腾讯视频百度网站收录网站seo必应网站收录网站seoBing 站长Bing 网站管理员工具图片-七牛云图片存储到七牛云站长工具大全各种seo优化，工具等腾讯云dnspod解析新版入口，腾讯云控制台dnspod解析域名解析，其他：阿里云等cloudflare解析域名解析，https解析，介绍HTML字符实体网页特殊符号大全leancloud一站式后端云服务daocloud网站在线客服宅音乐播放器依赖jQueryButton样例20多种button样式，可获取源码encycolorpediaencycolorpedia取色器特效字转换工具集各种特效字转换工具,彩虹字生成器,RGB转16进制颜色等jquery之家web前端网css,js插件源代码分享懒人之家js特效，flash素材前端库前端很多学习交流分享网站gradient渐变色调色渐变色调色，获取代码cloud studio这是腾讯云和coding合作后的一个东西，简单来说就是云端开发环境。试了一下完全可以把hexo博客源码挂上面编辑。这也就不用只局限于一台电脑发布博客了。其他链接描述GitHub国外代码托管，分享，开源网站coding国内代码托管，软件在线开发，定位似乎和github不同，博客仓库gitee国内代码托管网站，又叫码云，定位和github很像,page服务存在收费在线工具w3cschool的在线工具集合在线工具开源中国社区菜鸟工具菜鸟教程在线工具，编译，加密，压缩代码等图标工厂移动应用图标生成工具，一键生成所有尺寸的应用图标大象代理收费，口碑不错表白网表白网页源码下载、demo表白驿站傻瓜式制作表白网页图片转字符工具二维码解码器草料二维码https://cli.im联图二维码第九工厂死磕艺术二维码模板码动态二维码等网址迷宫nazo_game一个程序员的网页游戏，我只玩到12关。。。无损音乐下载手写体制作北京大学计算机科学技术研究所的一个项目 （我的字体至今还未完成）湖南工程学院缴费查询系统湖工教务管理系统ubuntu pastebin代码展示托管，生成分享网址，防止代码直接分享缩进消失现实君外链支持多种文件外链，唯一不好的是http蒲公英应用内测发布平台everyfont中文字库在线压缩字蛛font-spider中文字库压缩PEXELS无版权美图网，避免配图侵权改图宝在线改图压缩，加水印，生成二维码，印章制作等soogifgif图及工具站长工具网站信息查询，权重，seo，网站速度查询，ping等mdtr2pdfmarkdown转pdfAD’s API包括动态签名，网易音乐等]]></content>
      <categories>
        <category>通用</category>
      </categories>
      <tags>
        <tag>通用</tag>
        <tag>链接集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[戏子春秋]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2F%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B.html</url>
    <content type="text"><![CDATA[从此故乡只有冬夏，再无春秋。湖南文理学院 杨灿 时间急促得仿佛还在昨天，还没有清楚地认识到这句话的其中含义时，我早已离开它，远去。 自此，一江绿水东去，桃花竞开，春洒满园；瑟瑟秋风里，稻谷黄时，落木萧萧；故乡的春秋成为回忆尘封在我的脑海深处。 三月，这里和故乡一样雨下得缠绵，却尽带着他乡的味道。在不是滋润自己的那方水土上，哪怕是喜雨之人，亦只有料峭的寒意。雨下到这里才懂得，为何古来才子佳人逢阴雨连绵天总是带着一股莫名的惆怅。原是这般由头！我与他们，并无二般，想起故乡来。 故乡的春是在牛耕上的。太爷说，老牛伏在岸边饮水时节就是春耕了。到那时，耕牛头角披红挂彩，鼻挂铜色大铃，以祈愿今年平安，田地丰收；当耕牛喘着鼻息，缓缓地哞哞叫着走下田，是其在田地里大展身手的机会。故而，二月春耕总是会见到红布条装扮的水牛在田间劳作，彩带飘逸，好生招摇，尤其是农夫哼起那极具故乡气息的耕牛民歌，如高山流水般，伴着清脆的铜铃声隐隐飘去……在春末，三月桃花尽开，漫山望去，粉红红一片，甚是好看。小时看到总以为身处仙山，而后来，陶渊明一篇《桃花源记》就以为自己是那秦时避乱而住在桃花源中的后人。每每与外人谈起家乡的桃花山时，必然是一副神气十足的傲气样子。我想，这也是自己不知不觉中受家人影响，又倾心桃花的缘故吧。 印象中，家里人都爱这漫山遍野的桃花。太爷爱赏花，山上桃花开得极好的时候，便移栽了数株桃花留在了院子里，天好天坏，都能观赏上好一会儿。太婆还在的时候，桃花次第开，她就会拾掇许多桃花下来做成桃花糕，那桃花糕香香糯糯的味道飘散四周，总能把我馋来。后来，太婆故去，奶奶学着太婆开始做起了桃花糕，却总是没有太婆做的如意。但奶奶的桃花酒，受到父辈们的一致好评。每当酒坛从土里挖出，揭开红布，酒气便带着桃花的香甜扑鼻而来。父辈们在太爷种的桃花树下把酒话桑麻，颇有一副桃花坞里桃花庵，桃花庵里桃花仙的样子。现如今记忆远去，酒香却长留下来，记起时，那酒酣甜得喜人。 故乡的秋从九月农收渐起，那时候一家老小在浓浓的秋意里忙忙碌碌，直至十月方才得些许闲暇日子。 稻谷黄时，是秋最盛的时候。父辈们清晨便出发去地里收稻谷。晌午，我兴起与祖母前去送饭。正午的太阳烈得很，父辈们大颗大颗的汗直往下掉，稻谷机嘈杂得很。这才想起太爷教我的诗，“妇姑荷箪食，童稚携壶浆”，就是这样的情景无差。那时候不懂得父辈的辛苦，只知奔入山间，捕捉蚱蜢，蛐蛐等趣物。等傍晚将近，坐在板车谷袋上，兴尽而回，一天就算结束。渐渐长大，再也不敢胡闹，不知是童趣少了还是知了人事愈发迷惘了？ 窗外又下起雨，心里竟也惆怅起来。并非是洗过的衣服久晾未干，而是伴着那股湿意而来，藏在雨里的那点点乡愁。这边的桃花也开得好，往窗外，密密一片，不免想起了太爷书房里的书画：花是春时花，却非故乡花。人是故乡人，却是他乡客。所见时，不过是从戏子变成看客了罢。]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[光]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2F%E5%85%89.html</url>
    <content type="text"><![CDATA[我们的光明！ Incorrect Password! No content to display! U2FsdGVkX1+ZxgbVMS+tC5T5zzpNT7klzUMv12Ccs9sEgxE/mgU/9cqBdHrC/x8RXFGgu12SERj8VYtDc6qRUz5HSxmraSo2mu7sE2MqkZBmw0RVtDbQcXDKn2iz6q9/WecXfZwdCpCaraNoShc6vrHtadnw0nFE4z4FNWJJDKEajmyiDtqOI93JpWOnWCrESmoWrFxuyTZEt7fBU3oWQ0Z0fD9HZmKj606MJBbGkZUxQ/RXKsHBOjVPc78zCjzF3pIOs4VPXWYRDWDmPNw/Ca7umrxxubMFV6pNZG4QEfs4/mrYXARCPQ8rm0Aiyyf5eoEsKb1AWSjrCcl0MU4hCyYGG1MTjqBf4S3gn74Atazcrft0BHsxoybJJEkNx9Vas0yZlC3ZW9tr2b9NPHrBfLbJRmSN5GlcHPTUWvXEm8+Sjj93lcsT6UdxhspFcpjgk/HUEIvvZ3VLfhDLEVs+ADluTm1hK74+2vX1hVvM5f3YlsLnroveDynzCAANzHQYIk/VDIJfFENnVHmzw0EbOu4ZgMleSkQ+nCVQ0AUt+fdzGSyqLfxVaISAzP0uVxkDVCtJghNJC67gNHw7nrL7OoYkNYTIIo+jySurT00EFyOcxHaQfYuUF4MioqV2bhp2mgOniXnPiHBO2Kpd4qbCe8KsbNdsgdKjFBh/1sumh1gsZOYDCXCJNI3lIbPwE8BhgImoy4/2b+ahqsS7uVDDHJ5YCPmdl6CKhuIj8tOYk93bq3NUESThnOqTtYxkC672CWDfWo1G9QDzG+/iBIOH6kY6y6WHfGqdQR9YLUQ9NpWA1Z/9ka3rjW2DC4SVSorK38ftpaupNi0UFwQxqdybF2rkh0/z15tnAzTOfJoZzLbXVISBQtrQMtdCRzZsupZbB6bxWAffS1JZHBwIcLESPF2lRp2bFCWGrpXBrNySQIpJXUyaBVsRkwLPg0Z/i4jGo0Qovy3YAPZLFVz/GHLk7LozjCARaiCdFUorO0qi0+F0GKDi2/1OhPu4HyXOyDI1dGvuKNYjSWrm2KhE//7wfgquaeCax1uG8ddrPt37ggp+Nmgr1SzcVB5SwQCbbrPdYUNkKFODEV4iAJxaHqXidm2VTl5bHv06fFxOjXMAs8KL1K6B8h41Sg7Z48fTbW86RZdZiyfksHl9fFq/L1zYmQ+Ec/2uYdnecbbYY4zqJc7I3T6giy4f/Q7lcowkBzeVbx1wHOg8YPKtlyKvE6Tyz4bW4MVyejHWrzsEt5+7ZWrOzTkBTz1aCW2li5GUr+Glkf89fJ5ywiosqHywMNW51t4wftswiUNuheTx6K2YxE8e1WLVyQEZI+XNC++2Tkr8LfUvxsYq9YVKidN0cr8R1tNOXoJUbUXSjLoDzS79QRu8BtEleDc5wI+epfft4woPSCVf+iapd36z4tE44f4W65vU31Fv6nTx2nV/T3OByNG5kzVChto9LLu/bedbvZUVn5natfBUpm70jkXlwruOygwN9eXhA0mmJOX4ssJD0bPKRv8UqL732dlJhQu3jzWDRdWVUU8InToNXLt8iUudHIKADwEm8YzAs77fgYDFFqJQgadLzNGXtSdAckmUxjTmLi9Of+nPlslWo7JR4X2CNSzqQ1X5InRtqWCHnKD4ZxR607Kv/ywCeRoazLrmdFvCczIs138SZwcswYeryiGctuSh4NMLZCJHgy2DcQBpP1Towh8KqGDpUISFdpiWhXx/spu4VYN6ORu6JRXbQMXH2sc3Xer1/o3xBjehh3to2qr/4V+Fn5XHI12L8CbxGdj5YFRqXXSDP6PBjFx1Gf9CLALxB6McvdQsmtOn9nQUCeWZPD5+N6WjGyRFDnse11DLzo+lk9hdwl1cKHYZLIEQpySg5IwiL3qn1L0wYl7h8KdxdCbapzGpyUY4RYaycrStgz1V658klr0LP+erJ5pKzOwSq7GGwRml29FejoGJ+y7sJgi/Ner+wv1jtpfhSnWZ+jQWytQFZZeYB31r1BlYzrewNOzXctfI1fG9sFNJfhyr0as6ltuO0aCK0CkXaX+xspDrtwEt1f20ltOmDjyvU/VLfWg36A2AWcqieuxXR3A/fxgiIW6E1z9V4Un8Vn/yDoweB2T++ODJTw+E2ge3gJxYHvEdWtW7FZGyupsND77AerboSp6ql+zzvDhNUBXnunLLqNXRQwKZm0Jzmtr7DFyXSVLFuiJebN/gWHD/0rj9AL+aKAqqg5di5jfeJlQIczvuh2TIJHQAv2t+Da5xY65MZuhmdTvbVEqlaND8hanZXZNzg3EwLUfMV/abIjHjeunyU9Fy9AL0QZSiFzPU9g5sx9bBY/Jean55fZ/OHCFaJBvKUTShUgeFXSofBh5Y+b1t/6NelYO2Ky6f31TkEIInoxO6tsgNeoB6vK8Z67vacwYVoeEAgRhlIXeD+K90qz+zNj8+XEikj+MM/qdFa95iVHnmnC2vuvL350o242IwPMZSJXfb9R5+SGYMpxy1f2COPJ8YPhG7GyF+IIW9txWJtmJZxnOC3/0TIUch8STgluI7hyvpQl1QPApRD0PjFlq4D5BmFr2chdhwsP6YUd7EzcM06LdMeGHd/qhfGVh4Pf0Kc+ztxM7TMYszU77fPnXxGS20s9YEp0MX2oUwmzLFWqzc5CHWCWdY6MG2vtKhUu/I5kXYWOrf0EAxsa34tOrNDP8S1gbXSit6sRWZqbg8pCa+r5+QBzL8YO/v+54uuxKioRdh9C15mpLQYLBgZ6J0kNqyVwaBki6gqI+tMnWuy8wBot6NzaWEErIs0v/MVO44lp+cgyCmG/MvdxqvZiTY4UDcVyBZAUvq9h4S4NrDio5qKhpCyADGz55PvsIBHZMhBH7Xmlpc6i72t7FxcCAvYkOlKCFTpiPYasVMn47Qj0p+8a1sW/dyQSk/Vghf2nxFasePJnoIKCc04DMEXie//Jqw22CBnWQ9L0rexch9aNvpbnzCoZDoAq2dunCMRRIgycSfPz89MJma3E0VYJN+PLtvJbbwxBMhWsbT6jExnW9pMNaYYj5DYaAkDhS2yEN1REfM2doULYr/37guM4TZzvHzs8FG7WdMxJjyh70C1N40HKswb+9qLarpLAbd499n0hI27MEjg/nGlaA6D2PS1hterlYXGFVQk7qrELtJ44Q86SWOAf/hsxYkmOw3o18fE6ZUwcUEdaQVK9bffQTFnYYcMT0TYuAeBvtirK1XJdmnzY8wDnK6rJ3RmnQ4rNBm3JsRm7nnUbczjEhQ6xQXKpi18vkbaBDgTlDpgFh37wS+tFhCelQiV2G+5BEUDqx5/jfx6gNUmXIdNSUg3/XQ86f+gACKnRCQKwoBLQkZr3A7613iPiz9/sU5M5UV0e9qFS/242gh2TeArOZ0DpWbj/BCqYZ5hvzAXBi4cwXIB7+N44iQEXuNYa6uIPkvx6UEE564YbsmYJxV4DT7wQhCPcugan7MkhBxu2c3J7W5DNdjpRbfzg85+rYRkpk6FxzzA8zWVS3Ny2izQsx6FDkELI+Xro473PLYys6Qdh5g30yq47UW34YDzKMEs53ijgFMrsysG4vs7nxvTyDOsPEcZPYfGwfrs8Np/H+2b4s+1cm/PyyOtSJdRdOb3NEaLuMVQhQeLIdXSykqP8bXiGcLCpHtRB1tCIurTEgxqApUhP44gVpVZicb0kODVzvBrKuCF09su/sS9Aaw86e4dPP0iWX7nllC0ROB8Pi7BMDShw71O0DKtv8Pi4kKUi05+CZlJ1TQfY1WZwoYQ4Ls+4AL1oiRpJ8qZiuzviOWknGbcVnLzmLaEhwd7wA0XpIG2Ja0Plzg3bkL58mAvYNKchov9NYLvmFSZrEqzqltn68GsKIiepQ1DOYDCS78uPIDUKVnwK6f9kZWV6FpDXrnb7s5sxdywb/F+6mmYPJwLeIbzxEUs71af8BO2igXW4euqLbTTeKKZ/p1XcOiLAMslBW1Eb467KOR1AP2BocRAw0T9c4y4M+8phiaEbZae828ffD7b622pw1gDJcCQ/jAqqAczaimSjg0y7/hcr1KtuT+7GkfggkIEEPzwVHrB6TdJnCXEsv3+AIW+ox2JIL0sAhwxfJYkNRJRhnlMY1A5e5a+duNJY6dU8X2V6EtYykaW96zumrtAHE369Z6Vjk7pZsEcljiZUVkCzaokMhWHqd1JvjT02hKXpplwRtxLcHbQy+xvCsSDRXjoTlzP+uJJHg6cD3ncVV3FC5By3IS1Lj+ElI0kKS7k/Sfepj5zyGostZblZIzm6cSWJjgNkpuJjFBvkvpqn3/UR09jTkosELqQPblPVo2oUBEzVWg7DjyQFNJhjmMJKd98j+Cj9mjg9bW9NNdiqBNtfdkYEJ3gJLrPXk0METnbWKDqYWcvQbFekvAOuQJwCQKVs19wTTqOu3GwDHFWhn7vq2y2BsRi366gXvzZyjuzsF5zswIEbd6GAEjW2GTw7scCneGaWmYwJr3/kI5xjPcKniUM4VDIrBcWYK63wlQMbvtJRc6zD+OljqOg70knH+teAsob4AoJTmiAaKPgyC5UQHITbQIsyTMl74DFQ/Wca/02hcze7zP3vuBe04XN+sS0UY/bqrRkeYXTLp+XMoyiyrF3H41zo3NDrebktwnO2niMAPv4cYRq51uiADPHvo0s3XRGrkyi0OEMve7ZXFtDPe5vGhDFlXcUOWQloqawewRcFdiIHIKnfvBZr6H+vubsLfnPtCvltA20VRjByyro3eZpk5jcr4IpX/FiDa1gachR5ZzpfPFKUhaBRQQzlGbaB8Svpy+9/1ePqqS2dyTdY3c+dfolw9BGniXA0H4/eYMPqwNgtsvjO2dsOX37RARKCVP5mPEZLMT8YYAv4NvJ/qZODh2H8iOpa7PuDOWgHeb7pTrkYnEH8f/Gi+QQ94BFHkCX5IA30jfWx1DaD8lPxOfLMmQvfX4yAYdz/7UXB1SX+tCW2X8jJianfUQNueiwUARcN89LWI+6F10oWHKCnwXWneQsPLaACkon1ZMjNaDhiyHX/DcT6wYXla/W457xjZSamI6FRWRGiO+H/vR89UYJ5IoFVBDxchrZSUI7r4TpCmp0WTuhO1rwVF4q0E6Nkk6IB+kRY7aSHC1fYnMzFz03j/07Fvs3UIpsvv52DSpJtzwKnwX7CPcwFddDi8C9EfsckIyznH24VLyPeReGBSMF6UPqRIR9Zo4dzZe3pz59KrXmuZidzWPLwKTx7OSopWPqGVCOM5RjnYg5MejlHpu41KvNKQdpmifjnbiPtialCIt3ztpdOEtC5zRZCIdX9SyiOCf598nlAz9Dyl5DwIQc3fRvuDEsEuprveGqzXY2IzMnHrpwAm9CcfP3OOSermPdooPMq72FujD8XoiunlZ9TdzrMhkFv0uxHYwRB1maROrhoyaqh6TOXfsBpEmnUJ3kFcMngPAuBT8Gb30ztEVLSna+1mCB5t0KeMWYGBYBeFm0gqqzGv0aKPMtX1f8zVMLlcZiP+w30BD2XIW1itLCr7Zuz04le0xUZ9JaLJWA4XPILQci+qBGXu+3BSp/1zSrv0C2UtY8OTMhX1Wfw9H5xTB/p1uAYp91dCtvFMNkRSrjZm/VdetSySqcid7/17Z8ww7z1HIkCGAoeI3HmAWvWYLRyltSv9ATyEsIvVxJkwxDsn3wBoLezSu89mG1efaq9yCV/jv+DmzZ4WAoT4ClEg3sOCqOlbpmAQ940RjuzyvLWmz4SrdawKR/ru4necln3tLSN2enDOFHH0jPT1bUXeDQMTJErlMfxYfp5yxIyYOpE48YWTwyKamNjsYNe6pyyBZ9DnkfexsOCtShDrukPNk82XNVBfhY/apqcoNeJ0WQ5o32H3hHCSqi1xi/tu/T13hIyui/DMnA+trNJfGMTiJy2bFlw5faGb4LXRqtyXfFklINYOUW0BX+oNH5S2z/Wz/pVh2N3qxBf7epkulrLMRiP8WovWH0GG666ZU6J4dhz+mjcuqSfJAvylHguEXuGZ0nEMHBZ7ho2jnv4CPRSsPfSg0CYca7L4p+i48mCeVdvwOqTvSUvCRFldLNDac5Mx+ZPgE7vXxOq0uPZ7NQ43xMS1R2tkLE+hDkU8e52uVb3SB1lm9E6ypn1h9PxUcSJuYJ9PuSYgH4b9kOim0xCnv8dj7eXKmD0VMdR8W59Aj9czd977FtS5Jfhb7LoRJSeCMfGG59s8qJv0oz0rcVnqeE3tys7OkrYplQdpuYfPFnyL792DK0HmYqXXKSxKUVzzr33SFrwtAHhCeH05FMfKOkQ8fhI2StLoZEl08ZNaPcMIrilF51ZLCV3h7mfg4S1JyyaNwFBnahe4AdPF1YxbHY/feWpAOSRaj1lGGkjcHH8mfUlRmEM23/kwZFYpoz5Qk2dTFkWyID2uooHPY2N+PWVlSFd+drToJzbgfV5FDXU5deCIjcKbdmx7s7heuwIg1VyocRxRRN9RVlV65gTkacsogX8kSLhLES70KnLoI3NWs+j3h7nMtHb6yI/ECO7nlYkmq+I7EytQNj++lKWZKXZ1nBrkQwHeYZ0hkX+i3U78C40No32aTlbwBtQ4KNmiqhjDaiitUkzucOtLUsoqCu1S9zYjMDwdRpKHGCRbSwM68Y62of6JxHz4uTNcTIl9jAOfm78jm59kg+mgGhNRZHooCpZDuvJx4xSv26xq/GXsSamYLw11TTcr1cCj9itklFXgaVL4Xcc06bLNe9pEt29Ex0Qam20ZWu08QWX90SPoXtLAiMpC6JCsYL2wM1hRw3Li3faDcOpUg2AfKpCQ5SPTw2eTisz+ZvijRHaWyfusb//igk7UnshJJ3SONa0+qiQ/mb8KrO+MeIHD1r4iebMRjOS1VXHEZfurzN+QRXJ+iZ50yJ5cfkSW9o0VdQgckpX2swp0Hsc/4RuBCcSB7P7PSk8c22h1Xt9Y385IBCoxVrA04sQNb9hAAkKpPvmxbEqdBMZ2/kxpTR+Q1wpexXu3gUHJwFyq3s7DRU8KeVnWRYj0im4pBSiKmvq9wocnuf3do/pxBBTQU77Vj0zT/tXsdUBhr0Nb9Q9V6z3cEWwo34ZP/jXybJhAbktinm7QU2zjXPXGORinKUIJJaPU1yS20vs/mZmW8+W7IMKStvt97AU77j6wnlX6h46LzDjjgvf7VnUclL0s+mJr6j50vliJOYZy/4wTn3WRGP1xGa3uN2XzlosEZ+7nw/lp5fKB/DuI8V+QSE19SwmYD9HsEnzW0cMzGPaeQ0CNWUi4wNIaD/FNrAeUPVF/TuxPABEN6+K/SO2rxNefWAneR3hUdQ/Rl5Ox14vaIy/2AlhjHfnDsjK6Gp0RJOCBeCMgA8W5woSJg7H3ouo+MBGGMKMUp/PtFYDYs9KE+4cGjCsveUDzvtJqHIj2I5/YgZej8/VVSWorRm2P9NllRXWy1HTL3NLCoSzqv/fWxuxMFHA3MSgV+itam5Dj8rFlRhLnjHWYaH+WH3XPsvYKDFktZRn7CZ8rDw/aaZuRBJ4laOEUmyDXB7qKBH9ehDZdQa3flj9CjWgExVQyykH5enqpot5coGByAS/4ZGvsRfFvFmeNtdO+I4yL82+KVvDYjVKpEeY5BJnMSPRlJZUWlMu7TiS5wZ8ct6NK12x6i8O28E+q5XoA=]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[换主题next]]></title>
    <url>%2Fhexo%2F%E6%8D%A2%E4%B8%BB%E9%A2%98next.html</url>
    <content type="text"><![CDATA[next使用手册用了几天aloha主题，最开始看中的是他的简约，主页就是归档，看起来很清爽，可是没想到功能也简约，用了几天很不爽了，换回了next，最近要考试了，有时间再配置。。。next功能果然很强大，配置很快，next使用手册也很详细，如果不想入坑，建议第一次直接使用next主题]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客及美化]]></title>
    <url>%2Fhexo%2Fhexo%20%2B%20github%20%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[更多关于hexo首先官方文档是我们的第一手资料，也是最好的。安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：Node.jsGithexo安装如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。1npm install -g hexo-cli建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install为一个文件夹的名字新建完成后，指定文件夹的目录如下：12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes安装hexo插件全装上吧，没事。。。12345678910111213npm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-deployer-heroku --savenpm install hexo-deployer-rsync --savenpm install hexo-deployer-openshift --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save本地查看效果执行下面语句，执行完再登录localhost:4000查看效果（执行完不要按Ctrl+C，不然就停止了）12hexo ghexo s其他步骤在这里不赘述，参见超详细教程安卓上搭建hexo博客部署1hexo g -d部署后我们可以浏览器搜 username.github.io 查看自己的博客效果，，比如我的lruihao.github.io美化这些美化都写的很详细，我建议你们自己好好看看吧，我也是在这里看到的，如果问我和这里说的是一样的。valine特别鸣谢赵俊👍asdfv1929hexo官方主题集合，我用的是aloha主题，该主题官方文档，后改用next主题hexo官方插件hexo个性化教程说说我的主题遇到的一些问题，由于这个主题用的人少，所以作者优化的不是很好（next使用最多），当然也可以反过来说，所以自己美化了一点博文置顶修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;;about页面about页面可以用HTML写，你想怎么写都行，我用的最简单的方法，直接hexo n page &quot;about&quot;后，会生成一个md文件，也就是后面说的文章，直接写文章就行了。添加搜索，评论，分享搜索功能真心好用，当文章多起来的时候，标签提供的作用已经很少了，只能简单索引，搜索却能精确查找，这里我用的依旧是最简单的本地站内搜索。安装hexo-generator-searchdb在站点的根目录下执行以下命令：1npm install hexo-generator-searchdb --save配置站点配置文件新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000配置主题配置文件123# Local searchlocal_search: enable: truealgolia参考文件让搜索引擎找到你的博客，还是看到邱承佳学长博文有写到传送门添加访客数，阅读量等评论有多说（多说好像挂了），计数有不蒜，我用的不蒜子，还有其他的。。。文章阅读量以下适合非next主题的部分主题，next主题已经自带，到主题配置文件修改就好了。打开以下路径在你喜欢的地方添加代码，\blog\hexo\themes\主题名字\layout_partial，找到article.ejs文件1234&lt;div align="left"&gt;&lt;span id="busuanzi_container_page_pv"&gt; 本文总阅读量&lt;span id="busuanzi_value_page_pv"&gt;&lt;/span&gt;次 &lt;/span&gt;&lt;/div&gt;站点访问量，访客数打开以下路径在你喜欢的地方添加代码，\blog\hexo\themes\主题名字\layout_partial，找到footer.ejs文件123456789&lt;script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_page_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次 | &lt;/span&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt;2018.10.08更新不蒜子官网说七牛强制过期域名dn-lbstatics.qbox.me,所以js文件位置发生改变，改为busuanzi.ibruce.info写文章hexo文章用轻量型标签语言Markdown编写markdown入门繁体原始文件繁体原始文件github]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 添加图片，音乐，链接，视频]]></title>
    <url>%2Fhexo%2Fhexo-%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%EF%BC%8C%E9%9F%B3%E4%B9%90%EF%BC%8C%E9%93%BE%E6%8E%A5%EF%BC%8C%E8%A7%86%E9%A2%91.html</url>
    <content type="text"><![CDATA[如果实在搞得头晕直接去简书写文章，再把简书生成的md文章复制过来就好了（简书是个不错的Markdown在线编辑器），还可以去马克飞象，专为印象笔记打造的 Markdown 编辑器，typora 也是不错的，突然发现csdn也支持Markdown编译器了1.首先刚刚搭博客，很多都不懂，就连插入图片的路径问题都把我整的要命。。。（我用的Sublime Text 3编译器）下面讲讲：1.1 设置站点配置_config.yml1post_asset_folder: true1.2 安装插件1npm install https://github.com/CodeFalling/hexo-asset-image -- save1.3 下次再运行hexo n “xxxx”来生成md博文时，下路径1/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹，在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片。2.添加图片首先大家可以查看hexo官方文档资源文件夹章节2.1 markdown添加相对路径添加（我被这个相对路径搞得要死，前面各种出错，大家可以对照我的来插入图片…）1234567#直接写图片名就好了，图片实例见下![kyrie irving](294136.jpg)#如果改了Permalink就要加上文章名，即同名文件夹名![kyrie irving](hexo-添加图片，音乐，链接，视频/294136.jpg)#代码压缩后前面还要加一个/![kyrie irving](/hexo-添加图片，音乐，链接，视频/294136.jpg)2.2 插件添加传送门这种方式被很多人诟病，但有时候也不失一种好方式，简单快捷。还有图片名字显示，不错的。1&#123;% asset_img 297787.jpg kyrie irving %&#125;3.音乐大家可以看网易云音乐的官网，播放音乐可以生成外链，直接拿来用就行了。iframe插件可以在代码中设置宽高等参数，auto为自动播放。flash不可以自己设置参数。看喜好，随便你。其他音乐，把插件中的链接替换成要播放的链接就可以了1234#iframe插件&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=330 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=66651&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;1234#flash插件&lt;embed src=&quot;//music.163.com/style/swf/widget.swf?sid=40249713&amp;type=2&amp;auto=0&amp;width=320&amp;height=66&quot; width=&quot;340&quot; height=&quot;86&quot; allowNetworking=&quot;all&quot;&gt;&lt;/embed&gt;4.添加链接1[我的微博](https://weibo.com/liahao)我的微博5.添加视频视频链接最好是打开就是视频的链接（youku，YouTube，抖音等）可以把视频上传到优酷，抖音等生成外链再拿来用。（优酷上传需要注册和实名认证）参考资料自拍手写视频（优酷）实验室无聊拍的12345&lt;iframe height=500 width=100% src=&quot;https://player.youku.com/embed/XMzY0MzgxNDMyOA==&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;工具集合马克飞象、CSDN、简书SM.MS图床]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猴子与哪吒]]></title>
    <url>%2F%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94%2F%E7%8C%B4%E5%AD%90%E4%B8%8E%E5%93%AA%E5%90%92.html</url>
    <content type="text"><![CDATA[一直觉得中国古代神话能称得上传奇的只有两个人物：一是猴子一是哪吒百世蕴灵育出只石猴 大闹天宫腾云驾雾三年怀胎生了个哪吒 东海屠龙翻江倒海可以说 除了这两人 没人再能当得起离经放纵四个字的但称得上悲剧的 约摸也只有这两个一个五行山下压五百年 揭了封印 戴上金箍无悲无喜 拜佛西天 唤孙悟空一个削肉还母剔骨还父 塑了莲身 站上火轮无怨无恨 封神南门 号三太子这尘世最擅长的事 大抵就是抹杀疏狂者的落拓 磨平豪纵者的傲骨 斩灭叛世者的孤妄]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
      <tags>
        <tag>生活随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fnull%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
  </entry>
</search>
